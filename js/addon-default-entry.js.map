{"version":3,"file":"js/addon-default-entry.js","sources":["webpack://GUI/./src/addons/addons/color-picker/style.css","webpack://GUI/./src/addons/addons/editor-comment-previews/userstyle.css","webpack://GUI/./src/addons/addons/editor-searchable-dropdowns/userscript.css","webpack://GUI/./src/addons/addons/editor-theme3/compatibility.css","webpack://GUI/./src/addons/addons/find-bar/userstyle.css","webpack://GUI/./src/addons/addons/folders/style.css","webpack://GUI/./src/addons/addons/middle-click-popup/userstyle.css","webpack://GUI/./src/addons/addons/onion-skinning/style.css","webpack://GUI/./src/addons/addons/pick-colors-from-stage/style.css","webpack://GUI/./src/addons/addons/reorder-custom-inputs/arrows.css","webpack://GUI/./src/addons/addons/editor-devtools/icon--close.svg","webpack://GUI/./src/addons/addons/folders/folder.svg","webpack://GUI/./src/addons/addons/onion-skinning/decrement.svg","webpack://GUI/./src/addons/addons/onion-skinning/increment.svg","webpack://GUI/./src/addons/addons/onion-skinning/settings.svg","webpack://GUI/./src/addons/addons/onion-skinning/toggle.svg","webpack://GUI/./src/addons/addons/bitmap-copy/_runtime_entry.js","webpack://GUI/./src/addons/addons/bitmap-copy/userscript.js","webpack://GUI/./src/addons/addons/block-cherry-picking/_runtime_entry.js","webpack://GUI/./src/addons/addons/block-cherry-picking/userscript.js","webpack://GUI/./src/addons/addons/block-duplicate/_runtime_entry.js","webpack://GUI/./src/addons/addons/block-duplicate/module.js","webpack://GUI/./src/addons/addons/block-duplicate/userscript.js","webpack://GUI/./src/addons/addons/block-switching/_runtime_entry.js","webpack://GUI/./src/addons/addons/block-switching/userscript.js","webpack://GUI/./src/addons/addons/color-picker/_runtime_entry.js","webpack://GUI/./src/addons/addons/color-picker/code-editor.js","webpack://GUI/./src/addons/addons/color-picker/userscript.js","webpack://GUI/./src/addons/addons/editor-comment-previews/_runtime_entry.js","webpack://GUI/./src/addons/addons/editor-comment-previews/userscript.js","webpack://GUI/./src/addons/addons/editor-devtools/DevTools.js","webpack://GUI/./src/addons/addons/editor-devtools/DomHelpers.js","webpack://GUI/./src/addons/addons/editor-devtools/UndoGroup.js","webpack://GUI/./src/addons/addons/editor-devtools/_runtime_entry.js","webpack://GUI/./src/addons/addons/editor-devtools/userscript.js","webpack://GUI/./src/addons/addons/editor-searchable-dropdowns/_runtime_entry.js","webpack://GUI/./src/addons/addons/editor-searchable-dropdowns/userscript.js","webpack://GUI/./src/addons/addons/find-bar/_runtime_entry.js","webpack://GUI/./src/addons/addons/find-bar/blockly/BlockItem.js","webpack://GUI/./src/addons/addons/find-bar/userscript.js","webpack://GUI/./src/addons/addons/folders/_runtime_entry.js","webpack://GUI/./src/addons/addons/folders/userscript.js","webpack://GUI/./src/addons/addons/middle-click-popup/BlockRenderer.js","webpack://GUI/./src/addons/addons/middle-click-popup/BlockTypeInfo.js","webpack://GUI/./src/addons/addons/middle-click-popup/WorkspaceQuerier.js","webpack://GUI/./src/addons/addons/middle-click-popup/_runtime_entry.js","webpack://GUI/./src/addons/addons/middle-click-popup/module.js","webpack://GUI/./src/addons/addons/middle-click-popup/userscript.js","webpack://GUI/./src/addons/addons/move-to-top-bottom/_runtime_entry.js","webpack://GUI/./src/addons/addons/move-to-top-bottom/userscript.js","webpack://GUI/./src/addons/addons/onion-skinning/_runtime_entry.js","webpack://GUI/./src/addons/addons/onion-skinning/userscript.js","webpack://GUI/./src/addons/addons/paint-skew/_runtime_entry.js","webpack://GUI/./src/addons/addons/paint-skew/userscript.js","webpack://GUI/./src/addons/addons/paint-snap/compatibility.js","webpack://GUI/./src/addons/addons/pick-colors-from-stage/_runtime_entry.js","webpack://GUI/./src/addons/addons/pick-colors-from-stage/userscript.js","webpack://GUI/./src/addons/addons/rename-broadcasts/_runtime_entry.js","webpack://GUI/./src/addons/addons/rename-broadcasts/userscript.js","webpack://GUI/./src/addons/addons/reorder-custom-inputs/_runtime_entry.js","webpack://GUI/./src/addons/addons/reorder-custom-inputs/modified-funcs.js","webpack://GUI/./src/addons/addons/reorder-custom-inputs/userscript.js","webpack://GUI/./src/addons/libraries/common/cs/normalize-color.js","webpack://GUI/./src/addons/libraries/common/cs/rate-limiter.js","webpack://GUI/./src/addons/libraries/thirdparty/cs/tinycolor-min.js"],"sourcesContent":["exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-color-picker {\\n  display: flex;\\n}\\n\\n.sa-color-picker-code {\\n  margin: 8px 0;\\n}\\n\\n.sa-color-picker-paint {\\n  margin-top: 16px;\\n  margin-bottom: 4px;\\n}\\n\\n.sa-color-picker > .sa-color-picker-color {\\n  border: none;\\n  border-top-left-radius: 1rem;\\n  border-bottom-left-radius: 1rem;\\n  padding: 0;\\n  padding-left: 0.6rem;\\n  padding-right: 0.4rem;\\n  margin-left: 0.5rem;\\n  outline: none;\\n  box-sizing: border-box;\\n  width: 3rem;\\n  height: 2rem;\\n}\\n\\n.sa-color-picker > .sa-color-picker-text {\\n  box-sizing: border-box;\\n  width: calc(150px - 3rem);\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n}\\n\\n[dir=\\\"rtl\\\"] .sa-color-picker > .sa-color-picker-color {\\n  border-top-left-radius: 0;\\n  border-bottom-left-radius: 0;\\n  border-top-right-radius: 1rem;\\n  border-bottom-right-radius: 1rem;\\n  margin-left: 0;\\n  margin-right: 0.5rem;\\n}\\n\\n[dir=\\\"rtl\\\"] .sa-color-picker > .sa-color-picker-text {\\n  border-top-left-radius: 1rem;\\n  border-bottom-left-radius: 1rem;\\n  border-top-right-radius: 0;\\n  border-bottom-right-radius: 0;\\n}\\n\\nbody.sa-hide-eye-dropper-background div[class*=\\\"stage_color-picker-background\\\"] {\\n  /* Do not show eye dropper background if the color picker is \\\"fake\\\" */\\n  display: none;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-comment-preview-outer {\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  z-index: 100000000;\\n  pointer-events: none;\\n}\\n\\n.sa-comment-preview-inner {\\n  width: calc(200px - 16px);\\n  max-height: calc(132px - 8px);\\n  padding: 8px;\\n  overflow: hidden;\\n\\n  font-size: 12px;\\n  white-space: pre-wrap;\\n  pointer-events: none;\\n\\n  color: rgb(87, 94, 117);\\n  background-color: rgb(255 255 255 / 90%);\\n  border-style: none;\\n  border-radius: 8px;\\n  filter: drop-shadow(0px 5px 5px rgb(0 0 0 / 10%));\\n\\n  transform: perspective(200px);\\n}\\n\\n@supports (backdrop-filter: blur(16px)) {\\n  .sa-comment-preview-inner {\\n    background-color: rgb(255 255 255 / 75%);\\n    backdrop-filter: blur(16px);\\n  }\\n}\\n\\n.sa-comment-preview-fade {\\n  transition:\\n    opacity 0.1s,\\n    filter 0.1s,\\n    transform 0.1s linear;\\n}\\n\\n.sa-comment-preview-hidden {\\n  opacity: 0;\\n  filter: none;\\n  transform: perspective(200px) translateZ(-20px);\\n}\\n\\n.sa-comment-preview-reduce-transparency {\\n  background-color: rgb(255 255 255);\\n  backdrop-filter: none;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".u-dropdown-searchbar {\\n  width: 100%;\\n  box-sizing: border-box;\\n  /* based on styles for the title input */\\n  color: white;\\n  background-color: hsla(0, 100%, 100%, 0.25);\\n  border: 1px solid hsla(0, 0%, 0%, 0.15);\\n  padding: 0.5rem;\\n  outline: none;\\n  transition: 0.25s ease-out;\\n  font-size: 13px;\\n  font-weight: bold;\\n  border-radius: 4px;\\n}\\n.u-dropdown-searchbar:hover {\\n  background-color: hsla(0, 100%, 100%, 0.5);\\n}\\n.u-dropdown-searchbar:focus {\\n  background-color: white;\\n  color: black;\\n}\\n.blocklyDropDownDiv .goog-menu {\\n  overflow-x: hidden;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \"/* Imported by other addons */\\n\\n.sa-block-color {\\n  --sa-block-colored-background: var(--sa-block-background-primary);\\n  --sa-block-colored-background-secondary: var(--sa-block-field-background);\\n  --sa-block-bright-background: var(--sa-block-background-primary);\\n  --sa-block-text: var(--editorTheme3-blockText, white);\\n  --sa-block-gray-text: white;\\n  --sa-block-colored-text: var(--sa-block-background-primary);\\n  --sa-block-text-on-bright-background: var(--editorTheme3-blockText, white);\\n  --sa-block-input-color: var(--editorTheme3-inputColor, white);\\n  --sa-block-input-text: var(--editorTheme3-inputColor-text, #575e75);\\n}\\n\\n.sa-block-color-motion {\\n  --sa-block-background-primary: var(--editorTheme3-motion-primary, #4c97ff);\\n  --sa-block-background-secondary: var(--editorTheme3-motion-secondary, #4280d7);\\n  --sa-block-background-tertiary: var(--editorTheme3-motion-tertiary, #3373cc);\\n  --sa-block-field-background: var(--editorTheme3-motion-field, #3373cc);\\n}\\n\\n.sa-block-color-looks {\\n  --sa-block-background-primary: var(--editorTheme3-looks-primary, #9966ff);\\n  --sa-block-background-secondary: var(--editorTheme3-looks-secondary, #855cd6);\\n  --sa-block-background-tertiary: var(--editorTheme3-looks-tertiary, #774dcb);\\n  --sa-block-field-background: var(--editorTheme3-looks-field, #774dcb);\\n}\\n\\n.sa-block-color-sounds {\\n  --sa-block-background-primary: var(--editorTheme3-sounds-primary, #cf63cf);\\n  --sa-block-background-secondary: var(--editorTheme3-sounds-secondary, #c94fc9);\\n  --sa-block-background-tertiary: var(--editorTheme3-sounds-tertiary, #bd42bd);\\n  --sa-block-field-background: var(--editorTheme3-sounds-field, #bd42bd);\\n}\\n\\n.sa-block-color-events {\\n  --sa-block-background-primary: var(--editorTheme3-event-primary, #ffbf00);\\n  --sa-block-background-secondary: var(--editorTheme3-event-secondary, #e6ac00);\\n  --sa-block-background-tertiary: var(--editorTheme3-event-tertiary, #cc9900);\\n  --sa-block-field-background: var(--editorTheme3-event-field, #cc9900);\\n}\\n\\n.sa-block-color-control {\\n  --sa-block-background-primary: var(--editorTheme3-control-primary, #ffab19);\\n  --sa-block-background-secondary: var(--editorTheme3-control-secondary, #ec9c13);\\n  --sa-block-background-tertiary: var(--editorTheme3-control-tertiary, #cf8b17);\\n  --sa-block-field-background: var(--editorTheme3-control-field, #cf8b17);\\n}\\n\\n.sa-block-color-sensing {\\n  --sa-block-background-primary: var(--editorTheme3-sensing-primary, #5cb1d6);\\n  --sa-block-background-secondary: var(--editorTheme3-sensing-secondary, #47a8d1);\\n  --sa-block-background-tertiary: var(--editorTheme3-sensing-tertiary, #2e8eb8);\\n  --sa-block-field-background: var(--editorTheme3-sensing-field, #2e8eb8);\\n}\\n\\n.sa-block-color-operators {\\n  --sa-block-background-primary: var(--editorTheme3-operators-primary, #59c059);\\n  --sa-block-background-secondary: var(--editorTheme3-operators-secondary, #46b946);\\n  --sa-block-background-tertiary: var(--editorTheme3-operators-tertiary, #389438);\\n  --sa-block-field-background: var(--editorTheme3-operators-field, #389438);\\n}\\n\\n.sa-block-color-data {\\n  --sa-block-background-primary: var(--editorTheme3-data-primary, #ff8c1a);\\n  --sa-block-background-secondary: var(--editorTheme3-data-secondary, #ff8000);\\n  --sa-block-background-tertiary: var(--editorTheme3-data-tertiary, #db6e00);\\n  --sa-block-field-background: var(--editorTheme3-data-field, #db6e00);\\n}\\n\\n.sa-block-color-data-lists,\\n.sa-block-color-list {\\n  --sa-block-background-primary: var(--editorTheme3-data_lists-primary, #ff661a);\\n  --sa-block-background-secondary: var(--editorTheme3-data_lists-secondary, #ff5500);\\n  --sa-block-background-tertiary: var(--editorTheme3-data_lists-tertiary, #e64d00);\\n  --sa-block-field-background: var(--editorTheme3-data_lists-field, #e64d00);\\n}\\n\\n.sa-block-color-more,\\n.sa-block-color-null {\\n  --sa-block-background-primary: var(--editorTheme3-more-primary, #ff6680);\\n  --sa-block-background-secondary: var(--editorTheme3-more-secondary, #ff4d6a);\\n  --sa-block-background-tertiary: var(--editorTheme3-more-tertiary, #ff3355);\\n  --sa-block-field-background: var(--editorTheme3-more-field, #ff3355);\\n}\\n\\n.sa-block-color-pen {\\n  --sa-block-background-primary: var(--editorTheme3-pen-primary, #0fbd8c);\\n  --sa-block-background-secondary: var(--editorTheme3-pen-secondary, #0da57a);\\n  --sa-block-background-tertiary: var(--editorTheme3-pen-tertiary, #0b8e69);\\n  --sa-block-field-background: var(--editorTheme3-pen-field, #0b8e69);\\n}\\n\\n.sa-block-color-addon-custom-block {\\n  --sa-block-background-primary: var(--editorTheme3-addons-primary, #29beb8);\\n  --sa-block-background-secondary: var(--editorTheme3-addons-secondary, #3aa8a4);\\n  --sa-block-background-tertiary: var(--editorTheme3-addons-tertiary, #3aa8a4);\\n  --sa-block-field-background: var(--editorTheme3-addons-field, #3aa8a4);\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\nexports.i(require(\"-!../../../../node_modules/css-loader/index.js!../editor-theme3/compatibility.css\"), \"\");\n\n// module\nexports.push([module.id, \".sa-find-bar {\\n  display: flex;\\n  align-items: center;\\n  white-space: nowrap;\\n  font-family: \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n  width: 100%;\\n  height: 100%;\\n  margin-left: 1em;\\n}\\n.sa-find-bar[hidden] {\\n  /* !important to override displayNoneWhileDisabled */\\n  display: none !important;\\n}\\n\\n.sa-find-wrapper {\\n  overflow: visible;\\n  position: relative;\\n  height: 2rem;\\n  width: 100%;\\n  max-width: 16em;\\n}\\n\\n.sa-find-dropdown-out {\\n  display: block;\\n  top: -6px;\\n  z-index: 100;\\n  width: 100%;\\n  max-width: 16em;\\n  position: relative;\\n  padding: 4px;\\n  border: none;\\n  border-radius: 4px;\\n  margin-top: 6px;\\n}\\n\\n.sa-find-dropdown-out.visible {\\n  position: absolute;\\n  width: 16em;\\n  box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, 0.3);\\n  background-color: var(--ui-modal-background);\\n  outline: 1px solid var(--ui-black-transparent);\\n}\\n\\n/* We need to modify Scratch styles so that the place where the find bar is injected */\\n/* has actually correct size information, which is used to make the find bar not cover up controls */\\n[class*=\\\"gui_tab-list_\\\"] {\\n  width: 100%;\\n}\\n[class*=\\\"gui_tab_\\\"] {\\n  flex-grow: 0;\\n}\\n\\n.sa-find-input {\\n  width: 100%;\\n  box-sizing: border-box !important;\\n  /* !important required for extension, because CSS injection method (and hence order) differs from addon */\\n  height: 1.5rem;\\n\\n  /* Change Scratch default styles */\\n  border-radius: 0.25rem;\\n  font-size: 0.75rem;\\n  padding-left: 0.4em;\\n}\\n\\n.sa-find-input:focus {\\n  /* Change Scratch default styles */\\n  box-shadow: none;\\n}\\n\\n.sa-find-dropdown {\\n  display: none;\\n  position: relative;\\n  padding: 0.2em 0;\\n  font-size: 0.75rem;\\n  line-height: 1;\\n  overflow-y: auto;\\n  min-height: 128px;\\n  max-height: 65vh;\\n  user-select: none;\\n  max-width: 100%;\\n  margin-top: 6px;\\n  border: none;\\n}\\n\\n.sa-find-dropdown-out.visible > .sa-find-dropdown {\\n  display: block;\\n}\\n\\n.sa-find-dropdown > li {\\n  display: block;\\n  padding: 0.5em 0.3em;\\n  white-space: nowrap;\\n  margin: 0;\\n  font-weight: bold;\\n  text-overflow: ellipsis;\\n  overflow: hidden;\\n}\\n\\n.sa-find-dropdown > li > b {\\n  background-color: #aaffaa;\\n  color: black;\\n}\\n\\n/* Drop down items */\\n.sa-find-dropdown > li:hover,\\n.sa-find-dropdown > li.sel {\\n  color: var(--sa-block-text-on-bright-background);\\n  cursor: pointer;\\n}\\n\\n.sa-find-dropdown > li::before {\\n  content: \\\"\\\\25CF   \\\"; /* â— */\\n}\\n\\n.sa-find-flag {\\n  color: #4cbf56;\\n}\\n/* .sa-find-dropdown added for specificity */\\n.sa-find-dropdown > .sa-find-flag:hover,\\n.sa-find-dropdown > .sa-find-flag.sel {\\n  background-color: #4cbf56;\\n  color: white;\\n}\\n\\n.sa-find-dropdown .sa-block-color {\\n  color: var(--sa-block-colored-text);\\n}\\n.sa-find-dropdown .sa-block-color:hover,\\n.sa-find-dropdown .sa-block-color.sel {\\n  background-color: var(--sa-block-bright-background);\\n}\\n\\n.sa-find-carousel {\\n  font-weight: normal;\\n  position: absolute;\\n  right: 0;\\n  white-space: nowrap;\\n  background-color: inherit;\\n  z-index: 1;\\n  padding: 0;\\n}\\n\\n.sa-find-carousel-control {\\n  padding: 0 6px;\\n}\\n\\n.sa-find-carousel-control:hover {\\n  color: #ffff80;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-folders-contextmenu-item {\\n  max-width: 250px;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n}\\n\\n[sa-folders-context-type=\\\"folder\\\"] .react-contextmenu > :not(.sa-ctx-menu) {\\n  display: none;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\nexports.i(require(\"-!../../../../node_modules/css-loader/index.js!../editor-theme3/compatibility.css\"), \"\");\n\n// module\nexports.push([module.id, \".sa-mcp-root {\\n  display: flex;\\n  white-space: nowrap;\\n  font-family: \\\"Helvetica Neue\\\", Helvetica, Arial, sans-serif;\\n\\n  position: absolute;\\n  min-width: 100px;\\n  background-color: var(--ui-modal-background);\\n  border-radius: 4px;\\n  box-shadow:\\n    rgba(0, 0, 0, 0.3) 0 0 3px,\\n    rgba(0, 0, 0, 0.2) 0 3px 10px;\\n\\n  z-index: 999;\\n}\\n\\n.sa-mcp-container {\\n  display: flex;\\n  flex-flow: column;\\n  top: -6px;\\n  z-index: 100;\\n  position: absolute;\\n  box-shadow: 0px 0px 8px 1px rgba(0, 0, 0, 0.3);\\n  background-color: var(--ui-modal-background);\\n  outline: 1px solid var(--ui-black-transparent);\\n  border: none;\\n  border-radius: 4px;\\n}\\n\\n.sa-mcp-input-wrapper {\\n  position: relative;\\n  margin: 4px;\\n  /* !important required for extension, because CSS injection method (and hence order) differs from addon */\\n  box-sizing: border-box !important;\\n  height: 1.5rem;\\n  min-height: 1.5rem;\\n\\n  /* Change Scratch default styles */\\n  border-radius: 0.25rem;\\n  font-size: 0.75rem;\\n  padding-left: 0.2rem;\\n  padding-right: 0.2rem;\\n}\\n\\n.sa-mcp-input-wrapper:focus {\\n  /* Change Scratch default styles */\\n  box-shadow: none;\\n}\\n\\n.sa-mcp-input-wrapper[data-error=\\\"true\\\"] {\\n  border-color: red;\\n}\\n\\n.sa-mcp-input-wrapper > input {\\n  position: absolute;\\n  border: 0;\\n  background-color: transparent;\\n  outline: none;\\n  width: 100%;\\n  height: 100%;\\n  line-height: 100%;\\n  box-sizing: border-box;\\n}\\n\\n.sa-mcp-input-suggestion {\\n  color: hsla(225, 15%, 40%, 0.65);\\n}\\n\\n.sa-mcp-preview-container {\\n  flex: auto;\\n  overflow-y: scroll;\\n}\\n\\n.sa-mcp-root /* <-- specificity */ .sa-mcp-preview-container {\\n  scrollbar-width: none;\\n}\\n\\n.sa-mcp-preview-container::-webkit-scrollbar {\\n  width: 0;\\n  height: 0;\\n}\\n\\n.sa-mcp-preview-blocks {\\n  width: 100%;\\n  min-height: 100%;\\n  /* https://stackoverflow.com/a/22166728/8448397 */\\n  float: left;\\n}\\n\\n.sa-mcp-preview-scrollbar {\\n  position: absolute;\\n  width: 11px;\\n  right: 0;\\n  bottom: 0;\\n}\\n\\n.sa-mcp-preview-block-bg {\\n  width: 100%;\\n  fill: transparent;\\n  cursor: grab;\\n}\\n\\n.sa-mcp-preview-block {\\n  filter: brightness(95%);\\n  cursor: grab;\\n}\\n\\n.sa-mcp-preview-block-selection {\\n  filter: brightness(103%);\\n}\\n\\n.sa-mcp-preview-block-bg-selection {\\n  fill: #7774;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-onion-button {\\n  position: relative;\\n}\\n.sa-onion-button:focus-within {\\n  background-color: var(--editorDarkMode-primary-transparent35, hsla(260, 60%, 60%, 0.35));\\n}\\n.sa-onion-image[data-image=\\\"toggle\\\"] {\\n  filter: var(--filter-icon-white);\\n}\\n.sa-onion-image[data-image=\\\"settings\\\"] {\\n  filter: var(--filter-icon-black);\\n}\\n.sa-onion-button[data-enabled=\\\"true\\\"] .sa-onion-image {\\n  filter: brightness(0) invert(1);\\n}\\n.sa-onion-button[data-enabled=\\\"true\\\"] {\\n  color: white;\\n  background-color: var(--looks-secondary);\\n}\\n\\n.sa-onion-group {\\n  position: relative;\\n  flex-direction: row;\\n}\\n\\n.sa-onion-settings-wrapper {\\n  position: absolute;\\n  justify-items: center;\\n  left: 50%;\\n  width: 1.95rem;\\n  height: 1.95rem;\\n  display: grid;\\n}\\n\\n.sa-onion-settings {\\n  position: absolute;\\n  bottom: 100%;\\n  /* based on the styles for the color dropdown */\\n  padding: 4px;\\n  border-radius: 4px;\\n  border: 1px solid #ddd;\\n  border: 1px solid var(--ui-black-transparent);\\n  transition-property: bottom, opacity;\\n  transition-duration: 500ms;\\n  transition-timing-function: cubic-bezier(0.23, 1, 0.32, 1);\\n  opacity: 0;\\n  pointer-events: none;\\n  background: var(--ui-modal-background);\\n  color: var(--ui-text-primary);\\n  min-height: 100%;\\n  min-width: 100%;\\n  display: flex;\\n  flex-direction: column;\\n  gap: 0.25em;\\n}\\n.sa-onion-settings[data-visible=\\\"true\\\"] {\\n  bottom: calc(100% + 22px);\\n  pointer-events: auto;\\n  opacity: 1;\\n}\\n\\n.sa-onion-settings-line {\\n  display: flex;\\n  justify-content: flex-end;\\n  align-items: baseline;\\n  gap: 0.25em;\\n}\\n\\n.sa-onion-settings-input {\\n  position: absolute;\\n  top: 0;\\n  left: 0;\\n  width: 100%;\\n  height: 100%;\\n  box-sizing: border-box;\\n  text-align: center;\\n  border: 0;\\n  background: transparent;\\n  -moz-appearance: textfield;\\n  border: 0;\\n  outline: 0;\\n}\\n\\n.sa-onion-settings-input::-webkit-outer-spin-button,\\n.sa-onion-settings-input::-webkit-inner-spin-button {\\n  -webkit-appearance: none;\\n  margin: 0;\\n}\\n\\n.sa-onion-settings-tip {\\n  position: absolute;\\n  bottom: 0;\\n  transform: translateY(100%);\\n  right: calc(50% - 7px);\\n}\\n.sa-onion-settings-polygon {\\n  fill: var(--ui-modal-background);\\n  stroke: var(--ui-black-transparent);\\n}\\n\\n.sa-onion-settings-label {\\n  white-space: nowrap;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".sa-stage-color-picker-picking [class^=\\\"stage_color-picker-background_\\\"] {\\n  display: none;\\n}\\n\", \"\"]);\n\n// exports\n","exports = module.exports = require(\"../../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \".blocklyTextShiftArrow {\\n  position: absolute;\\n  top: -50px;\\n  left: 50%;\\n  margin-left: -12.5px;\\n  cursor: pointer;\\n}\\n\", \"\"]);\n\n// exports\n","export default \"data:image/svg+xml;base64,PHN2ZyBpZD0iTGF5ZXJfMSIgZGF0YS1uYW1lPSJMYXllciAxIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA3LjQ4IDcuNDgiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDpub25lO3N0cm9rZTojZmZmO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2Utd2lkdGg6MnB4O308L3N0eWxlPjwvZGVmcz48dGl0bGU+aWNvbi0tYWRkPC90aXRsZT48bGluZSBjbGFzcz0iY2xzLTEiIHgxPSIzLjc0IiB5MT0iNi40OCIgeDI9IjMuNzQiIHkyPSIxIi8+PGxpbmUgY2xhc3M9ImNscy0xIiB4MT0iMSIgeTE9IjMuNzQiIHgyPSI2LjQ4IiB5Mj0iMy43NCIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHdpZHRoPSIyNCI+PHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIvPjxwYXRoIGQ9Ik0xMCA0SDRjLTEuMSAwLTEuOTkuOS0xLjk5IDJMMiAxOGMwIDEuMS45IDIgMiAyaDE2YzEuMSAwIDItLjkgMi0yVjhjMC0xLjEtLjktMi0yLTJoLThsLTItMnoiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjQiIHdpZHRoPSIyNCI+PHBhdGggc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUgMTEuMzU4aDE3LjUwMXYxLjI4NUgzLjI1eiIvPjxwYXRoIHRyYW5zZm9ybT0icm90YXRlKDkwKSIgc3R5bGU9ImZpbGw6IzU3NWU3NTtzdHJva2Utd2lkdGg6LjczNDczNiIgZD0iTTMuMjUtMTIuNjQyaDE3LjUwMXYxLjI4NUgzLjI1eiIvPjwvc3ZnPg==\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PHBhdGggc3R5bGU9Im9wYWNpdHk6Ljc1O2ZpbGw6bm9uZTtzdHJva2U6IzAwMDtzdHJva2Utd2lkdGg6NDtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIgZD0iTTU2IDE2djk2IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMi4zNzYgLTIuMzc2KSBzY2FsZSguMjI0NjIpIi8+PHBhdGggc3R5bGU9Im9wYWNpdHk6LjU7ZmlsbDpub25lO3N0cm9rZTojMDAwO3N0cm9rZS13aWR0aDo0O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiBkPSJNNDAgMzJ2NjQiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjM3NiAtMi4zNzYpIHNjYWxlKC4yMjQ2MikiLz48cGF0aCBzdHlsZT0ib3BhY2l0eTouMjU7ZmlsbDpub25lO3N0cm9rZTojMDAwO3N0cm9rZS13aWR0aDo0O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjptaXRlcjtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiBkPSJNMjQgNDh2MzIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjM3NiAtMi4zNzYpIHNjYWxlKC4yMjQ2MikiLz48cGF0aCBzdHlsZT0ib3BhY2l0eTouNzU7ZmlsbDpub25lO3N0cm9rZTojMDAwO3N0cm9rZS13aWR0aDo0O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2Utb3BhY2l0eToxIiBkPSJNNzIgMTZ2OTYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjM3NiAtMi4zNzYpIHNjYWxlKC4yMjQ2MikiLz48cGF0aCBzdHlsZT0ib3BhY2l0eTouNTtmaWxsOm5vbmU7c3Ryb2tlOiMwMDA7c3Ryb2tlLXdpZHRoOjQ7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIGQ9Ik04OCAzMnY2NCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIuMzc2IC0yLjM3Nikgc2NhbGUoLjIyNDYyKSIvPjxwYXRoIHN0eWxlPSJvcGFjaXR5Oi4yNTtmaWxsOm5vbmU7c3Ryb2tlOiMwMDA7c3Ryb2tlLXdpZHRoOjQ7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiIGQ9Ik0xMDQgNDh2MzIiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjM3NiAtMi4zNzYpIHNjYWxlKC4yMjQ2MikiLz48L3N2Zz4=\"","export default \"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNCIgaGVpZ2h0PSIyNCI+PGcgc3Ryb2tlLXdpZHRoPSIxLjIiIHN0cm9rZT0iIzAwMTAyNiI+PGcgc3R5bGU9Im9wYWNpdHk6LjU7c3Ryb2tlLXdpZHRoOjQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lIj48cGF0aCBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6bm9ybWFsO2ZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6NDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIgZmlsbD0iI2JmYmZiZiIgZD0iTTY4LjQ1IDMyLjQ1N2MuMy0uMi44LS4xLjkuM2wyLjYgMTAuN3M2LjQgNC43IDguMyA4YzMuMiA1LjUgMy4zIDEwIDMuMyAxMHM3LjEgMi4xIDguMyA3LjhjMS4yIDUuNy0zLjIgMTYuNS0yMiAyMC4yLTE4LjggMy43LTMzLjktMS40LTQxLTEyLjgtNy4xLTExLjQgNC4xLTI1IDMuNS0yNC4ybC0yLjEtMTcuOWMtLjEtLjQuNC0uNy44LS41bDEyLjEgNy45czQuNS0xLjcgOS4yLTEuOWMyLjgtLjIgNS4yIDAgNy41LjR6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNC42NTIgLTQuNjUpIHNjYWxlKC4yMzI5KSIvPjxwYXRoIHN0eWxlPSJtaXgtYmxlbmQtbW9kZTpub3JtYWw7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDo0O3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGZpbGw9Im5vbmUiIGQ9Ik0xMDEuNjUgNjIuOTU3Yy00LjcgMy44LTExLjkgMy45LTExLjkgMy45bTEwLjYgNy4zYy02LjMuNS0xMC4yLTEuNC0xMC4yLTEuNG0tNjguOC0xMC4xczguNiAyLjggMTIuMSA1LjltLjMgMy41Yy00LjMgMS43LTExLjcuNi0xMS43LjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC00LjY1MiAtNC42NSkgc2NhbGUoLjIzMjkpIi8+PC9nPjxnIHN0eWxlPSJvcGFjaXR5Oi43NTtzdHJva2Utd2lkdGg6NDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmUiPjxwYXRoIHN0eWxlPSJtaXgtYmxlbmQtbW9kZTpub3JtYWw7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDo0O3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowIiBmaWxsPSIjYmZiZmJmIiBkPSJNNjguNDUgMzIuNDU3Yy4zLS4yLjgtLjEuOS4zbDIuNiAxMC43czYuNCA0LjcgOC4zIDhjMy4yIDUuNSAzLjMgMTAgMy4zIDEwczcuMSAyLjEgOC4zIDcuOGMxLjIgNS43LTMuMiAxNi41LTIyIDIwLjItMTguOCAzLjctMzMuOS0xLjQtNDEtMTIuOC03LjEtMTEuNCA0LjEtMjUgMy41LTI0LjJsLTIuMS0xNy45Yy0uMS0uNC40LS43LjgtLjVsMTIuMSA3LjlzNC41LTEuNyA5LjItMS45YzIuOC0uMiA1LjIgMCA3LjUuNHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjMyMyAtMi4zMjEpIHNjYWxlKC4yMzI5KSIvPjxwYXRoIHN0eWxlPSJtaXgtYmxlbmQtbW9kZTpub3JtYWw7ZmlsbDpub25lO2ZpbGwtcnVsZTpldmVub2RkO3N0cm9rZS13aWR0aDo0O3N0cm9rZS1taXRlcmxpbWl0OjEwO3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBzdHJva2UtbGluZWNhcD0icm91bmQiIGZpbGw9Im5vbmUiIGQ9Ik0xMDEuNjUgNjIuOTU3Yy00LjcgMy44LTExLjkgMy45LTExLjkgMy45bTEwLjYgNy4zYy02LjMuNS0xMC4yLTEuNC0xMC4yLTEuNG0tNjguOC0xMC4xczguNiAyLjggMTIuMSA1LjltLjMgMy41Yy00LjMgMS43LTExLjcuNi0xMS43LjYiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yLjMyMyAtMi4zMjEpIHNjYWxlKC4yMzI5KSIvPjwvZz48ZyBzdHlsZT0ic3Ryb2tlLXdpZHRoOjQ7c3Ryb2tlLW1pdGVybGltaXQ6MTA7c3Ryb2tlLWRhc2hhcnJheTpub25lIj48cGF0aCBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6bm9ybWFsO2ZpbGw6I2ZmZjtmaWxsLW9wYWNpdHk6MTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6NDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIgZmlsbD0iI2JmYmZiZiIgZD0iTTczLjQ1IDM3LjQ1N2MuMy0uMi44LS4xLjkuM2wyLjYgMTAuN3M2LjQgNC43IDguMyA4YzMuMiA1LjUgMy4zIDEwIDMuMyAxMHM3LjEgMi4xIDguMyA3LjhjMS4yIDUuNy0zLjIgMTYuNS0yMiAyMC4yLTE4LjggMy43LTMzLjktMS40LTQxLTEyLjgtNy4xLTExLjQgNC4xLTI1IDMuNS0yNC4ybC0yLjEtMTcuOWMtLjEtLjQuNC0uNy44LS41bDEyLjEgNy45czQuNS0xLjcgOS4yLTEuOWMyLjgtLjIgNS4yIDAgNy41LjR6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS4xNTkgLTEuMTU3KSBzY2FsZSguMjMyOSkiLz48cGF0aCBzdHlsZT0ibWl4LWJsZW5kLW1vZGU6bm9ybWFsO2ZpbGw6bm9uZTtmaWxsLXJ1bGU6ZXZlbm9kZDtzdHJva2Utd2lkdGg6NDtzdHJva2UtbWl0ZXJsaW1pdDoxMDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBmaWxsPSJub25lIiBkPSJNMTA2LjY1IDY3Ljk1N2MtNC43IDMuOC0xMS45IDMuOS0xMS45IDMuOW0xMC42IDcuM2MtNi4zLjUtMTAuMi0xLjQtMTAuMi0xLjRtLTY4LjgtMTAuMXM4LjYgMi44IDEyLjEgNS45bS4zIDMuNWMtNC4zIDEuNy0xMS43LjYtMTEuNy42IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMS4xNTkgLTEuMTU3KSBzY2FsZSguMjMyOSkiLz48L2c+PC9nPjwvc3ZnPg==\"","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","export default async ({ addon, console }) => {\n  if (!addon.tab.redux.state) return console.warn(\"Redux is not available!\");\n  addon.tab.redux.initialize();\n  addon.tab.redux.addEventListener(\"statechanged\", ({ detail }) => {\n    if (addon.self.disabled) return;\n    const e = detail;\n    if (!e.action || e.action.type !== \"scratch-paint/clipboard/SET\") return;\n    const items = e.next.scratchPaint.clipboard.items;\n    if (items.length !== 1) return;\n    const firstItem = items[0];\n    // TODO vector support\n    if (!Array.isArray(firstItem) || firstItem[0] !== \"Raster\") return console.log(\"copied element is vector\");\n    const dataURL = firstItem[1].source;\n    addon.tab\n      .copyImage(dataURL)\n      .then(() => console.log(\"Image successfully copied\"))\n      .catch((e) => console.error(`Image could not be copied: ${e}`));\n  });\n};\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","import * as sharedModule from \"../block-duplicate/module.js\";\n\nexport default async function ({ addon, console }) {\n  const update = () => {\n    sharedModule.setCherryPicking(!addon.self.disabled, addon.settings.get(\"invertDrag\"));\n  };\n  addon.self.addEventListener(\"disabled\", update);\n  addon.self.addEventListener(\"reenabled\", update);\n  addon.settings.addEventListener(\"change\", update);\n  update();\n  sharedModule.load(addon);\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","let enableCherryPicking = false;\nlet invertCherryPicking = false;\nexport function setCherryPicking(newEnabled, newInverted) {\n  enableCherryPicking = newEnabled;\n  // If cherry picking is disabled, also disable invert. Duplicating blocks can still cause\n  // this setting to be used.\n  invertCherryPicking = newEnabled && newInverted;\n}\n\nlet enableDuplication = false;\nexport function setDuplication(newEnabled) {\n  enableDuplication = newEnabled;\n}\n\n// mostRecentEvent_ is sometimes a fake event, so we can't rely on reading its properties.\nlet ctrlOrMetaPressed = false;\nlet altPressed = false;\ndocument.addEventListener(\n  \"mousedown\",\n  function (e) {\n    ctrlOrMetaPressed = e.ctrlKey || e.metaKey;\n    altPressed = e.altKey;\n  },\n  {\n    capture: true,\n  }\n);\n\nlet loaded = false;\n\nexport async function load(addon) {\n  if (loaded) {\n    return;\n  }\n  loaded = true;\n\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n\n  // https://github.com/scratchfoundation/scratch-blocks/blob/912b8cc728bea8fd91af85078c64fcdbfe21c87a/core/gesture.js#L454\n  const originalStartDraggingBlock = ScratchBlocks.Gesture.prototype.startDraggingBlock_;\n  ScratchBlocks.Gesture.prototype.startDraggingBlock_ = function (...args) {\n    let block = this.targetBlock_;\n\n    // Scratch uses fake mouse events to implement right click > duplicate\n    const isRightClickDuplicate = !(this.mostRecentEvent_ instanceof MouseEvent);\n\n    const isDuplicating =\n      enableDuplication &&\n      altPressed &&\n      !isRightClickDuplicate &&\n      !this.flyout_ &&\n      !this.shouldDuplicateOnDrag_ &&\n      this.targetBlock_.type !== \"procedures_definition\";\n\n    const isCherryPickingInverted = invertCherryPicking && !isRightClickDuplicate && block.getParent();\n    const canCherryPick = enableCherryPicking || isDuplicating;\n    const isCherryPicking = canCherryPick && ctrlOrMetaPressed === !isCherryPickingInverted && !block.isShadow();\n\n    if (isDuplicating || isCherryPicking) {\n      if (!ScratchBlocks.Events.getGroup()) {\n        // Scratch will disable grouping on its own later.\n        ScratchBlocks.Events.setGroup(true);\n      }\n    }\n\n    if (isDuplicating) {\n      // Based on https://github.com/scratchfoundation/scratch-blocks/blob/feda366947432b9d82a4f212f43ff6d4ab6f252f/core/scratch_blocks_utils.js#L171\n      // Setting this.shouldDuplicateOnDrag_ = true does NOT work because it doesn't call changeObscuredShadowIds\n      this.startWorkspace_.setResizesEnabled(false);\n      ScratchBlocks.Events.disable();\n      let newBlock;\n      try {\n        const xmlBlock = ScratchBlocks.Xml.blockToDom(block);\n        newBlock = ScratchBlocks.Xml.domToBlock(xmlBlock, this.startWorkspace_);\n        ScratchBlocks.scratchBlocksUtils.changeObscuredShadowIds(newBlock);\n        const xy = block.getRelativeToSurfaceXY();\n        newBlock.moveBy(xy.x, xy.y);\n      } catch (e) {\n        console.error(e);\n      }\n      ScratchBlocks.Events.enable();\n\n      if (newBlock) {\n        block = newBlock;\n        this.targetBlock_ = newBlock;\n        if (ScratchBlocks.Events.isEnabled()) {\n          ScratchBlocks.Events.fire(new ScratchBlocks.Events.BlockCreate(newBlock));\n        }\n      }\n    }\n\n    if (isCherryPicking) {\n      if (isRightClickDuplicate || isDuplicating) {\n        const nextBlock = block.getNextBlock();\n        if (nextBlock) {\n          nextBlock.dispose();\n        }\n      }\n      block.unplug(true);\n    }\n\n    return originalStartDraggingBlock.call(this, ...args);\n  };\n}\n","import * as sharedModule from \"./module.js\";\n\nexport default async function ({ addon, console }) {\n  const update = () => {\n    sharedModule.setDuplication(!addon.self.disabled);\n  };\n  addon.self.addEventListener(\"disabled\", update);\n  addon.self.addEventListener(\"reenabled\", update);\n  update();\n  sharedModule.load(addon);\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","export default async function ({ addon, console, msg }) {\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n  const vm = addon.tab.traps.vm;\n\n  let blockSwitches = {};\n  let procedureSwitches = {};\n  const noopSwitch = {\n    isNoop: true,\n  };\n\n  const randomColor = () => {\n    const num = Math.floor(Math.random() * 256 * 256 * 256);\n    return `#${num.toString(16).padStart(6, \"0\")}`;\n  };\n\n  const buildSwitches = () => {\n    blockSwitches = {};\n    procedureSwitches = {};\n\n    if (addon.settings.get(\"motion\")) {\n      blockSwitches[\"motion_turnright\"] = [\n        noopSwitch,\n        {\n          opcode: \"motion_turnleft\",\n        },\n      ];\n      blockSwitches[\"motion_turnleft\"] = [\n        {\n          opcode: \"motion_turnright\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"motion_setx\"] = [\n        noopSwitch,\n        {\n          opcode: \"motion_changexby\",\n          remapInputName: { X: \"DX\" },\n        },\n        {\n          opcode: \"motion_sety\",\n          remapInputName: { X: \"Y\" },\n        },\n        {\n          opcode: \"motion_changeyby\",\n          remapInputName: { X: \"DY\" },\n        },\n      ];\n      blockSwitches[\"motion_changexby\"] = [\n        {\n          opcode: \"motion_setx\",\n          remapInputName: { DX: \"X\" },\n        },\n        noopSwitch,\n        {\n          opcode: \"motion_sety\",\n          remapInputName: { DX: \"Y\" },\n        },\n        {\n          opcode: \"motion_changeyby\",\n          remapInputName: { DX: \"DY\" },\n        },\n      ];\n      blockSwitches[\"motion_sety\"] = [\n        {\n          opcode: \"motion_setx\",\n          remapInputName: { Y: \"X\" },\n        },\n        {\n          opcode: \"motion_changexby\",\n          remapInputName: { Y: \"DX\" },\n        },\n        noopSwitch,\n        {\n          opcode: \"motion_changeyby\",\n          remapInputName: { Y: \"DY\" },\n        },\n      ];\n      blockSwitches[\"motion_changeyby\"] = [\n        {\n          opcode: \"motion_setx\",\n          remapInputName: { DY: \"X\" },\n        },\n        {\n          opcode: \"motion_changexby\",\n          remapInputName: { DY: \"DX\" },\n        },\n        {\n          opcode: \"motion_sety\",\n          remapInputName: { DY: \"Y\" },\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"motion_xposition\"] = [\n        noopSwitch,\n        {\n          opcode: \"motion_yposition\",\n        },\n      ];\n      blockSwitches[\"motion_yposition\"] = [\n        {\n          opcode: \"motion_xposition\",\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"looks\")) {\n      blockSwitches[\"looks_seteffectto\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_changeeffectby\",\n          remapInputName: { VALUE: \"CHANGE\" },\n        },\n      ];\n      blockSwitches[\"looks_changeeffectby\"] = [\n        {\n          opcode: \"looks_seteffectto\",\n          remapInputName: { CHANGE: \"VALUE\" },\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"looks_setsizeto\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_changesizeby\",\n          remapInputName: { SIZE: \"CHANGE\" },\n        },\n      ];\n      blockSwitches[\"looks_changesizeby\"] = [\n        {\n          opcode: \"looks_setsizeto\",\n          remapInputName: { CHANGE: \"SIZE\" },\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"looks_costumenumbername\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_backdropnumbername\",\n        },\n      ];\n      blockSwitches[\"looks_backdropnumbername\"] = [\n        {\n          opcode: \"looks_costumenumbername\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"looks_show\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_hide\",\n        },\n      ];\n      blockSwitches[\"looks_hide\"] = [\n        {\n          opcode: \"looks_show\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"looks_nextcostume\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_nextbackdrop\",\n        },\n      ];\n      blockSwitches[\"looks_nextbackdrop\"] = [\n        {\n          opcode: \"looks_nextcostume\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"looks_say\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_sayforsecs\",\n          createInputs: {\n            SECS: {\n              shadowType: \"math_number\",\n              value: \"2\",\n            },\n          },\n        },\n        {\n          opcode: \"looks_think\",\n        },\n        {\n          opcode: \"looks_thinkforsecs\",\n          createInputs: {\n            SECS: {\n              shadowType: \"math_number\",\n              value: \"2\",\n            },\n          },\n        },\n      ];\n      blockSwitches[\"looks_think\"] = [\n        {\n          opcode: \"looks_say\",\n        },\n        {\n          opcode: \"looks_sayforsecs\",\n          createInputs: {\n            SECS: {\n              shadowType: \"math_number\",\n              value: \"2\",\n            },\n          },\n        },\n        noopSwitch,\n        {\n          opcode: \"looks_thinkforsecs\",\n          createInputs: {\n            SECS: {\n              shadowType: \"math_number\",\n              value: \"2\",\n            },\n          },\n        },\n      ];\n      blockSwitches[\"looks_sayforsecs\"] = [\n        {\n          opcode: \"looks_say\",\n          splitInputs: [\"SECS\"],\n        },\n        {\n          opcode: \"looks_think\",\n          splitInputs: [\"SECS\"],\n        },\n        noopSwitch,\n        {\n          opcode: \"looks_thinkforsecs\",\n        },\n      ];\n      blockSwitches[\"looks_thinkforsecs\"] = [\n        {\n          opcode: \"looks_say\",\n          splitInputs: [\"SECS\"],\n        },\n        {\n          opcode: \"looks_think\",\n          splitInputs: [\"SECS\"],\n        },\n        {\n          opcode: \"looks_sayforsecs\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"looks_switchbackdropto\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_switchbackdroptoandwait\",\n        },\n      ];\n      blockSwitches[\"looks_switchbackdroptoandwait\"] = [\n        {\n          opcode: \"looks_switchbackdropto\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"looks_gotofrontback\"] = [\n        noopSwitch,\n        {\n          opcode: \"looks_goforwardbackwardlayers\",\n          remapInputName: {\n            FRONT_BACK: \"FORWARD_BACKWARD\",\n          },\n          mapFieldValues: {\n            FRONT_BACK: {\n              front: \"forward\",\n              back: \"backward\",\n            },\n          },\n          createInputs: {\n            NUM: {\n              shadowType: \"math_integer\",\n              value: \"1\",\n            },\n          },\n        },\n      ];\n      blockSwitches[\"looks_goforwardbackwardlayers\"] = [\n        {\n          opcode: \"looks_gotofrontback\",\n          splitInputs: [\"NUM\"],\n          remapInputName: {\n            FORWARD_BACKWARD: \"FRONT_BACK\",\n          },\n          mapFieldValues: {\n            FORWARD_BACKWARD: {\n              forward: \"front\",\n              backward: \"back\",\n            },\n          },\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"sound\")) {\n      blockSwitches[\"sound_play\"] = [\n        noopSwitch,\n        {\n          opcode: \"sound_playuntildone\",\n        },\n      ];\n      blockSwitches[\"sound_playuntildone\"] = [\n        {\n          opcode: \"sound_play\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"sound_seteffectto\"] = [\n        noopSwitch,\n        {\n          opcode: \"sound_changeeffectby\",\n        },\n      ];\n      blockSwitches[\"sound_changeeffectby\"] = [\n        {\n          opcode: \"sound_seteffectto\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"sound_setvolumeto\"] = [\n        noopSwitch,\n        {\n          opcode: \"sound_changevolumeby\",\n        },\n      ];\n      blockSwitches[\"sound_changevolumeby\"] = [\n        {\n          opcode: \"sound_setvolumeto\",\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"event\")) {\n      blockSwitches[\"event_broadcast\"] = [\n        noopSwitch,\n        {\n          opcode: \"event_broadcastandwait\",\n        },\n      ];\n      blockSwitches[\"event_broadcastandwait\"] = [\n        {\n          opcode: \"event_broadcast\",\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"control\")) {\n      blockSwitches[\"control_if\"] = [\n        noopSwitch,\n        {\n          opcode: \"control_if_else\",\n        },\n      ];\n      blockSwitches[\"control_if_else\"] = [\n        {\n          opcode: \"control_if\",\n          splitInputs: [\"SUBSTACK2\"],\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"control_repeat_until\"] = [\n        noopSwitch,\n        {\n          opcode: \"control_wait_until\",\n          splitInputs: [\"SUBSTACK\"],\n        },\n        {\n          opcode: \"control_forever\",\n          splitInputs: [\"CONDITION\"],\n        },\n      ];\n      blockSwitches[\"control_forever\"] = [\n        {\n          opcode: \"control_repeat_until\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"control_wait_until\"] = [\n        {\n          opcode: \"control_repeat_until\",\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"operator\")) {\n      blockSwitches[\"operator_equals\"] = [\n        {\n          opcode: \"operator_gt\",\n        },\n        noopSwitch,\n        {\n          opcode: \"operator_lt\",\n        },\n      ];\n      blockSwitches[\"operator_gt\"] = [\n        noopSwitch,\n        {\n          opcode: \"operator_equals\",\n        },\n        {\n          opcode: \"operator_lt\",\n        },\n      ];\n      blockSwitches[\"operator_lt\"] = [\n        {\n          opcode: \"operator_gt\",\n        },\n        {\n          opcode: \"operator_equals\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"operator_add\"] = [\n        noopSwitch,\n        {\n          opcode: \"operator_subtract\",\n        },\n        {\n          opcode: \"operator_multiply\",\n        },\n        {\n          opcode: \"operator_divide\",\n        },\n        {\n          opcode: \"operator_mod\",\n        },\n      ];\n      blockSwitches[\"operator_subtract\"] = [\n        {\n          opcode: \"operator_add\",\n        },\n        noopSwitch,\n        {\n          opcode: \"operator_multiply\",\n        },\n        {\n          opcode: \"operator_divide\",\n        },\n        {\n          opcode: \"operator_mod\",\n        },\n      ];\n      blockSwitches[\"operator_multiply\"] = [\n        {\n          opcode: \"operator_add\",\n        },\n        {\n          opcode: \"operator_subtract\",\n        },\n        noopSwitch,\n        {\n          opcode: \"operator_divide\",\n        },\n        {\n          opcode: \"operator_mod\",\n        },\n      ];\n      blockSwitches[\"operator_divide\"] = [\n        {\n          opcode: \"operator_add\",\n        },\n        {\n          opcode: \"operator_subtract\",\n        },\n        {\n          opcode: \"operator_multiply\",\n        },\n        noopSwitch,\n        {\n          opcode: \"operator_mod\",\n        },\n      ];\n      blockSwitches[\"operator_mod\"] = [\n        {\n          opcode: \"operator_add\",\n        },\n        {\n          opcode: \"operator_subtract\",\n        },\n        {\n          opcode: \"operator_multiply\",\n        },\n        {\n          opcode: \"operator_divide\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"operator_and\"] = [\n        noopSwitch,\n        {\n          opcode: \"operator_or\",\n        },\n      ];\n      blockSwitches[\"operator_or\"] = [\n        {\n          opcode: \"operator_and\",\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"sensing\")) {\n      blockSwitches[\"sensing_mousex\"] = [\n        noopSwitch,\n        {\n          opcode: \"sensing_mousey\",\n        },\n      ];\n      blockSwitches[\"sensing_mousey\"] = [\n        {\n          opcode: \"sensing_mousex\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"sensing_touchingcolor\"] = [\n        noopSwitch,\n        {\n          opcode: \"sensing_coloristouchingcolor\",\n          createInputs: {\n            COLOR2: {\n              shadowType: \"colour_picker\",\n              value: randomColor,\n            },\n          },\n        },\n      ];\n      blockSwitches[\"sensing_coloristouchingcolor\"] = [\n        {\n          opcode: \"sensing_touchingcolor\",\n          splitInputs: [\"COLOR2\"],\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"data\")) {\n      blockSwitches[\"data_setvariableto\"] = [\n        noopSwitch,\n        {\n          opcode: \"data_changevariableby\",\n          remapShadowType: { VALUE: \"math_number\" },\n        },\n      ];\n      blockSwitches[\"data_changevariableby\"] = [\n        {\n          opcode: \"data_setvariableto\",\n          remapShadowType: { VALUE: \"text\" },\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"data_showvariable\"] = [\n        noopSwitch,\n        {\n          opcode: \"data_hidevariable\",\n        },\n      ];\n      blockSwitches[\"data_hidevariable\"] = [\n        {\n          opcode: \"data_showvariable\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"data_showlist\"] = [\n        noopSwitch,\n        {\n          opcode: \"data_hidelist\",\n        },\n      ];\n      blockSwitches[\"data_hidelist\"] = [\n        {\n          opcode: \"data_showlist\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"data_replaceitemoflist\"] = [\n        noopSwitch,\n        {\n          opcode: \"data_insertatlist\",\n        },\n      ];\n      blockSwitches[\"data_insertatlist\"] = [\n        {\n          opcode: \"data_replaceitemoflist\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"data_deleteoflist\"] = [\n        noopSwitch,\n        {\n          opcode: \"data_deletealloflist\",\n          splitInputs: [\"INDEX\"],\n        },\n      ];\n      blockSwitches[\"data_deletealloflist\"] = [\n        {\n          opcode: \"data_deleteoflist\",\n          createInputs: {\n            INDEX: {\n              shadowType: \"math_integer\",\n              value: \"1\",\n            },\n          },\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"extension\")) {\n      blockSwitches[\"pen_penDown\"] = [\n        noopSwitch,\n        {\n          opcode: \"pen_penUp\",\n        },\n      ];\n      blockSwitches[\"pen_penUp\"] = [\n        {\n          opcode: \"pen_penDown\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"pen_setPenColorParamTo\"] = [\n        noopSwitch,\n        {\n          opcode: \"pen_changePenColorParamBy\",\n        },\n      ];\n      blockSwitches[\"pen_changePenColorParamBy\"] = [\n        {\n          opcode: \"pen_setPenColorParamTo\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"pen_setPenHueToNumber\"] = [\n        noopSwitch,\n        {\n          opcode: \"pen_changePenHueBy\",\n        },\n      ];\n      blockSwitches[\"pen_changePenHueBy\"] = [\n        {\n          opcode: \"pen_setPenHueToNumber\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"pen_setPenShadeToNumber\"] = [\n        noopSwitch,\n        {\n          opcode: \"pen_changePenShadeBy\",\n        },\n      ];\n      blockSwitches[\"pen_changePenShadeBy\"] = [\n        {\n          opcode: \"pen_setPenShadeToNumber\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"pen_setPenSizeTo\"] = [\n        noopSwitch,\n        {\n          opcode: \"pen_changePenSizeBy\",\n        },\n      ];\n      blockSwitches[\"pen_changePenSizeBy\"] = [\n        {\n          opcode: \"pen_setPenSizeTo\",\n        },\n        noopSwitch,\n      ];\n      blockSwitches[\"music_setTempo\"] = [\n        noopSwitch,\n        {\n          opcode: \"music_changeTempo\",\n        },\n      ];\n      blockSwitches[\"music_changeTempo\"] = [\n        {\n          opcode: \"music_setTempo\",\n        },\n        noopSwitch,\n      ];\n    }\n\n    if (addon.settings.get(\"sa\")) {\n      const logProc = \"\\u200B\\u200Blog\\u200B\\u200B %s\";\n      const warnProc = \"\\u200B\\u200Bwarn\\u200B\\u200B %s\";\n      const errorProc = \"\\u200B\\u200Berror\\u200B\\u200B %s\";\n      const logMessage = msg(\"debugger_log\");\n      const warnMessage = msg(\"debugger_warn\");\n      const errorMessage = msg(\"debugger_error\");\n      const logSwitch = {\n        mutate: {\n          proccode: logProc,\n        },\n        msg: logMessage,\n      };\n      const warnSwitch = {\n        mutate: {\n          proccode: warnProc,\n        },\n        msg: warnMessage,\n      };\n      const errorSwitch = {\n        mutate: {\n          proccode: errorProc,\n        },\n        msg: errorMessage,\n      };\n      procedureSwitches[logProc] = [\n        {\n          msg: logMessage,\n          isNoop: true,\n        },\n        warnSwitch,\n        errorSwitch,\n      ];\n      procedureSwitches[warnProc] = [\n        logSwitch,\n        {\n          msg: warnMessage,\n          isNoop: true,\n        },\n        errorSwitch,\n      ];\n      procedureSwitches[errorProc] = [\n        logSwitch,\n        warnSwitch,\n        {\n          msg: errorMessage,\n          isNoop: true,\n        },\n      ];\n    }\n\n    // Switching for these is implemented by Scratch. We only define them here to optionally add a border.\n    // Because we don't implement the switching ourselves, this is not controlled by the data category option.\n    blockSwitches[\"data_variable\"] = [];\n    blockSwitches[\"data_listcontents\"] = [];\n  };\n  buildSwitches();\n  addon.settings.addEventListener(\"change\", buildSwitches);\n\n  /**\n   * @param {*} workspace\n   * @param {Element} xmlBlock\n   */\n  const pasteBlockXML = (workspace, xmlBlock) => {\n    // Similar to https://github.com/scratchfoundation/scratch-blocks/blob/7575c9a0f2c267676569c4b102b76d77f35d9fd6/core/workspace_svg.js#L1020\n    // but without the collision checking.\n    const block = ScratchBlocks.Xml.domToBlock(xmlBlock, workspace);\n    const x = +xmlBlock.getAttribute(\"x\");\n    const y = +xmlBlock.getAttribute(\"y\");\n    // Don't need to handle RTL here\n    block.moveBy(x, y);\n    return block;\n  };\n\n  /**\n   * @param {string} shadowType The type of shadow eg. \"math_number\"\n   * @returns {string} The name of the shadow's inner field that contains the user-visible value\n   */\n  const getShadowFieldName = (shadowType) => {\n    // This is non-comprehensive.\n    if (shadowType === \"text\") {\n      return \"TEXT\";\n    }\n    if (shadowType === \"colour_picker\") {\n      return \"COLOUR\";\n    }\n    return \"NUM\";\n  };\n\n  /**\n   * @template T\n   * @param {T|()=>T} value\n   * @returns {T}\n   */\n  const callIfFunction = (value) => {\n    if (typeof value === \"function\") {\n      return value();\n    }\n    return value;\n  };\n\n  const menuCallbackFactory = (block, opcodeData) => () => {\n    if (opcodeData.isNoop) {\n      return;\n    }\n\n    if (opcodeData.fieldValue) {\n      block.setFieldValue(opcodeData.fieldValue, \"VALUE\");\n      return;\n    }\n\n    try {\n      ScratchBlocks.Events.setGroup(true);\n\n      const workspace = block.workspace;\n\n      const blocksToBringToForeground = [];\n      // Split inputs before we clone the block.\n      if (opcodeData.splitInputs) {\n        for (const inputName of opcodeData.splitInputs) {\n          const input = block.getInput(inputName);\n          if (!input) {\n            continue;\n          }\n          const connection = input.connection;\n          if (!connection) {\n            continue;\n          }\n          if (connection.isConnected()) {\n            const targetBlock = connection.targetBlock();\n            if (targetBlock.isShadow()) {\n              // Deleting shadows is handled later.\n            } else {\n              connection.disconnect();\n              blocksToBringToForeground.push(targetBlock);\n            }\n          }\n        }\n      }\n\n      // Make a copy of the block with the proper type set.\n      // It doesn't seem to be possible to change a Block's type after it's created, so we'll just make a new block instead.\n      const xml = ScratchBlocks.Xml.blockToDom(block);\n      // blockToDomWithXY's handling of RTL is strange, so we encode the position ourselves.\n      const position = block.getRelativeToSurfaceXY();\n      xml.setAttribute(\"x\", position.x);\n      xml.setAttribute(\"y\", position.y);\n      if (opcodeData.opcode) {\n        xml.setAttribute(\"type\", opcodeData.opcode);\n      }\n\n      const parentBlock = block.getParent();\n      let parentConnection;\n      let blockConnectionType;\n      if (parentBlock) {\n        // If the block has a parent, find the parent -> child connection that will be reattached later.\n        const parentConnections = parentBlock.getConnections_();\n        parentConnection = parentConnections.find(\n          (c) => c.targetConnection && c.targetConnection.sourceBlock_ === block\n        );\n        // There's two types of connections from child -> parent. We need to figure out which one is used.\n        const blockConnections = block.getConnections_();\n        const blockToParentConnection = blockConnections.find(\n          (c) => c.targetConnection && c.targetConnection.sourceBlock_ === parentBlock\n        );\n        blockConnectionType = blockToParentConnection.type;\n      }\n\n      // Array.from creates a clone of the children list. This is important as we may remove\n      // children as we iterate.\n      for (const child of Array.from(xml.children)) {\n        const oldName = child.getAttribute(\"name\");\n\n        // Any inputs that were supposed to be split that were not should be removed.\n        // (eg. shadow inputs)\n        if (opcodeData.splitInputs && opcodeData.splitInputs.includes(oldName)) {\n          xml.removeChild(child);\n          continue;\n        }\n\n        const newName = opcodeData.remapInputName && opcodeData.remapInputName[oldName];\n        if (newName) {\n          child.setAttribute(\"name\", newName);\n        }\n\n        const newShadowType = opcodeData.remapShadowType && opcodeData.remapShadowType[oldName];\n        if (newShadowType) {\n          const valueNode = child.firstChild;\n          const fieldNode = valueNode.firstChild;\n          valueNode.setAttribute(\"type\", newShadowType);\n          fieldNode.setAttribute(\"name\", getShadowFieldName(newShadowType));\n        }\n\n        const fieldValueMap = opcodeData.mapFieldValues && opcodeData.mapFieldValues[oldName];\n        if (fieldValueMap && child.tagName === \"FIELD\") {\n          const oldValue = child.innerText;\n          const newValue = fieldValueMap[oldValue];\n          if (typeof newValue === \"string\") {\n            child.innerText = newValue;\n          }\n        }\n      }\n\n      if (opcodeData.mutate) {\n        const mutation = xml.querySelector(\"mutation\");\n        for (const [key, value] of Object.entries(opcodeData.mutate)) {\n          mutation.setAttribute(key, value);\n        }\n      }\n\n      if (opcodeData.createInputs) {\n        for (const [inputName, inputData] of Object.entries(opcodeData.createInputs)) {\n          const valueElement = document.createElement(\"value\");\n          valueElement.setAttribute(\"name\", inputName);\n\n          const shadowElement = document.createElement(\"shadow\");\n          shadowElement.setAttribute(\"type\", inputData.shadowType);\n\n          const shadowFieldElement = document.createElement(\"field\");\n          shadowFieldElement.setAttribute(\"name\", getShadowFieldName(inputData.shadowType));\n          shadowFieldElement.innerText = callIfFunction(inputData.value);\n\n          shadowElement.appendChild(shadowFieldElement);\n          valueElement.appendChild(shadowElement);\n          xml.appendChild(valueElement);\n        }\n      }\n\n      // Remove the old block and insert the new one.\n      block.dispose();\n      const newBlock = pasteBlockXML(workspace, xml);\n\n      if (parentConnection) {\n        // Search for the same type of connection on the new block as on the old block.\n        const newBlockConnections = newBlock.getConnections_();\n        const newBlockConnection = newBlockConnections.find((c) => c.type === blockConnectionType);\n        newBlockConnection.connect(parentConnection);\n      }\n\n      for (const otherBlock of blocksToBringToForeground) {\n        // By re-appending the element, we move it to the end, which will make it display\n        // on top.\n        const svgRoot = otherBlock.getSvgRoot();\n        svgRoot.parentNode.appendChild(svgRoot);\n      }\n    } finally {\n      ScratchBlocks.Events.setGroup(false);\n    }\n  };\n\n  const uniques = (array) => [...new Set(array)];\n\n  addon.tab.createBlockContextMenu(\n    (items, block) => {\n      if (!addon.self.disabled) {\n        const type = block.type;\n        let switches = blockSwitches[block.type] || [];\n\n        const customArgsMode = addon.settings.get(\"customargs\") ? addon.settings.get(\"customargsmode\") : \"off\";\n        if (\n          customArgsMode !== \"off\" &&\n          [\"argument_reporter_boolean\", \"argument_reporter_string_number\"].includes(type) &&\n          // if the arg is a shadow, it's in a procedures_prototype so we don't want it to be switchable\n          !block.isShadow()\n        ) {\n          const customBlocks = getCustomBlocks();\n          if (customArgsMode === \"all\") {\n            switch (type) {\n              case \"argument_reporter_string_number\":\n                switches = Object.values(customBlocks)\n                  .map((cb) => cb.stringArgs)\n                  .flat(1);\n                break;\n              case \"argument_reporter_boolean\":\n                switches = Object.values(customBlocks)\n                  .map((cb) => cb.boolArgs)\n                  .flat(1);\n                break;\n            }\n          } else if (customArgsMode === \"defOnly\") {\n            const root = block.getRootBlock();\n            if (root.type !== \"procedures_definition\") return items;\n            const customBlockObj = customBlocks[root.getChildren(true)[0].getProcCode()];\n            switch (type) {\n              case \"argument_reporter_string_number\":\n                switches = customBlockObj.stringArgs;\n                break;\n              case \"argument_reporter_boolean\":\n                switches = customBlockObj.boolArgs;\n                break;\n            }\n          }\n          const currentValue = block.getFieldValue(\"VALUE\");\n          switches = uniques(switches).map((i) => ({\n            isNoop: i === currentValue,\n            fieldValue: i,\n            msg: i,\n          }));\n        }\n\n        if (block.type === \"procedures_call\") {\n          const proccode = block.getProcCode();\n          if (procedureSwitches[proccode]) {\n            switches = procedureSwitches[proccode];\n          }\n        }\n\n        if (!addon.settings.get(\"noop\")) {\n          switches = switches.filter((i) => !i.isNoop);\n        }\n\n        switches.forEach((opcodeData, i) => {\n          const makeSpaceItemIndex = items.findIndex((obj) => obj._isDevtoolsFirstItem);\n          const insertBeforeIndex =\n            makeSpaceItemIndex !== -1\n              ? // If \"make space\" button exists, add own items before it\n                makeSpaceItemIndex\n              : // If there's no such button, insert at end\n                items.length;\n          const text = opcodeData.msg ? opcodeData.msg : opcodeData.opcode ? msg(opcodeData.opcode) : msg(block.type);\n          items.splice(insertBeforeIndex, 0, {\n            enabled: true,\n            text,\n            callback: menuCallbackFactory(block, opcodeData),\n            separator: i === 0,\n          });\n        });\n\n        if (block.type === \"data_variable\" || block.type === \"data_listcontents\") {\n          // Add top border to first variable (if it exists)\n          const delBlockIndex = items.findIndex((item) => item.text === ScratchBlocks.Msg.DELETE_BLOCK);\n          // firstVariableItem might be undefined, a variable to switch to,\n          // or an item added by editor-devtools (or any addon before this one)\n          const firstVariableItem = items[delBlockIndex + 1];\n          if (firstVariableItem) firstVariableItem.separator = true;\n        }\n      }\n      return items;\n    },\n    { blocks: true }\n  );\n\n  // https://github.com/scratchfoundation/scratch-blocks/blob/abbfe93136fef57fdfb9a077198b0bc64726f012/blocks_vertical/procedures.js#L207-L215\n  // Returns a list like [\"%s\", \"%d\"]\n  const parseArguments = (code) =>\n    code\n      .split(/(?=[^\\\\]%[nbs])/g)\n      .map((i) => i.trim())\n      .filter((i) => i.charAt(0) === \"%\")\n      .map((i) => i.substring(0, 2));\n\n  const getCustomBlocks = () => {\n    const customBlocks = {};\n    const target = vm.editingTarget;\n    Object.values(target.blocks._blocks)\n      .filter((block) => block.opcode === \"procedures_prototype\")\n      .forEach((block) => {\n        const procCode = block.mutation.proccode;\n        const argumentNames = JSON.parse(block.mutation.argumentnames);\n        // argumentdefaults is unreliable, so we have to parse the procedure code to determine argument types\n        const parsedArguments = parseArguments(procCode);\n        const stringArgs = [];\n        const boolArgs = [];\n        for (let i = 0; i < argumentNames.length; i++) {\n          if (parsedArguments[i] === \"%b\") {\n            boolArgs.push(argumentNames[i]);\n          } else {\n            stringArgs.push(argumentNames[i]);\n          }\n        }\n        customBlocks[procCode] = {\n          stringArgs,\n          boolArgs,\n        };\n      });\n    return customBlocks;\n  };\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./style.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"style.css\": _css,\n};\n","import { normalizeHex, getHexRegex } from \"../../libraries/common/cs/normalize-color.js\";\nimport RateLimiter from \"../../libraries/common/cs/rate-limiter.js\";\nimport tinycolor from \"../../libraries/thirdparty/cs/tinycolor-min.js\";\n\nexport default async ({ addon, console, msg }) => {\n  // 250-ms rate limit\n  const rateLimiter = new RateLimiter(250);\n  const setColor = (hex, element) => {\n    hex = normalizeHex(hex);\n    if (!addon.tab.redux.state || !addon.tab.redux.state.scratchGui) return;\n    // The only way to reliably set color is to invoke eye dropper via click()\n    // then faking that the eye dropper reported the value.\n    const onEyeDropperClosed = ({ detail }) => {\n      if (detail.action.type !== \"scratch-gui/color-picker/DEACTIVATE_COLOR_PICKER\") return;\n      addon.tab.redux.removeEventListener(\"statechanged\", onEyeDropperClosed);\n      setTimeout(() => {\n        document.body.classList.remove(\"sa-hide-eye-dropper-background\");\n      }, 50);\n    };\n    const onEyeDropperOpened = ({ detail }) => {\n      if (detail.action.type !== \"scratch-gui/color-picker/ACTIVATE_COLOR_PICKER\") return;\n      addon.tab.redux.removeEventListener(\"statechanged\", onEyeDropperOpened);\n      addon.tab.redux.addEventListener(\"statechanged\", onEyeDropperClosed);\n      setTimeout(() => {\n        addon.tab.redux.dispatch({\n          type: \"scratch-gui/color-picker/DEACTIVATE_COLOR_PICKER\",\n          color: hex,\n        });\n      }, 50);\n    };\n    addon.tab.redux.addEventListener(\"statechanged\", onEyeDropperOpened);\n    document.body.classList.add(\"sa-hide-eye-dropper-background\");\n    element.click();\n  };\n  const addColorPicker = (editor) => {\n    const element = document.querySelector(\"button.scratchEyedropper\");\n    rateLimiter.abort(false);\n    addon.tab.redux.initialize();\n    const defaultColor = editor.getValue();\n    const saColorPicker = Object.assign(document.createElement(\"div\"), {\n      className: \"sa-color-picker sa-color-picker-code\",\n    });\n    addon.tab.displayNoneWhileDisabled(saColorPicker, { display: \"flex\" });\n    const saColorPickerColor = Object.assign(document.createElement(\"input\"), {\n      className: \"sa-color-picker-color sa-color-picker-code-color\",\n      type: \"color\",\n      value: defaultColor || \"#000000\",\n    });\n    const saColorPickerText = Object.assign(document.createElement(\"input\"), {\n      className: addon.tab.scratchClass(\"input_input-form\", {\n        others: \"sa-color-picker-text sa-color-picker-code-text\",\n      }),\n      type: \"text\",\n      pattern: \"^#?([0-9a-fA-F]{3}){1,2}$\",\n      placeholder: msg(\"hex\"),\n      value: defaultColor || \"\",\n    });\n    saColorPickerColor.addEventListener(\"input\", () =>\n      rateLimiter.limit(() => setColor((saColorPickerText.value = saColorPickerColor.value), element))\n    );\n    saColorPickerText.addEventListener(\"change\", () => {\n      const { value } = saColorPickerText;\n      if (!getHexRegex().test(value)) return;\n      setColor((saColorPickerColor.value = normalizeHex(value)), element);\n    });\n    saColorPicker.appendChild(saColorPickerColor);\n    saColorPicker.appendChild(saColorPickerText);\n    element.parentElement.insertBefore(saColorPicker, element);\n  };\n  const ScratchBlocks = await addon.tab.traps.getBlockly();\n  const originalShowEditor = ScratchBlocks.FieldColourSlider.prototype.showEditor_;\n  ScratchBlocks.FieldColourSlider.prototype.showEditor_ = function (...args) {\n    const r = originalShowEditor.call(this, ...args);\n    addColorPicker(this);\n    return r;\n  };\n  const originalCallbackFactory = ScratchBlocks.FieldColourSlider.prototype.sliderCallbackFactory_;\n  ScratchBlocks.FieldColourSlider.prototype.sliderCallbackFactory_ = function (...args) {\n    const f = originalCallbackFactory.call(this, ...args);\n    return (event) => {\n      const r = f(event);\n      const div = ScratchBlocks.DropDownDiv.getContentDiv();\n      if (div) {\n        const saColorPickerColor = div.querySelector(\".sa-color-picker-color.sa-color-picker-code-color\");\n        const saColorPickerText = div.querySelector(\".sa-color-picker-text.sa-color-picker-code-text\");\n        if (!saColorPickerColor || !saColorPickerText) return r;\n        const color = this.getValue();\n        saColorPickerColor.value = color || \"#000000\";\n        saColorPickerText.value = color || \"\";\n      }\n      return r;\n    };\n  };\n};\n","import codeEditorHandler from \"./code-editor.js\";\n\nexport default async (api) => {\n  codeEditorHandler(api);\n};\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userstyle.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"userstyle.css\": _css,\n};\n","export default async function ({ addon, console }) {\n  const vm = addon.tab.traps.vm;\n\n  const updateStyles = () => {\n    previewInner.classList.toggle(\"sa-comment-preview-delay\", addon.settings.get(\"delay\") !== \"none\");\n    previewInner.classList.toggle(\"sa-comment-preview-reduce-transparency\", addon.settings.get(\"reduce-transparency\"));\n    previewInner.classList.toggle(\"sa-comment-preview-fade\", !addon.settings.get(\"reduce-animation\"));\n  };\n\n  const afterDelay = (cb) => {\n    if (!previewInner.classList.contains(\"sa-comment-preview-hidden\")) {\n      // If not hidden, updating immediately is preferred\n      cb();\n      return;\n    }\n    const delay = addon.settings.get(\"delay\");\n    if (delay === \"long\") return setTimeout(cb, 500);\n    if (delay === \"short\") return setTimeout(cb, 300);\n    cb();\n  };\n\n  let hoveredElement = null;\n  let showTimeout = null;\n  let mouseX = 0;\n  let mouseY = 0;\n  let doNotShowUntilMoveMouse = false;\n\n  const previewOuter = document.createElement(\"div\");\n  previewOuter.classList.add(\"sa-comment-preview-outer\");\n  const previewInner = document.createElement(\"div\");\n  previewInner.classList.add(\"sa-comment-preview-inner\");\n  previewInner.classList.add(\"sa-comment-preview-hidden\");\n  updateStyles();\n  addon.settings.addEventListener(\"change\", updateStyles);\n  addon.tab.displayNoneWhileDisabled(previewOuter);\n  previewOuter.appendChild(previewInner);\n  document.body.appendChild(previewOuter);\n\n  const getBlock = (id) => vm.editingTarget.blocks.getBlock(id) || vm.runtime.flyoutBlocks.getBlock(id);\n  const getComment = (block) => block && block.comment && vm.editingTarget.comments[block.comment];\n  const getProcedureDefinitionBlock = (procCode) => {\n    const procedurePrototype = Object.values(vm.editingTarget.blocks._blocks).find(\n      (i) => i.opcode === \"procedures_prototype\" && i.mutation.proccode === procCode\n    );\n    if (procedurePrototype) {\n      // Usually `parent` will exist but sometimes it doesn't\n      if (procedurePrototype.parent) {\n        return getBlock(procedurePrototype.parent);\n      }\n      const id = procedurePrototype.id;\n      return Object.values(vm.editingTarget.blocks._blocks).find(\n        (i) => i.opcode === \"procedures_definition\" && i.inputs.custom_block && i.inputs.custom_block.block === id\n      );\n    }\n    return null;\n  };\n\n  const setText = (text) => {\n    previewInner.innerText = text;\n    previewInner.classList.remove(\"sa-comment-preview-hidden\");\n    updateMousePosition();\n  };\n\n  const updateMousePosition = () => {\n    previewOuter.style.transform = `translate(${mouseX + 8}px, ${mouseY + 8}px)`;\n  };\n\n  const hidePreview = () => {\n    if (hoveredElement) {\n      hoveredElement = null;\n      previewInner.classList.add(\"sa-comment-preview-hidden\");\n    }\n  };\n\n  document.addEventListener(\"mouseover\", (e) => {\n    if (addon.self.disabled) {\n      return;\n    }\n    clearTimeout(showTimeout);\n    if (doNotShowUntilMoveMouse) {\n      return;\n    }\n\n    const el = e.target.closest(\".blocklyBubbleCanvas > g, .blocklyBlockCanvas .blocklyDraggable[data-id]\");\n    if (el === hoveredElement) {\n      // Nothing to do.\n      return;\n    }\n    if (!el) {\n      hidePreview();\n      return;\n    }\n\n    let text = null;\n    if (\n      addon.settings.get(\"hover-view\") &&\n      e.target.closest(\".blocklyBubbleCanvas > g\") &&\n      // Hovering over the thin line that connects comments to blocks should never show a preview\n      !e.target.closest(\"line\")\n    ) {\n      const collapsedText = el.querySelector(\"text.scratchCommentText\");\n      if (collapsedText.getAttribute(\"display\") !== \"none\") {\n        const textarea = el.querySelector(\"textarea\");\n        text = textarea.value;\n      }\n    } else if (e.target.closest(\".blocklyBlockCanvas .blocklyDraggable[data-id]\")) {\n      const id = el.dataset.id;\n      const block = getBlock(id);\n      const comment = getComment(block);\n      if (addon.settings.get(\"hover-view-block\") && comment) {\n        text = comment.text;\n      } else if (block && block.opcode === \"procedures_call\" && addon.settings.get(\"hover-view-procedure\")) {\n        const procCode = block.mutation.proccode;\n        const procedureDefinitionBlock = getProcedureDefinitionBlock(procCode);\n        const procedureComment = getComment(procedureDefinitionBlock);\n        if (procedureComment) {\n          text = procedureComment.text;\n        }\n      }\n    }\n\n    if (text !== null && text.trim() !== \"\") {\n      showTimeout = afterDelay(() => {\n        hoveredElement = el;\n        setText(text);\n      });\n    } else {\n      hidePreview();\n    }\n  });\n\n  document.addEventListener(\"mousemove\", (e) => {\n    mouseX = e.clientX;\n    mouseY = e.clientY;\n    doNotShowUntilMoveMouse = false;\n    if (addon.settings.get(\"follow-mouse\") && !previewInner.classList.contains(\"sa-comment-preview-hidden\")) {\n      updateMousePosition();\n    }\n  });\n\n  document.addEventListener(\n    \"mousedown\",\n    () => {\n      hidePreview();\n      doNotShowUntilMoveMouse = true;\n    },\n    {\n      capture: true,\n    }\n  );\n}\n","// import ShowBroadcast from \"./show-broadcast.js\";\nimport DomHelpers from \"./DomHelpers.js\";\nimport UndoGroup from \"./UndoGroup.js\";\n\nexport default class DevTools {\n  constructor(addon, msg, m) {\n    this.addon = addon;\n    this.msg = msg;\n    this.m = m;\n    /**\n     * @type {VirtualMachine}\n     */\n    this.domHelpers = new DomHelpers(addon);\n\n    this.codeTab = null;\n    this.costTab = null;\n    this.costTabBody = null;\n    this.selVarID = null;\n    this.canShare = false;\n\n    this.mouseXY = { x: 0, y: 0 };\n  }\n\n  async init() {\n    this.addContextMenus();\n    while (true) {\n      const root = await this.addon.tab.waitForElement(\"ul[class*=gui_tab-list_]\", {\n        markAsSeen: true,\n        reduxEvents: [\n          \"scratch-gui/mode/SET_PLAYER\",\n          \"fontsLoaded/SET_FONTS_LOADED\",\n          \"scratch-gui/locales/SELECT_LOCALE\",\n        ],\n        reduxCondition: (state) => !state.scratchGui.mode.isPlayerOnly,\n      });\n      this.initInner(root);\n    }\n  }\n  async addContextMenus() {\n    const blockly = await this.addon.tab.traps.getBlockly();\n    const oldCleanUpFunc = blockly.WorkspaceSvg.prototype.cleanUp;\n    const self = this;\n    blockly.WorkspaceSvg.prototype.cleanUp = function () {\n      if (self.addon.settings.get(\"enableCleanUpPlus\")) {\n        self.doCleanUp();\n      } else {\n        oldCleanUpFunc.call(this);\n      }\n    };\n\n    let originalMsg = blockly.Msg.CLEAN_UP;\n    if (this.addon.settings.get(\"enableCleanUpPlus\")) blockly.Msg.CLEAN_UP = this.m(\"clean-plus\");\n    this.addon.settings.addEventListener(\"change\", () => {\n      if (this.addon.settings.get(\"enableCleanUpPlus\")) blockly.Msg.CLEAN_UP = this.m(\"clean-plus\");\n      else blockly.Msg.CLEAN_UP = originalMsg;\n    });\n\n    this.addon.tab.createBlockContextMenu(\n      (items, block) => {\n        items.push({\n          enabled: blockly.clipboardXml_,\n          text: this.m(\"paste\"),\n          separator: true,\n          _isDevtoolsFirstItem: true,\n          callback: () => {\n            let ids = this.getTopBlockIDs();\n\n            document.dispatchEvent(\n              new KeyboardEvent(\"keydown\", {\n                keyCode: 86,\n                ctrlKey: true,\n                griff: true,\n              })\n            );\n\n            setTimeout(() => {\n              this.beginDragOfNewBlocksNotInIDs(ids);\n            }, 10);\n          },\n        });\n        return items;\n      },\n      { workspace: true }\n    );\n    this.addon.tab.createBlockContextMenu(\n      (items, block) => {\n        items.push(\n          {\n            enabled: true,\n            text: this.m(\"make-space\"),\n            _isDevtoolsFirstItem: true,\n            callback: () => {\n              this.doCleanUp(block);\n            },\n            separator: true,\n          },\n          {\n            enabled: true,\n            text: this.m(\"copy-all\"),\n            callback: () => {\n              this.eventCopyClick(block);\n            },\n            separator: true,\n          },\n          {\n            enabled: true,\n            text: this.m(\"copy-block\"),\n            callback: () => {\n              this.eventCopyClick(block, 1);\n            },\n          },\n          {\n            enabled: true,\n            text: this.m(\"cut-block\"),\n            callback: () => {\n              this.eventCopyClick(block, 2);\n            },\n          }\n        );\n        // const BROADCAST_BLOCKS = [\"event_whenbroadcastreceived\", \"event_broadcast\", \"event_broadcastandwait\"];\n        // if (BROADCAST_BLOCKS.includes(block.type)) {\n        //   // Show Broadcast\n        //   const broadcastId = this.showBroadcastSingleton.getAssociatedBroadcastId(block.id);\n        //   if (broadcastId) {\n        //     [\"Senders\", \"Receivers\"].forEach((showKey, i) => {\n        //       items.push({\n        //         enabled: true,\n        //         text: this.msg(`show-${showKey}`.toLowerCase()),\n        //         callback: () => {\n        //           this.showBroadcastSingleton[`show${showKey}`](broadcastId);\n        //         },\n        //         separator: i == 0,\n        //       });\n        //     });\n        //   }\n        // }\n        return items;\n      },\n      { blocks: true }\n    );\n    this.addon.tab.createBlockContextMenu(\n      (items, block) => {\n        if (block.getCategory() === \"data\" || block.getCategory() === \"data-lists\") {\n          this.selVarID = block.getVars()[0];\n          items.push({\n            enabled: true,\n            text: this.m(\"swap\", { var: block.getCategory() === \"data\" ? this.m(\"variables\") : this.m(\"lists\") }),\n            callback: async () => {\n              let wksp = this.getWorkspace();\n              let v = wksp.getVariableById(this.selVarID);\n              // prompt() returns Promise in desktop app\n              let varName = await window.prompt(this.msg(\"replace\", { name: v.name }));\n              if (varName) {\n                this.doReplaceVariable(this.selVarID, varName, v.type);\n              }\n            },\n            separator: true,\n          });\n        }\n        return items;\n      },\n      { blocks: true, flyout: true }\n    );\n  }\n\n  getWorkspace() {\n    return Blockly.getMainWorkspace();\n  }\n\n  isCostumeEditor() {\n    return this.costTab.className.indexOf(\"gui_is-selected\") >= 0;\n  }\n\n  /**\n   * A nicely ordered version of the top blocks\n   * @returns {[Blockly.Block]}\n   */\n  getTopBlocks() {\n    let result = this.getOrderedTopBlockColumns();\n    let columns = result.cols;\n    /**\n     * @type {[[Blockly.Block]]}\n     */\n    let topBlocks = [];\n    for (const col of columns) {\n      topBlocks = topBlocks.concat(col.blocks);\n    }\n    return topBlocks;\n  }\n\n  /**\n   * A much nicer way of laying out the blocks into columns\n   */\n  doCleanUp(block) {\n    let workspace = this.getWorkspace();\n    let makeSpaceForBlock = block && block.getRootBlock();\n\n    UndoGroup.startUndoGroup(workspace);\n\n    let result = this.getOrderedTopBlockColumns(true);\n    let columns = result.cols;\n    let orphanCount = result.orphans.blocks.length;\n    if (orphanCount > 0 && !block) {\n      let message = this.msg(\"orphaned\", {\n        count: orphanCount,\n      });\n      if (confirm(message)) {\n        for (const block of result.orphans.blocks) {\n          block.dispose();\n        }\n      } else {\n        columns.unshift(result.orphans);\n      }\n    }\n\n    let cursorX = 48;\n\n    let maxWidths = result.maxWidths;\n\n    for (const column of columns) {\n      let cursorY = 64;\n      let maxWidth = 0;\n\n      for (const block of column.blocks) {\n        let extraWidth = block === makeSpaceForBlock ? 380 : 0;\n        let extraHeight = block === makeSpaceForBlock ? 480 : 72;\n        let xy = block.getRelativeToSurfaceXY();\n        if (cursorX - xy.x !== 0 || cursorY - xy.y !== 0) {\n          block.moveBy(cursorX - xy.x, cursorY - xy.y);\n        }\n        let heightWidth = block.getHeightWidth();\n        cursorY += heightWidth.height + extraHeight;\n\n        let maxWidthWithComments = maxWidths[block.id] || 0;\n        maxWidth = Math.max(maxWidth, Math.max(heightWidth.width + extraWidth, maxWidthWithComments));\n      }\n\n      cursorX += maxWidth + 96;\n    }\n\n    let topComments = workspace.getTopComments();\n    for (const comment of topComments) {\n      if (comment.setVisible) {\n        comment.setVisible(false);\n        comment.needsAutoPositioning_ = true;\n        comment.setVisible(true);\n      }\n    }\n\n    setTimeout(() => {\n      // Locate unused local variables...\n      let workspace = this.getWorkspace();\n      let map = workspace.getVariableMap();\n      let vars = map.getVariablesOfType(\"\");\n      let unusedLocals = [];\n\n      for (const row of vars) {\n        if (row.isLocal) {\n          let usages = map.getVariableUsesById(row.getId());\n          if (!usages || usages.length === 0) {\n            unusedLocals.push(row);\n          }\n        }\n      }\n\n      if (unusedLocals.length > 0) {\n        const unusedCount = unusedLocals.length;\n        let message = this.msg(\"unused-var\", {\n          count: unusedCount,\n        });\n        for (let i = 0; i < unusedLocals.length; i++) {\n          let orphan = unusedLocals[i];\n          if (i > 0) {\n            message += \", \";\n          }\n          message += orphan.name;\n        }\n        if (confirm(message)) {\n          for (const orphan of unusedLocals) {\n            workspace.deleteVariableById(orphan.getId());\n          }\n        }\n      }\n\n      // Locate unused local lists...\n      let lists = map.getVariablesOfType(\"list\");\n      let unusedLists = [];\n\n      for (const row of lists) {\n        if (row.isLocal) {\n          let usages = map.getVariableUsesById(row.getId());\n          if (!usages || usages.length === 0) {\n            unusedLists.push(row);\n          }\n        }\n      }\n      if (unusedLists.length > 0) {\n        const unusedCount = unusedLists.length;\n        let message = this.msg(\"unused-list\", {\n          count: unusedCount,\n        });\n        for (let i = 0; i < unusedLists.length; i++) {\n          let orphan = unusedLists[i];\n          if (i > 0) {\n            message += \", \";\n          }\n          message += orphan.name;\n        }\n        if (confirm(message)) {\n          for (const orphan of unusedLists) {\n            workspace.deleteVariableById(orphan.getId());\n          }\n        }\n      }\n\n      UndoGroup.endUndoGroup(workspace);\n    }, 100);\n  }\n\n  /**\n   * Badly Orphaned - might want to delete these!\n   * @param topBlock\n   * @returns {boolean}\n   */\n  isBlockAnOrphan(topBlock) {\n    return !!topBlock.outputConnection;\n  }\n\n  /**\n   * Split the top blocks into ordered columns\n   * @param separateOrphans true to keep all orphans separate\n   * @returns {{orphans: {blocks: [Block], x: number, count: number}, cols: [Col]}}\n   */\n  getOrderedTopBlockColumns(separateOrphans) {\n    let w = this.getWorkspace();\n    let topBlocks = w.getTopBlocks();\n    let maxWidths = {};\n\n    if (separateOrphans) {\n      let topComments = w.getTopComments();\n\n      // todo: tie comments to blocks... find widths and width of block stack row...\n      for (const comment of topComments) {\n        // comment.autoPosition_();\n        // Hiding and showing repositions the comment right next to it's block - nice!\n        if (comment.setVisible) {\n          comment.setVisible(false);\n          comment.needsAutoPositioning_ = true;\n          comment.setVisible(true);\n\n          // let bb = comment.block_.svgPath_.getBBox();\n          let right = comment.getBoundingRectangle().bottomRight.x;\n\n          // Get top block for stack...\n          let root = comment.block_.getRootBlock();\n          let left = root.getBoundingRectangle().topLeft.x;\n          maxWidths[root.id] = Math.max(right - left, maxWidths[root.id] || 0);\n        }\n      }\n    }\n\n    // Default scratch ordering is horrid... Lets try something more clever.\n\n    /**\n     * @type {Col[]}\n     */\n    let cols = [];\n    const TOLERANCE = 256;\n    let orphans = { x: -999999, count: 0, blocks: [] };\n\n    for (const topBlock of topBlocks) {\n      // let r = b.getBoundingRectangle();\n      let position = topBlock.getRelativeToSurfaceXY();\n      /**\n       * @type {Col}\n       */\n      let bestCol = null;\n      let bestError = TOLERANCE;\n\n      if (separateOrphans && this.isBlockAnOrphan(topBlock)) {\n        orphans.blocks.push(topBlock);\n        continue;\n      }\n\n      // Find best columns\n      for (const col of cols) {\n        let err = Math.abs(position.x - col.x);\n        if (err < bestError) {\n          bestError = err;\n          bestCol = col;\n        }\n      }\n\n      if (bestCol) {\n        // We found a column that we fitted into\n        bestCol.x = (bestCol.x * bestCol.count + position.x) / ++bestCol.count; // re-average the columns as more items get added...\n        bestCol.blocks.push(topBlock);\n      } else {\n        // Create a new column\n        cols.push(new Col(position.x, 1, [topBlock]));\n      }\n    }\n\n    // if (orphans.blocks.length > 0) {\n    //     cols.push(orphans);\n    // }\n\n    // Sort columns, then blocks inside the columns\n    cols.sort((a, b) => a.x - b.x);\n    for (const col of cols) {\n      col.blocks.sort((a, b) => a.getRelativeToSurfaceXY().y - b.getRelativeToSurfaceXY().y);\n    }\n\n    return { cols: cols, orphans: orphans, maxWidths: maxWidths };\n  }\n\n  /**\n   * Find all the uses of a named variable.\n   * @param {string} id ID of the variable to find.\n   * @return {!Array.<!Blockly.Block>} Array of block usages.\n   */\n  getVariableUsesById(id) {\n    let uses = [];\n\n    let topBlocks = this.getTopBlocks(true); // todo: Confirm this was the right getTopBlocks?\n    for (const topBlock of topBlocks) {\n      /** @type {!Array<!Blockly.Block>} */\n      let kids = topBlock.getDescendants();\n      for (const block of kids) {\n        /** @type {!Array<!Blockly.VariableModel>} */\n        let blockVariables = block.getVarModels();\n        if (blockVariables) {\n          for (const blockVar of blockVariables) {\n            if (blockVar.getId() === id) {\n              uses.push(block);\n            }\n          }\n        }\n      }\n    }\n\n    return uses;\n  }\n\n  /**\n   * Quick and dirty replace all instances of one variable / list with another variable / list\n   * @param varId original variable name\n   * @param newVarName new variable name\n   * @param type type of variable (\"\" = variable, anything else is a list?\n   */\n  doReplaceVariable(varId, newVarName, type) {\n    let wksp = this.getWorkspace();\n    let v = wksp.getVariable(newVarName, type);\n    if (!v) {\n      alert(this.msg(\"var-not-exist\"));\n      return;\n    }\n    let newVId = v.getId();\n\n    UndoGroup.startUndoGroup(wksp);\n    let blocks = this.getVariableUsesById(varId);\n    for (const block of blocks) {\n      try {\n        if (type === \"\") {\n          block.getField(\"VARIABLE\").setValue(newVId);\n        } else {\n          block.getField(\"LIST\").setValue(newVId);\n        }\n      } catch (e) {\n        // ignore\n      }\n    }\n    UndoGroup.endUndoGroup(wksp);\n  }\n\n  /*\n    function doInjectScripts(codeString) {\n      let w = getWorkspace();\n      let xml = new XML(); // document.implementation.createDocument(null, \"xml\");\n      let x = xml.xmlDoc.firstChild;\n\n      let tree = math.parse(codeString);\n      console.log(tree);\n\n      const binaryOperatorTypes = {\n        add: \"operator_add\",\n        subtract: \"operator_subtract\",\n        this.multiply: \"operator_multiply\",\n        divide: \"operator_divide\",\n      };\n\n      const BLOCK_TYPE = {\n        number: \"math_number\",\n        text: \"text\",\n      };\n\n      function translateMathToXml(x, tree, shadowType) {\n        let xShadowField = null;\n        if (shadowType) {\n          let xShadow = xml.newXml(x, \"shadow\", { type: shadowType });\n          if (shadowType === BLOCK_TYPE.number) {\n            xShadowField = xml.newXml(xShadow, \"field\", { name: \"NUM\" });\n          } else if (shadowType === BLOCK_TYPE.text) {\n            xShadowField = xml.newXml(xShadow, \"field\", { name: \"TEXT\" });\n          }\n        }\n\n        if (!tree || !tree.type) {\n          return;\n        }\n\n        if (tree.type === \"OperatorNode\") {\n          let operatorType = binaryOperatorTypes[tree.fn];\n          if (operatorType) {\n            let xOp = newXml(x, \"block\", { type: operatorType });\n            translateMathToXml(xml.newXml(xOp, \"value\", { name: \"NUM1\" }), tree.args[0], BLOCK_TYPE.number);\n            translateMathToXml(xml.newXml(xOp, \"value\", { name: \"NUM2\" }), tree.args[1], BLOCK_TYPE.number);\n            return;\n          }\n\n          return;\n        }\n\n        if (tree.type === \"ConstantNode\") {\n          // number or text in quotes\n          if (xShadowField) {\n            xml.setAttr(xShadowField, { text: tree.value });\n          }\n          return;\n        }\n\n        if (tree.type === \"SymbolNode\") {\n          // variable\n          let xVar = xml.newXml(x, \"block\", { type: \"data_variable\" });\n          xml.newXml(xVar, \"field\", { name: \"VARIABLE\", text: tree.name });\n          return;\n        }\n\n        if (tree.type === \"FunctionNode\") {\n          // Method Call\n          if (tree.fn.name === \"join\") {\n            let xOp = newXml(x, \"block\", { type: \"operator_join\" });\n            translateMathToXml(xml.newXml(xOp, \"value\", { name: \"STRING1\" }), tree.args[0], BLOCK_TYPE.text);\n            translateMathToXml(xml.newXml(xOp, \"value\", { name: \"STRING2\" }), tree.args[1], BLOCK_TYPE.text);\n            return;\n          }\n        }\n      }\n\n      translateMathToXml(x, tree);\n      console.log(x);\n\n      let ids = Blockly.Xml.domToWorkspace(x, w);\n      console.log(ids);\n    }\n     */\n  /*\n    function clickInject(e) {\n      let codeString = window.prompt(\"Griffpatch: Enter an expression (i.e. a+2*3)\");\n      if (codeString) {\n        doInjectScripts(codeString);\n      }\n      e.preventDefault();\n      return false;\n    }\n    */\n\n  /**\n   * Returns a Set of the top blocks in this workspace / sprite\n   * @returns {Set<any>} Set of top blocks\n   */\n  getTopBlockIDs() {\n    let wksp = this.getWorkspace();\n    let topBlocks = wksp.getTopBlocks();\n    let ids = new Set();\n    for (const block of topBlocks) {\n      ids.add(block.id);\n    }\n    return ids;\n  }\n\n  /**\n   * Initiates a drag event for all block stacks except those in the set of ids.\n   * But why? - Because we know all the ids of the existing stacks before we paste / duplicate - so we can find the\n   * new stack by excluding all the known ones.\n   * @param ids Set of previously known ids\n   */\n  beginDragOfNewBlocksNotInIDs(ids) {\n    if (!this.addon.settings.get(\"enablePasteBlocksAtMouse\")) {\n      return;\n    }\n    let wksp = this.getWorkspace();\n    let topBlocks = wksp.getTopBlocks();\n    for (const block of topBlocks) {\n      if (!ids.has(block.id)) {\n        // console.log(\"I found a new block!!! - \" + block.id);\n        // todo: move the block to the mouse pointer?\n        let mouseXYClone = { x: this.mouseXY.x, y: this.mouseXY.y };\n        block.setIntersects(true); // fixes offscreen block pasting in TurboWarp\n        this.domHelpers.triggerDragAndDrop(block.svgPath_, null, mouseXYClone);\n      }\n    }\n  }\n\n  updateMousePosition(e) {\n    this.mouseXY.x = e.clientX;\n    this.mouseXY.y = e.clientY;\n  }\n\n  eventMouseMove(e) {\n    this.updateMousePosition(e);\n  }\n\n  eventKeyDown(e) {\n    const switchCostume = (up) => {\n      // todo: select previous costume\n      let selected = this.costTabBody.querySelector(\"div[class*='sprite-selector-item_is-selected']\");\n      let node = up ? selected.parentNode.previousSibling : selected.parentNode.nextSibling;\n      if (node) {\n        let wrapper = node.closest(\"div[class*=gui_flex-wrapper]\");\n        node.querySelector(\"div[class^='sprite-selector-item_sprite-name']\").click();\n        node.scrollIntoView({\n          behavior: \"auto\",\n          block: \"center\",\n          inline: \"start\",\n        });\n        wrapper.scrollTop = 0;\n      }\n    };\n\n    if (document.URL.indexOf(\"editor\") <= 0) {\n      return;\n    }\n\n    let ctrlKey = e.ctrlKey || e.metaKey;\n\n    if (e.key === \"ArrowLeft\" && ctrlKey) {\n      // Ctrl + Left Arrow Key\n      if (document.activeElement.tagName === \"INPUT\") {\n        return;\n      }\n\n      if (this.isCostumeEditor()) {\n        switchCostume(true);\n        e.cancelBubble = true;\n        e.preventDefault();\n        return true;\n      }\n    }\n\n    if (e.key === \"ArrowRight\" && ctrlKey) {\n      // Ctrl + Right Arrow Key\n      if (document.activeElement.tagName === \"INPUT\") {\n        return;\n      }\n\n      if (this.isCostumeEditor()) {\n        switchCostume(false);\n        e.cancelBubble = true;\n        e.preventDefault();\n        return true;\n      }\n    }\n\n    if (e.keyCode === 86 && ctrlKey && !e.griff) {\n      // Ctrl + V\n      // Set a timeout so we can take control of the paste after the event\n      let ids = this.getTopBlockIDs();\n      setTimeout(() => {\n        this.beginDragOfNewBlocksNotInIDs(ids);\n      }, 10);\n    }\n\n    // if (e.keyCode === 220 && (!document.activeElement || document.activeElement.tagName === 'INPUT')) {\n    //\n    // }\n  }\n\n  eventCopyClick(block, blockOnly) {\n    let wksp = this.getWorkspace();\n\n    if (block) {\n      block.select();\n      let next = blockOnly ? block.getNextBlock() : null;\n      if (next) {\n        next.unplug(false); // setParent(null);\n      }\n\n      // separate child temporarily\n      document.dispatchEvent(new KeyboardEvent(\"keydown\", { keyCode: 67, ctrlKey: true }));\n      if (next || blockOnly === 2) {\n        setTimeout(() => {\n          if (next) {\n            wksp.undo(); // undo the unplug above...\n          }\n          if (blockOnly === 2) {\n            UndoGroup.startUndoGroup(wksp);\n            block.dispose(true);\n            UndoGroup.endUndoGroup(wksp);\n          }\n        }, 0);\n      }\n    }\n  }\n\n  eventMouseDown(e) {\n    this.updateMousePosition(e);\n  }\n\n  eventMouseUp(e) {\n    this.updateMousePosition(e);\n  }\n\n  initInner(root) {\n    let guiTabs = root.childNodes;\n\n    if (this.codeTab && guiTabs[0] !== this.codeTab) {\n      // We have been CHANGED!!! - Happens when going to project page, and then back inside again!!!\n      this.domHelpers.unbindAllEvents();\n    }\n\n    this.codeTab = guiTabs[0];\n    this.costTab = guiTabs[1];\n    this.costTabBody = document.querySelector(\"div[aria-labelledby=\" + this.costTab.id + \"]\");\n\n    this.domHelpers.bindOnce(document, \"keydown\", (...e) => this.eventKeyDown(...e), true);\n    this.domHelpers.bindOnce(document, \"mousemove\", (...e) => this.eventMouseMove(...e), true);\n    this.domHelpers.bindOnce(document, \"mousedown\", (...e) => this.eventMouseDown(...e), true); // true to capture all mouse downs 'before' the dom events handle them\n    this.domHelpers.bindOnce(document, \"mouseup\", (...e) => this.eventMouseUp(...e), true);\n  }\n}\n\nclass Col {\n  /**\n   * @param x {Number} x position (for ordering)\n   * @param count {Number}\n   * @param blocks {[Block]}\n   */\n  constructor(x, count, blocks) {\n    /**\n     * x position (for ordering)\n     * @type {Number}\n     */\n    this.x = x;\n    /**\n     * @type {Number}\n     */\n    this.count = count;\n    /**\n     * @type {[Blockly.Block]}\n     */\n    this.blocks = blocks;\n  }\n}\n","export default class DomHelpers {\n  constructor(addon) {\n    this.addon = addon;\n    this.vm = addon.tab.traps.vm;\n    /**\n     * @type {eventDetails[]}\n     */\n    this.events = [];\n  }\n\n  /**\n   * Simulate a drag and drop programmatically through javascript\n   * @param selectorDrag\n   * @param selectorDrop\n   * @param mouseXY\n   * @param [shiftKey=false]\n   * @returns {boolean}\n   */\n  triggerDragAndDrop(selectorDrag, selectorDrop, mouseXY, shiftKey) {\n    // function for triggering mouse events\n    shiftKey = shiftKey || false;\n    let fireMouseEvent = function (type, elem, centerX, centerY) {\n      let evt = document.createEvent(\"MouseEvents\");\n      evt.initMouseEvent(type, true, true, window, 1, 1, 1, centerX, centerY, shiftKey, false, false, false, 0, elem);\n      elem.dispatchEvent(evt);\n    };\n\n    // fetch target elements\n    let elemDrag = selectorDrag; // document.querySelector(selectorDrag);\n    let elemDrop = selectorDrop; // document.querySelector(selectorDrop);\n    if (!elemDrag /* || !elemDrop*/) {\n      return false;\n    }\n\n    // calculate positions\n    let pos = elemDrag.getBoundingClientRect();\n    let center1X = Math.floor((pos.left + pos.right) / 2);\n    let center1Y = Math.floor((pos.top + pos.bottom) / 2);\n\n    // mouse over dragged element and mousedown\n    fireMouseEvent(\"mouseover\", elemDrag, center1X, center1Y);\n    fireMouseEvent(\"mousedown\", elemDrag, center1X, center1Y);\n\n    // start dragging process over to drop target\n    fireMouseEvent(\"dragstart\", elemDrag, center1X, center1Y);\n    fireMouseEvent(\"drag\", elemDrag, center1X, center1Y);\n    fireMouseEvent(\"mousemove\", elemDrag, center1X, center1Y);\n\n    if (!elemDrop) {\n      if (mouseXY) {\n        // console.log(mouseXY);\n        let center2X = mouseXY.x;\n        let center2Y = mouseXY.y;\n        fireMouseEvent(\"drag\", elemDrag, center2X, center2Y);\n        fireMouseEvent(\"mousemove\", elemDrag, center2X, center2Y);\n      }\n      return false;\n    }\n\n    pos = elemDrop.getBoundingClientRect();\n    let center2X = Math.floor((pos.left + pos.right) / 2);\n    let center2Y = Math.floor((pos.top + pos.bottom) / 2);\n\n    fireMouseEvent(\"drag\", elemDrag, center2X, center2Y);\n    fireMouseEvent(\"mousemove\", elemDrop, center2X, center2Y);\n\n    // trigger dragging process on top of drop target\n    fireMouseEvent(\"mouseenter\", elemDrop, center2X, center2Y);\n    fireMouseEvent(\"dragenter\", elemDrop, center2X, center2Y);\n    fireMouseEvent(\"mouseover\", elemDrop, center2X, center2Y);\n    fireMouseEvent(\"dragover\", elemDrop, center2X, center2Y);\n\n    // release dragged element on top of drop target\n    fireMouseEvent(\"drop\", elemDrop, center2X, center2Y);\n    fireMouseEvent(\"dragend\", elemDrag, center2X, center2Y);\n    fireMouseEvent(\"mouseup\", elemDrag, center2X, center2Y);\n\n    return true;\n  }\n\n  bindOnce(dom, event, func, capture) {\n    capture = !!capture;\n    dom.removeEventListener(event, func, capture);\n    dom.addEventListener(event, func, capture);\n    this.events.push(new eventDetails(dom, event, func, capture));\n  }\n\n  unbindAllEvents() {\n    for (const event of this.events) {\n      event.dom.removeEventListener(event.event, event.func, event.capture);\n    }\n    this.events = [];\n  }\n}\n\n/**\n * A record of an event\n */\nclass eventDetails {\n  constructor(dom, event, func, capture) {\n    this.dom = dom;\n    this.event = event;\n    this.func = func;\n    this.capture = capture;\n  }\n}\n","/**\n * This class is dedicated to maintaining the Undo stack of Blockly\n * It allows us to initiate an undo group such that all subsequent operations are recorded as a single\n * undoable transaction.\n */\nexport default class UndoGroup {\n  /**\n   * Start an Undo group - begin recording\n   * @param workspace the workspace\n   */\n  static startUndoGroup(workspace) {\n    const undoStack = workspace.undoStack_;\n    if (undoStack.length) {\n      undoStack[undoStack.length - 1]._devtoolsLastUndo = true;\n    }\n  }\n\n  /**\n   * End an Undo group - stops recording\n   * @param workspace the workspace\n   */\n  static endUndoGroup(workspace) {\n    const undoStack = workspace.undoStack_;\n    // Events (responsible for undoStack updates) are delayed with a setTimeout(f, 0)\n    // https://github.com/scratchfoundation/scratch-blocks/blob/f159a1779e5391b502d374fb2fdd0cb5ca43d6a2/core/events.js#L182\n    setTimeout(() => {\n      const group = generateUID();\n      for (let i = undoStack.length - 1; i >= 0 && !undoStack[i]._devtoolsLastUndo; i--) {\n        undoStack[i].group = group;\n      }\n    }, 0);\n  }\n}\n\n/**\n * https://github.com/scratchfoundation/scratch-blocks/blob/f159a1779e5391b502d374fb2fdd0cb5ca43d6a2/core/events.js#L182\n * @returns {string}\n * @private\n */\nfunction generateUID() {\n  const CHARACTERS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!#$%()*+,-./:;=?@[]^_`{|}~\";\n  let result = \"\";\n  for (let i = 0; i < 20; i++) {\n    result += CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];\n  }\n  return result;\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _asset from \"!url-loader!./icon--close.svg\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"icon--close.svg\": _asset,\n};\n","import DevTools from \"./DevTools.js\";\n\nexport default async function ({ addon, console, msg, safeMsg: m }) {\n  const devTools = new DevTools(addon, msg, m);\n  devTools.init();\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userscript.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"userscript.css\": _css,\n};\n","export default async function ({ addon, console, msg }) {\n  const Blockly = await addon.tab.traps.getBlockly();\n  const vm = addon.tab.traps.vm;\n\n  const SCRATCH_ITEMS_TO_HIDE = [\n    \"RENAME_VARIABLE_ID\",\n    \"DELETE_VARIABLE_ID\",\n    \"NEW_BROADCAST_MESSAGE_ID\",\n    // From rename-broadcasts addon\n    \"RENAME_BROADCAST_MESSAGE_ID\",\n  ];\n\n  const canUseAsGlobalVariableName = (name, type) => {\n    return !vm.runtime.getAllVarNamesOfType(type).includes(name);\n  };\n\n  const canUseAsLocalVariableName = (name, type) => {\n    return !vm.editingTarget.lookupVariableByNameAndType(name, type);\n  };\n\n  const ADDON_ITEMS = {\n    createGlobalVariable: {\n      enabled: (name) => canUseAsGlobalVariableName(name, \"\"),\n      createVariable: (workspace, name) => workspace.createVariable(name),\n    },\n    createLocalVariable: {\n      enabled: (name) => canUseAsLocalVariableName(name, \"\"),\n      createVariable: (workspace, name) => workspace.createVariable(name, \"\", null, true),\n    },\n    createGlobalList: {\n      enabled: (name) => canUseAsGlobalVariableName(name, \"list\"),\n      createVariable: (workspace, name) => workspace.createVariable(name, \"list\"),\n    },\n    createLocalList: {\n      enabled: (name) => canUseAsLocalVariableName(name, \"list\"),\n      createVariable: (workspace, name) => workspace.createVariable(name, \"list\", null, true),\n    },\n    createBroadcast: {\n      enabled: (name) => canUseAsGlobalVariableName(name, \"broadcast_msg\"),\n      createVariable: (workspace, name) => workspace.createVariable(name, \"broadcast_msg\"),\n    },\n  };\n\n  let blocklyDropDownContent = null;\n  let blocklyDropdownMenu = null;\n  let searchBar = null;\n  // Contains DOM and addon state\n  let items = [];\n  let searchedItems = [];\n  // Tracks internal Scratch state\n  let currentDropdownOptions = [];\n  let resultOfLastGetOptions = [];\n\n  const oldDropDownDivShow = Blockly.DropDownDiv.show;\n  Blockly.DropDownDiv.show = function (...args) {\n    blocklyDropdownMenu = document.querySelector(\".blocklyDropdownMenu\");\n    if (!blocklyDropdownMenu) {\n      return oldDropDownDivShow.call(this, ...args);\n    }\n\n    blocklyDropdownMenu.focus = () => {}; // no-op focus() so it can't steal it from the search bar\n\n    searchBar = document.createElement(\"input\");\n    addon.tab.displayNoneWhileDisabled(searchBar, { display: \"flex\" });\n    searchBar.type = \"text\";\n    searchBar.addEventListener(\"input\", updateSearch);\n    searchBar.addEventListener(\"keydown\", handleKeyDownEvent);\n    searchBar.classList.add(\"u-dropdown-searchbar\");\n    blocklyDropdownMenu.insertBefore(searchBar, blocklyDropdownMenu.firstChild);\n\n    items = Array.from(blocklyDropdownMenu.children)\n      .filter((child) => child.tagName !== \"INPUT\")\n      .map((element) => ({\n        element,\n        text: element.textContent,\n      }));\n    currentDropdownOptions = resultOfLastGetOptions;\n    updateSearch();\n\n    // Call the original show method after adding everything so that it can perform the correct size calculations\n    const ret = oldDropDownDivShow.call(this, ...args);\n\n    // Lock the size of the dropdown\n    blocklyDropDownContent = Blockly.DropDownDiv.getContentDiv();\n    blocklyDropDownContent.style.width = getComputedStyle(blocklyDropDownContent).width;\n    blocklyDropDownContent.style.height = getComputedStyle(blocklyDropDownContent).height;\n\n    // This is really strange, but if you don't reinsert the search bar into the DOM then focus() doesn't work\n    blocklyDropdownMenu.insertBefore(searchBar, blocklyDropdownMenu.firstChild);\n    searchBar.focus();\n\n    return ret;\n  };\n\n  const oldDropDownDivClearContent = Blockly.DropDownDiv.clearContent;\n  Blockly.DropDownDiv.clearContent = function () {\n    oldDropDownDivClearContent.call(this);\n    items = [];\n    searchedItems = [];\n    Blockly.DropDownDiv.content_.style.height = \"\";\n  };\n\n  const oldFieldDropdownGetOptions = Blockly.FieldDropdown.prototype.getOptions;\n  Blockly.FieldDropdown.prototype.getOptions = function () {\n    const options = oldFieldDropdownGetOptions.call(this);\n    const block = this.sourceBlock_;\n    const isStage = vm.editingTarget && vm.editingTarget.isStage;\n    if (block) {\n      if (block.category_ === \"data\") {\n        options.push(getMenuItemMessage(\"createGlobalVariable\"));\n        if (!isStage) {\n          options.push(getMenuItemMessage(\"createLocalVariable\"));\n        }\n      } else if (block.category_ === \"data-lists\") {\n        options.push(getMenuItemMessage(\"createGlobalList\"));\n        if (!isStage) {\n          options.push(getMenuItemMessage(\"createLocalList\"));\n        }\n      } else if (block.type === \"event_broadcast_menu\" || block.type === \"event_whenbroadcastreceived\") {\n        options.push(getMenuItemMessage(\"createBroadcast\"));\n      }\n    }\n    // Options aren't normally stored anywhere, so we'll store them ourselves.\n    resultOfLastGetOptions = options;\n    return options;\n  };\n\n  const oldFieldVariableOnItemSelected = Blockly.FieldVariable.prototype.onItemSelected;\n  Blockly.FieldVariable.prototype.onItemSelected = function (menu, menuItem) {\n    const sourceBlock = this.sourceBlock_;\n    if (sourceBlock && sourceBlock.workspace && searchBar.value.length !== 0) {\n      const workspace = sourceBlock.workspace;\n      const optionId = menuItem.getValue();\n\n      if (Object.prototype.hasOwnProperty.call(ADDON_ITEMS, optionId)) {\n        const addonItem = ADDON_ITEMS[optionId];\n        Blockly.Events.setGroup(true);\n        const variable = addonItem.createVariable(workspace, searchBar.value.trim());\n        if (this.sourceBlock_) this.setValue(variable.getId());\n        Blockly.Events.setGroup(false);\n        return;\n      }\n    }\n    return oldFieldVariableOnItemSelected.call(this, menu, menuItem);\n  };\n\n  function selectItem(item, click) {\n    // You can't just use click() or focus() because Blockly uses mousedown and mouseup handlers, not click handlers.\n    item.dispatchEvent(new MouseEvent(\"mousedown\", { relatedTarget: item, bubbles: true }));\n    if (click) item.dispatchEvent(new MouseEvent(\"mouseup\", { relatedTarget: item, bubbles: true }));\n\n    // Scroll the item into view if it is offscreen.\n    const itemTop = item.offsetTop;\n    const itemEnd = itemTop + item.offsetHeight;\n\n    const scrollTop = blocklyDropDownContent.scrollTop;\n    const scrollHeight = blocklyDropDownContent.offsetHeight;\n    const scrollEnd = scrollTop + scrollHeight;\n\n    if (scrollTop > itemTop) {\n      blocklyDropDownContent.scrollTop = itemTop;\n    } else if (itemEnd > scrollEnd) {\n      blocklyDropDownContent.scrollTop = itemEnd - scrollHeight;\n    }\n  }\n\n  function performSearch() {\n    const rawQuery = searchBar.value.trim();\n    const query = rawQuery.trim().toLowerCase();\n\n    const rank = (item, index) => {\n      // Negative number will hide\n      // Higher numbers will appear first\n      const option = currentDropdownOptions[index];\n      const optionId = option[1];\n      if (SCRATCH_ITEMS_TO_HIDE.includes(optionId)) {\n        return query ? -1 : 0;\n      } else if (Object.prototype.hasOwnProperty.call(ADDON_ITEMS, optionId)) {\n        if (!query) {\n          return -1;\n        }\n        const addonInfo = ADDON_ITEMS[optionId];\n        if (addonInfo.enabled(rawQuery)) {\n          item.element.lastChild.lastChild.textContent = getMenuItemMessage(optionId)[0];\n          return 0;\n        }\n        return -1;\n      }\n      const itemText = item.text.toLowerCase();\n      if (query === itemText) {\n        return 2;\n      }\n      if (itemText.startsWith(query)) {\n        return 1;\n      }\n      if (itemText.includes(query)) {\n        return 0;\n      }\n      return -1;\n    };\n    return items\n      .map((item, index) => ({\n        item,\n        score: rank(item, index),\n      }))\n      .sort(({ score: scoreA }, { score: scoreB }) => Math.max(0, scoreB) - Math.max(0, scoreA));\n  }\n\n  function updateSearch() {\n    const previousSearchedItems = searchedItems;\n    searchedItems = performSearch();\n    let needToUpdateDOM = previousSearchedItems.length !== searchedItems.length;\n    if (!needToUpdateDOM) {\n      for (let i = 0; i < searchedItems.length; i++) {\n        if (searchedItems[i].item !== previousSearchedItems[i].item) {\n          needToUpdateDOM = true;\n          break;\n        }\n      }\n    }\n    if (needToUpdateDOM && previousSearchedItems.length > 0) {\n      for (const { item } of previousSearchedItems) {\n        item.element.remove();\n      }\n      for (const { item } of searchedItems) {\n        blocklyDropdownMenu.appendChild(item.element);\n      }\n    }\n    for (const { item, score } of searchedItems) {\n      item.element.hidden = score < 0;\n    }\n  }\n\n  function handleKeyDownEvent(event) {\n    if (event.key === \"Enter\") {\n      // Reimplement enter to select item to account for hidden items and default to the top item.\n      event.stopPropagation();\n      event.preventDefault();\n\n      const selectedItem = document.querySelector(\".goog-menuitem-highlight\");\n      if (selectedItem && !selectedItem.hidden) {\n        selectItem(selectedItem, true);\n        return;\n      }\n\n      const selectedBlock = Blockly.selected;\n      if (searchBar.value === \"\" && selectedBlock) {\n        if (\n          selectedBlock.type === \"event_broadcast\" ||\n          selectedBlock.type === \"event_broadcastandwait\" ||\n          selectedBlock.type === \"event_whenbroadcastreceived\"\n        ) {\n          // The top item of these dropdowns is always \"New message\"\n          // When pressing enter on an empty search bar, we close the dropdown instead of making a new broadcast.\n          Blockly.DropDownDiv.hide();\n          return;\n        }\n      }\n      for (const { item } of searchedItems) {\n        if (!item.element.hidden) {\n          selectItem(item.element, true);\n          break;\n        }\n      }\n      // If there is no top value, do nothing and leave the dropdown open\n    } else if (event.key === \"Escape\") {\n      Blockly.DropDownDiv.hide();\n    } else if (event.key === \"ArrowDown\" || event.key === \"ArrowUp\") {\n      // Reimplement keyboard navigation to account for hidden items.\n      event.preventDefault();\n      event.stopPropagation();\n\n      const items = searchedItems.filter((i) => i.score >= 0).map((i) => i.item);\n      if (items.length === 0) {\n        return;\n      }\n\n      let selectedIndex = -1;\n      for (let i = 0; i < items.length; i++) {\n        if (items[i].element.classList.contains(\"goog-menuitem-highlight\")) {\n          selectedIndex = i;\n          break;\n        }\n      }\n\n      const lastIndex = items.length - 1;\n      let newIndex = 0;\n      if (event.key === \"ArrowDown\") {\n        if (selectedIndex === -1 || selectedIndex === lastIndex) {\n          newIndex = 0;\n        } else {\n          newIndex = selectedIndex + 1;\n        }\n      } else {\n        if (selectedIndex === -1 || selectedIndex === 0) {\n          newIndex = lastIndex;\n        } else {\n          newIndex = selectedIndex - 1;\n        }\n      }\n\n      selectItem(items[newIndex].element, false);\n    }\n  }\n\n  function getMenuItemMessage(message) {\n    // Format used internally by Scratch:\n    // [human readable name, internal name]\n    return [msg(message, { name: searchBar?.value.trim() || \"\" }), message];\n  }\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userstyle.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"userstyle.css\": _css,\n};\n","export default class BlockItem {\n  constructor(cls, procCode, labelID, y) {\n    this.cls = cls;\n    this.procCode = procCode;\n    this.labelID = labelID;\n    this.y = y;\n    this.lower = procCode.toLowerCase();\n    /**\n     * An Array of block ids\n     * @type {Array.<string>}\n     */\n    this.clones = null;\n    this.eventName = null;\n  }\n\n  /**\n   * True if the blockID matches a black represented by this BlockItem\n   * @param id\n   * @returns {boolean}\n   */\n  matchesID(id) {\n    if (this.labelID === id) {\n      return true;\n    }\n    if (this.clones) {\n      for (const cloneID of this.clones) {\n        if (cloneID === id) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n}\n","import BlockItem from \"./blockly/BlockItem.js\";\nimport BlockInstance from \"./blockly/BlockInstance.js\";\nimport Utils from \"./blockly/Utils.js\";\n\nexport default async function ({ addon, msg, console }) {\n  const Blockly = await addon.tab.traps.getBlockly();\n\n  class FindBar {\n    constructor() {\n      this.utils = new Utils(addon);\n\n      this.prevValue = \"\";\n\n      this.findBarOuter = null;\n      this.findWrapper = null;\n      this.findInput = null;\n      this.dropdownOut = null;\n      this.dropdown = new Dropdown(this.utils);\n\n      document.addEventListener(\"keydown\", (e) => this.eventKeyDown(e), true);\n    }\n\n    get workspace() {\n      return Blockly.getMainWorkspace();\n    }\n\n    createDom(root) {\n      this.findBarOuter = document.createElement(\"div\");\n      this.findBarOuter.className = \"sa-find-bar\";\n      addon.tab.displayNoneWhileDisabled(this.findBarOuter, { display: \"flex\" });\n      root.appendChild(this.findBarOuter);\n\n      this.findWrapper = this.findBarOuter.appendChild(document.createElement(\"span\"));\n      this.findWrapper.className = \"sa-find-wrapper\";\n\n      this.dropdownOut = this.findWrapper.appendChild(document.createElement(\"label\"));\n      this.dropdownOut.className = \"sa-find-dropdown-out\";\n\n      this.findInput = this.dropdownOut.appendChild(document.createElement(\"input\"));\n      this.findInput.className = addon.tab.scratchClass(\"input_input-form\", {\n        others: \"sa-find-input\",\n      });\n      // for <label>\n      this.findInput.id = \"sa-find-input\";\n      this.findInput.type = \"search\";\n      this.findInput.placeholder = msg(\"find-placeholder\");\n      this.findInput.autocomplete = \"off\";\n\n      this.dropdownOut.appendChild(this.dropdown.createDom());\n\n      this.bindEvents();\n      this.tabChanged();\n    }\n\n    bindEvents() {\n      this.findInput.addEventListener(\"focus\", () => this.inputChange());\n      this.findInput.addEventListener(\"keydown\", (e) => this.inputKeyDown(e));\n      this.findInput.addEventListener(\"keyup\", () => this.inputChange());\n      this.findInput.addEventListener(\"focusout\", () => this.hideDropDown());\n    }\n\n    tabChanged() {\n      if (!this.findBarOuter) {\n        return;\n      }\n      const tab = addon.tab.redux.state.scratchGui.editorTab.activeTabIndex;\n      const visible = tab === 0 || tab === 1 || tab === 2;\n      this.findBarOuter.hidden = !visible;\n    }\n\n    inputChange() {\n      this.showDropDown();\n\n      // Filter the list...\n      let val = (this.findInput.value || \"\").toLowerCase();\n      if (val === this.prevValue) {\n        // No change so don't re-filter\n        return;\n      }\n      this.prevValue = val;\n\n      this.dropdown.blocks = null;\n\n      // Hide items in list that do not contain filter text\n      let listLI = this.dropdown.items;\n      for (const li of listLI) {\n        let procCode = li.data.procCode;\n        let i = li.data.lower.indexOf(val);\n        if (i >= 0) {\n          li.style.display = \"block\";\n          while (li.firstChild) {\n            li.removeChild(li.firstChild);\n          }\n          if (i > 0) {\n            li.appendChild(document.createTextNode(procCode.substring(0, i)));\n          }\n          let bText = document.createElement(\"b\");\n          bText.appendChild(document.createTextNode(procCode.substr(i, val.length)));\n          li.appendChild(bText);\n          if (i + val.length < procCode.length) {\n            li.appendChild(document.createTextNode(procCode.substr(i + val.length)));\n          }\n        } else {\n          li.style.display = \"none\";\n        }\n      }\n    }\n\n    inputKeyDown(e) {\n      this.dropdown.inputKeyDown(e);\n\n      // Enter\n      if (e.key === \"Enter\") {\n        this.findInput.blur();\n        return;\n      }\n\n      // Escape\n      if (e.key === \"Escape\") {\n        if (this.findInput.value.length > 0) {\n          this.findInput.value = \"\"; // Clear search first, then close on second press\n          this.inputChange();\n        } else {\n          this.findInput.blur();\n        }\n        e.preventDefault();\n        return;\n      }\n    }\n\n    eventKeyDown(e) {\n      if (addon.self.disabled || !this.findBarOuter) return;\n\n      let ctrlKey = e.ctrlKey || e.metaKey;\n\n      if (e.key.toLowerCase() === \"f\" && ctrlKey && !e.shiftKey) {\n        // Ctrl + F (Override default Ctrl+F find)\n        this.findInput.focus();\n        this.findInput.select();\n        e.cancelBubble = true;\n        e.preventDefault();\n        return true;\n      }\n\n      if (e.key === \"ArrowLeft\" && ctrlKey) {\n        // Ctrl + Left Arrow Key\n        if (document.activeElement.tagName === \"INPUT\") {\n          return;\n        }\n\n        if (this.selectedTab === 0) {\n          this.utils.navigationHistory.goBack();\n          e.cancelBubble = true;\n          e.preventDefault();\n          return true;\n        }\n      }\n\n      if (e.key === \"ArrowRight\" && ctrlKey) {\n        // Ctrl + Right Arrow Key\n        if (document.activeElement.tagName === \"INPUT\") {\n          return;\n        }\n\n        if (this.selectedTab === 0) {\n          this.utils.navigationHistory.goForward();\n          e.cancelBubble = true;\n          e.preventDefault();\n          return true;\n        }\n      }\n    }\n\n    showDropDown(focusID, instanceBlock) {\n      if (!focusID && this.dropdownOut.classList.contains(\"visible\")) {\n        return;\n      }\n\n      // special '' vs null... - null forces a reevaluation\n      this.prevValue = focusID ? \"\" : null; // Clear the previous value of the input search\n\n      this.dropdownOut.classList.add(\"visible\");\n      let scratchBlocks =\n        this.selectedTab === 0\n          ? this.getScratchBlocks()\n          : this.selectedTab === 1\n            ? this.getScratchCostumes()\n            : this.selectedTab === 2\n              ? this.getScratchSounds()\n              : [];\n\n      this.dropdown.empty();\n\n      for (const proc of scratchBlocks) {\n        let item = this.dropdown.addItem(proc);\n\n        if (focusID) {\n          if (proc.matchesID(focusID)) {\n            this.dropdown.onItemClick(item, instanceBlock);\n          } else {\n            item.style.display = \"none\";\n          }\n        }\n      }\n\n      this.utils.offsetX = this.dropdownOut.getBoundingClientRect().width + 32;\n      this.utils.offsetY = 32;\n    }\n\n    hideDropDown() {\n      this.dropdownOut.classList.remove(\"visible\");\n    }\n\n    get selectedTab() {\n      return addon.tab.redux.state.scratchGui.editorTab.activeTabIndex;\n    }\n\n    getScratchBlocks() {\n      let myBlocks = [];\n      let myBlocksByProcCode = {};\n\n      let topBlocks = this.workspace.getTopBlocks();\n\n      /**\n       * @param cls\n       * @param txt\n       * @param root\n       * @returns BlockItem\n       */\n      function addBlock(cls, txt, root) {\n        let id = root.id ? root.id : root.getId ? root.getId() : null;\n        let clone = myBlocksByProcCode[txt];\n        if (clone) {\n          if (!clone.clones) {\n            clone.clones = [];\n          }\n          clone.clones.push(id);\n          return clone;\n        }\n        let items = new BlockItem(cls, txt, id, 0);\n        items.y = root.getRelativeToSurfaceXY ? root.getRelativeToSurfaceXY().y : null;\n        myBlocks.push(items);\n        myBlocksByProcCode[txt] = items;\n        return items;\n      }\n\n      function getDescFromField(root) {\n        let fields = root.inputList[0];\n        let desc;\n        for (const fieldRow of fields.fieldRow) {\n          desc = desc ? desc + \" \" : \"\";\n          if (fieldRow instanceof Blockly.FieldImage && fieldRow.src_.endsWith(\"green-flag.svg\")) {\n            desc += msg(\"/_general/blocks/green-flag\");\n          } else {\n            desc += fieldRow.getText();\n          }\n        }\n        return desc;\n      }\n\n      for (const root of topBlocks) {\n        if (root.type === \"procedures_definition\") {\n          const label = root.getChildren()[0];\n          const procCode = label.getProcCode();\n          if (!procCode) {\n            continue;\n          }\n          const indexOfLabel = root.inputList.findIndex((i) => i.fieldRow.length > 0);\n          if (indexOfLabel === -1) {\n            continue;\n          }\n          const translatedDefine = root.inputList[indexOfLabel].fieldRow[0].getText();\n          const message = indexOfLabel === 0 ? `${translatedDefine} ${procCode}` : `${procCode} ${translatedDefine}`;\n          addBlock(\"define\", message, root);\n          continue;\n        }\n\n        if (root.type === \"event_whenflagclicked\") {\n          addBlock(\"flag\", getDescFromField(root), root); // \"When Flag Clicked\"\n          continue;\n        }\n\n        if (root.type === \"event_whenbroadcastreceived\") {\n          const fieldRow = root.inputList[0].fieldRow;\n          let eventName = fieldRow.find((input) => input.name === \"BROADCAST_OPTION\").getText();\n          addBlock(\"receive\", msg(\"event\", { name: eventName }), root).eventName = eventName;\n\n          continue;\n        }\n\n        if (root.type.substr(0, 10) === \"event_when\") {\n          addBlock(\"event\", getDescFromField(root), root); // \"When Flag Clicked\"\n          continue;\n        }\n\n        if (root.type === \"control_start_as_clone\") {\n          addBlock(\"event\", getDescFromField(root), root); // \"when I start as a clone\"\n          continue;\n        }\n      }\n\n      let map = this.workspace.getVariableMap();\n\n      let vars = map.getVariablesOfType(\"\");\n      for (const row of vars) {\n        addBlock(\n          row.isLocal ? \"var\" : \"VAR\",\n          row.isLocal ? msg(\"var-local\", { name: row.name }) : msg(\"var-global\", { name: row.name }),\n          row\n        );\n      }\n\n      let lists = map.getVariablesOfType(\"list\");\n      for (const row of lists) {\n        addBlock(\n          row.isLocal ? \"list\" : \"LIST\",\n          row.isLocal ? msg(\"list-local\", { name: row.name }) : msg(\"list-global\", { name: row.name }),\n          row\n        );\n      }\n\n      const events = this.getCallsToEvents();\n      for (const event of events) {\n        addBlock(\"receive\", msg(\"event\", { name: event.eventName }), event.block).eventName = event.eventName;\n      }\n\n      const clsOrder = { flag: 0, receive: 1, event: 2, define: 3, var: 4, VAR: 5, list: 6, LIST: 7 };\n\n      myBlocks.sort((a, b) => {\n        let t = clsOrder[a.cls] - clsOrder[b.cls];\n        if (t !== 0) {\n          return t;\n        }\n        if (a.lower < b.lower) {\n          return -1;\n        }\n        if (a.lower > b.lower) {\n          return 1;\n        }\n        return a.y - b.y;\n      });\n\n      return myBlocks;\n    }\n\n    getScratchCostumes() {\n      let costumes = this.utils.getEditingTarget().getCostumes();\n\n      let items = [];\n\n      let i = 0;\n      for (const costume of costumes) {\n        let item = new BlockItem(\"costume\", costume.name, costume.assetId, i);\n        items.push(item);\n        i++;\n      }\n\n      return items;\n    }\n\n    getScratchSounds() {\n      let sounds = this.utils.getEditingTarget().getSounds();\n\n      let items = [];\n\n      let i = 0;\n      for (const sound of sounds) {\n        let item = new BlockItem(\"sound\", sound.name, sound.assetId, i);\n        items.push(item);\n        i++;\n      }\n\n      return items;\n    }\n\n    getCallsToEvents() {\n      const uses = [];\n      const alreadyFound = new Set();\n\n      for (const block of this.workspace.getAllBlocks()) {\n        if (block.type !== \"event_broadcast\" && block.type !== \"event_broadcastandwait\") {\n          continue;\n        }\n\n        const broadcastInput = block.getChildren()[0];\n        if (!broadcastInput) {\n          continue;\n        }\n\n        let eventName = \"\";\n        if (broadcastInput.type === \"event_broadcast_menu\") {\n          eventName = broadcastInput.inputList[0].fieldRow[0].getText();\n        } else {\n          eventName = msg(\"complex-broadcast\");\n        }\n        if (!alreadyFound.has(eventName)) {\n          alreadyFound.add(eventName);\n          uses.push({ eventName: eventName, block: block });\n        }\n      }\n\n      return uses;\n    }\n  }\n\n  class Dropdown {\n    constructor(utils) {\n      this.utils = utils;\n\n      this.el = null;\n      this.items = [];\n      this.selected = null;\n      this.carousel = new Carousel(this.utils);\n    }\n\n    get workspace() {\n      return Blockly.getMainWorkspace();\n    }\n\n    createDom() {\n      this.el = document.createElement(\"ul\");\n      this.el.className = \"sa-find-dropdown\";\n      return this.el;\n    }\n\n    inputKeyDown(e) {\n      // Up Arrow\n      if (e.key === \"ArrowUp\") {\n        this.navigateFilter(-1);\n        e.preventDefault();\n        return;\n      }\n\n      // Down Arrow\n      if (e.key === \"ArrowDown\") {\n        this.navigateFilter(1);\n        e.preventDefault();\n        return;\n      }\n\n      // Enter\n      if (e.key === \"Enter\") {\n        // Any selected on enter? if not select now\n        if (this.selected) {\n          this.navigateFilter(1);\n        }\n        e.preventDefault();\n        return;\n      }\n\n      this.carousel.inputKeyDown(e);\n    }\n\n    navigateFilter(dir) {\n      let nxt;\n      if (this.selected && this.selected.style.display !== \"none\") {\n        nxt = dir === -1 ? this.selected.previousSibling : this.selected.nextSibling;\n      } else {\n        nxt = this.items[0];\n        dir = 1;\n      }\n      while (nxt && nxt.style.display === \"none\") {\n        nxt = dir === -1 ? nxt.previousSibling : nxt.nextSibling;\n      }\n      if (nxt) {\n        nxt.scrollIntoView({ block: \"nearest\" });\n        this.onItemClick(nxt);\n      }\n    }\n\n    addItem(proc) {\n      const item = document.createElement(\"li\");\n      item.innerText = proc.procCode;\n      item.data = proc;\n      const colorIds = {\n        receive: \"events\",\n        event: \"events\",\n        define: \"more\",\n        var: \"data\",\n        VAR: \"data\",\n        list: \"data-lists\",\n        LIST: \"data-lists\",\n        costume: \"looks\",\n        sound: \"sounds\",\n      };\n      if (proc.cls === \"flag\") {\n        item.className = \"sa-find-flag\";\n      } else {\n        const colorId = colorIds[proc.cls];\n        item.className = `sa-block-color sa-block-color-${colorId}`;\n      }\n      item.addEventListener(\"mousedown\", (e) => {\n        this.onItemClick(item);\n        e.preventDefault();\n        e.cancelBubble = true;\n        return false;\n      });\n      this.items.push(item);\n      this.el.appendChild(item);\n      return item;\n    }\n\n    onItemClick(item, instanceBlock) {\n      if (this.selected && this.selected !== item) {\n        this.selected.classList.remove(\"sel\");\n        this.selected = null;\n      }\n      if (this.selected !== item) {\n        item.classList.add(\"sel\");\n        this.selected = item;\n      }\n\n      let cls = item.data.cls;\n      if (cls === \"costume\" || cls === \"sound\") {\n        // Viewing costumes/sounds - jump to selected costume/sound\n        const assetPanel = document.querySelector(\"[class^=asset-panel_wrapper]\");\n        if (assetPanel) {\n          const reactInstance = assetPanel[addon.tab.traps.getInternalKey(assetPanel)];\n          const reactProps = reactInstance.child.stateNode.props;\n          reactProps.onItemClick(item.data.y);\n          const selectorList = assetPanel.firstChild.firstChild;\n          selectorList.children[item.data.y].scrollIntoView({\n            behavior: \"auto\",\n            block: \"center\",\n            inline: \"start\",\n          });\n          // The wrapper seems to scroll when we use the function above.\n          let wrapper = assetPanel.closest(\"div[class*=gui_flex-wrapper]\");\n          wrapper.scrollTop = 0;\n        }\n      } else if (cls === \"var\" || cls === \"VAR\" || cls === \"list\" || cls === \"LIST\") {\n        // Search now for all instances\n        let blocks = this.getVariableUsesById(item.data.labelID);\n        this.carousel.build(item, blocks, instanceBlock);\n      } else if (cls === \"define\") {\n        let blocks = this.getCallsToProcedureById(item.data.labelID);\n        this.carousel.build(item, blocks, instanceBlock);\n      } else if (cls === \"receive\") {\n        /*\n          let blocks = [this.workspace.getBlockById(li.data.labelID)];\n          if (li.data.clones) {\n              for (const cloneID of li.data.clones) {\n                  blocks.push(this.workspace.getBlockById(cloneID))\n              }\n          }\n          blocks = blocks.concat(getCallsToEventsByName(li.data.eventName));\n        */\n        // Now, fetch the events from the scratch runtime instead of blockly\n        let blocks = this.getCallsToEventsByName(item.data.eventName);\n        if (!instanceBlock) {\n          // Can we start by selecting the first block on 'this' sprite\n          const currentTargetID = this.utils.getEditingTarget().id;\n          for (const block of blocks) {\n            if (block.targetId === currentTargetID) {\n              instanceBlock = block;\n              break;\n            }\n          }\n        }\n        this.carousel.build(item, blocks, instanceBlock);\n      } else if (item.data.clones) {\n        let blocks = [this.workspace.getBlockById(item.data.labelID)];\n        for (const cloneID of item.data.clones) {\n          blocks.push(this.workspace.getBlockById(cloneID));\n        }\n        this.carousel.build(item, blocks, instanceBlock);\n      } else {\n        this.utils.scrollBlockIntoView(item.data.labelID);\n        this.carousel.remove();\n      }\n    }\n\n    getVariableUsesById(id) {\n      let uses = [];\n\n      let topBlocks = this.workspace.getTopBlocks();\n      for (const topBlock of topBlocks) {\n        /** @type {!Array<!Blockly.Block>} */\n        let kids = topBlock.getDescendants();\n        for (const block of kids) {\n          /** @type {!Array<!Blockly.VariableModel>} */\n          let blockVariables = block.getVarModels();\n          if (blockVariables) {\n            for (const blockVar of blockVariables) {\n              if (blockVar.getId() === id) {\n                uses.push(block);\n              }\n            }\n          }\n        }\n      }\n\n      return uses;\n    }\n\n    getCallsToProcedureById(id) {\n      let procBlock = this.workspace.getBlockById(id);\n      let label = procBlock.getChildren()[0];\n      let procCode = label.getProcCode();\n\n      let uses = [procBlock]; // Definition First, then calls to it\n      let topBlocks = this.workspace.getTopBlocks();\n      for (const topBlock of topBlocks) {\n        /** @type {!Array<!Blockly.Block>} */\n        let kids = topBlock.getDescendants();\n        for (const block of kids) {\n          if (block.type === \"procedures_call\") {\n            if (block.getProcCode() === procCode) {\n              uses.push(block);\n            }\n          }\n        }\n      }\n\n      return uses;\n    }\n\n    getCallsToEventsByName(name) {\n      let uses = []; // Definition First, then calls to it\n\n      const runtime = addon.tab.traps.vm.runtime;\n      const targets = runtime.targets; // The sprites / stage\n\n      for (const target of targets) {\n        if (!target.isOriginal) {\n          continue; // Skip clones\n        }\n\n        const blocks = target.blocks;\n        if (!blocks._blocks) {\n          continue;\n        }\n\n        for (const id of Object.keys(blocks._blocks)) {\n          const block = blocks._blocks[id];\n          if (block.opcode === \"event_whenbroadcastreceived\" && block.fields.BROADCAST_OPTION.value === name) {\n            uses.push(new BlockInstance(target, block));\n          } else if (block.opcode === \"event_broadcast\" || block.opcode === \"event_broadcastandwait\") {\n            const broadcastInputBlockId = block.inputs.BROADCAST_INPUT.block;\n            const broadcastInputBlock = blocks._blocks[broadcastInputBlockId];\n            if (broadcastInputBlock) {\n              let eventName;\n              if (broadcastInputBlock.opcode === \"event_broadcast_menu\") {\n                eventName = broadcastInputBlock.fields.BROADCAST_OPTION.value;\n              } else {\n                eventName = msg(\"complex-broadcast\");\n              }\n              if (eventName === name) {\n                uses.push(new BlockInstance(target, block));\n              }\n            }\n          }\n        }\n      }\n\n      return uses;\n    }\n\n    empty() {\n      for (const item of this.items) {\n        if (this.el.contains(item)) {\n          this.el.removeChild(item);\n        }\n      }\n      this.items = [];\n      this.selected = null;\n    }\n  }\n\n  class Carousel {\n    constructor(utils) {\n      this.utils = utils;\n\n      this.el = null;\n      this.count = null;\n      this.blocks = [];\n      this.idx = 0;\n    }\n\n    build(item, blocks, instanceBlock) {\n      if (this.el && this.el.parentNode === item) {\n        // Same control... click again to go to next\n        this.navRight();\n      } else {\n        this.remove();\n        this.blocks = blocks;\n        item.appendChild(this.createDom());\n\n        this.idx = 0;\n        if (instanceBlock) {\n          for (const idx of Object.keys(this.blocks)) {\n            const block = this.blocks[idx];\n            if (block.id === instanceBlock.id) {\n              this.idx = Number(idx);\n              break;\n            }\n          }\n        }\n\n        if (this.idx < this.blocks.length) {\n          this.utils.scrollBlockIntoView(this.blocks[this.idx]);\n        }\n      }\n    }\n\n    createDom() {\n      this.el = document.createElement(\"span\");\n      this.el.className = \"sa-find-carousel\";\n\n      const leftControl = this.el.appendChild(document.createElement(\"span\"));\n      leftControl.className = \"sa-find-carousel-control\";\n      leftControl.textContent = \"â—€\";\n      leftControl.addEventListener(\"mousedown\", (e) => this.navLeft(e));\n\n      this.count = this.el.appendChild(document.createElement(\"span\"));\n      this.count.innerText = this.blocks.length > 0 ? this.idx + 1 + \" / \" + this.blocks.length : \"0\";\n\n      const rightControl = this.el.appendChild(document.createElement(\"span\"));\n      rightControl.className = \"sa-find-carousel-control\";\n      rightControl.textContent = \"â–¶\";\n      rightControl.addEventListener(\"mousedown\", (e) => this.navRight(e));\n\n      return this.el;\n    }\n\n    inputKeyDown(e) {\n      // Left Arrow\n      if (e.key === \"ArrowLeft\") {\n        if (this.el && this.blocks) {\n          this.navLeft(e);\n        }\n      }\n\n      // Right Arrow\n      if (e.key === \"ArrowRight\") {\n        if (this.el && this.blocks) {\n          this.navRight(e);\n        }\n      }\n    }\n\n    navLeft(e) {\n      return this.navSideways(e, -1);\n    }\n\n    navRight(e) {\n      return this.navSideways(e, 1);\n    }\n\n    navSideways(e, dir) {\n      if (this.blocks.length > 0) {\n        this.idx = (this.idx + dir + this.blocks.length) % this.blocks.length; // + length to fix negative modulo js issue.\n        this.count.innerText = this.idx + 1 + \" / \" + this.blocks.length;\n        this.utils.scrollBlockIntoView(this.blocks[this.idx]);\n      }\n\n      if (e) {\n        e.cancelBubble = true;\n        e.preventDefault();\n      }\n    }\n\n    remove() {\n      if (this.el) {\n        this.el.remove();\n        this.blocks = [];\n        this.idx = 0;\n      }\n    }\n  }\n\n  const findBar = new FindBar();\n\n  const _doBlockClick_ = Blockly.Gesture.prototype.doBlockClick_;\n  Blockly.Gesture.prototype.doBlockClick_ = function () {\n    if (!addon.self.disabled && (this.mostRecentEvent_.button === 1 || this.mostRecentEvent_.shiftKey)) {\n      // Wheel button...\n      // Intercept clicks to allow jump to...?\n      let block = this.startBlock_;\n      for (; block; block = block.getSurroundParent()) {\n        if (block.type === \"procedures_definition\" || (!this.jumpToDef && block.type === \"procedures_call\")) {\n          let id = block.id ? block.id : block.getId ? block.getId() : null;\n\n          findBar.findInput.focus();\n          findBar.showDropDown(id);\n\n          return;\n        }\n\n        if (\n          block.type === \"data_variable\" ||\n          block.type === \"data_changevariableby\" ||\n          block.type === \"data_setvariableto\"\n        ) {\n          let id = block.getVars()[0];\n\n          findBar.findInput.focus();\n          findBar.showDropDown(id, block);\n\n          findBar.selVarID = id;\n\n          return;\n        }\n\n        if (\n          block.type === \"event_whenbroadcastreceived\" ||\n          block.type === \"event_broadcastandwait\" ||\n          block.type === \"event_broadcast\"\n        ) {\n          // todo: actually index the broadcasts...!\n          let id = block.id;\n\n          findBar.findInput.focus();\n          findBar.showDropDown(id, block);\n\n          findBar.selVarID = id;\n\n          return;\n        }\n      }\n    }\n\n    _doBlockClick_.call(this);\n  };\n\n  addon.tab.redux.initialize();\n  addon.tab.redux.addEventListener(\"statechanged\", (e) => {\n    if (e.detail.action.type === \"scratch-gui/navigation/ACTIVATE_TAB\") {\n      findBar.tabChanged();\n    }\n  });\n\n  while (true) {\n    const root = await addon.tab.waitForElement(\"ul[class*=gui_tab-list_]\", {\n      markAsSeen: true,\n      reduxEvents: [\"scratch-gui/mode/SET_PLAYER\", \"fontsLoaded/SET_FONTS_LOADED\", \"scratch-gui/locales/SELECT_LOCALE\"],\n      reduxCondition: (state) => !state.scratchGui.mode.isPlayerOnly,\n    });\n    findBar.createDom(root);\n  }\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./style.css\";\nimport _asset from \"!url-loader!./folder.svg\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"style.css\": _css,\n  \"folder.svg\": _asset,\n};\n","export default async function ({ addon, console, msg }) {\n  // The basic premise of how this addon works is relative simple.\n  // scratch-gui renders the sprite selectors and asset selectors in a hierarchy like this:\n  // <SelectorHOC>\n  //   <SpriteSelectorItem />\n  //   <SpriteSelectorItem />\n  //   <SpriteSelectorItem />\n  //   <SpriteSelectorItem />\n  //   ...\n  // </SelectorHOC>\n  // It's obviously more complicated than that, but there are two important parts:\n  // SelectorHOC - We override this to change which items are displayed\n  // SpriteSelectorItem - We override this to change how items are displayed.\n  //    Folders are just items rendered differently\n  // These two components communicate through the `name` property of the items.\n  // We touch some things on the VM to make dragging items work properly.\n\n  const REACT_INTERNAL_PREFIX = \"__reactInternalInstance$\";\n\n  const TYPE_SPRITES = 1;\n  const TYPE_ASSETS = 2;\n\n  // We run too early, will be set later\n  let vm;\n\n  let reactInternalKey;\n\n  let currentSpriteFolder;\n  let currentAssetFolder;\n\n  let currentSpriteItems;\n  let currentAssetItems;\n\n  const DIVIDER = \"//\";\n\n  /**\n   * getFolderFromName(\"B\") === null\n   * getFolderFromName(\"A//b\") === \"A\"\n   */\n  const getFolderFromName = (name) => {\n    const idx = name.indexOf(DIVIDER);\n    if (idx === -1 || idx === 0) {\n      return null;\n    }\n    return name.substr(0, idx);\n  };\n\n  /**\n   * getNameWithoutFolder(\"B\") === \"B\"\n   * getNameWithoutFolder(\"A//b\") === \"b\"\n   */\n  const getNameWithoutFolder = (name) => {\n    const idx = name.indexOf(DIVIDER);\n    if (idx === -1 || idx === 0) {\n      return name;\n    }\n    return name.substr(idx + DIVIDER.length);\n  };\n\n  /**\n   * setFolderOfName(\"B\", \"y\") === \"y//B\"\n   * setFolderOfName(\"c//B\", \"y\") === \"y//B\"\n   * setFolderOfName(\"B\", null) === \"B\"\n   * setFolderOfName(\"c//B\", null) === \"B\"\n   */\n  const setFolderOfName = (name, folder) => {\n    const basename = getNameWithoutFolder(name);\n    if (folder) {\n      return `${folder}${DIVIDER}${basename}`;\n    }\n    return basename;\n  };\n\n  const isValidFolderName = (name) => {\n    return !name.includes(DIVIDER) && !name.endsWith(\"/\");\n  };\n\n  const RESERVED_NAMES = [\"_mouse_\", \"_stage_\", \"_edge_\", \"_myself_\", \"_random_\"];\n  const ensureNotReserved = (name) => {\n    if (name === \"\") return \"2\";\n    if (RESERVED_NAMES.includes(name)) return `${name}2`;\n    return name;\n  };\n\n  const getSortableHOCFromElement = (el) => {\n    const nearestSpriteSelector = el.closest(\"[class*='sprite-selector_sprite-selector']\");\n    if (nearestSpriteSelector) {\n      return nearestSpriteSelector[reactInternalKey].child.sibling.child.stateNode;\n    }\n    const nearestAssetPanelWrapper = el.closest('[class*=\"asset-panel_wrapper\"]');\n    if (nearestAssetPanelWrapper) {\n      return nearestAssetPanelWrapper[reactInternalKey].child.child.stateNode;\n    }\n    throw new Error(\"cannot find SortableHOC\");\n  };\n\n  const getBackpackFromElement = (el) => {\n    const gui = el.closest('[class*=\"gui_editor-wrapper\"]');\n    if (!gui) throw new Error(\"cannot find Backpack\");\n    return gui[reactInternalKey].child.sibling.child.child.stateNode;\n  };\n\n  const clamp = (n, min, max) => {\n    return Math.min(Math.max(n, min), max);\n  };\n\n  /**\n   * @typedef {Object} ItemData\n   * @property {string} realName\n   * @property {number} realIndex\n   * @property {string} inFolder\n   * @property {string} folder\n   * @property {boolean} folderOpen\n   */\n\n  /**\n   * @returns {ItemData|null}\n   */\n  const getItemData = (item) => {\n    if (item && item.name && typeof item.name === \"object\") {\n      return item.name;\n    }\n    return null;\n  };\n\n  const openFolderAsset = {\n    assetId: \"&__sa_folders_folder\",\n    encodeDataURI() {\n      // Doesn't actually need to be a data: URI\n      return addon.self.getResource(\"/folder.svg\") /* rewritten by pull.js */;\n    },\n  };\n\n  // https://github.com/scratchfoundation/scratch-gui/blob/develop/src/components/asset-panel/icon--sound.svg\n  const imageIconSource = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<svg width=\"100px\" height=\"100px\" viewBox=\"0 0 20 20\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n    <g id=\"Sound\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\">\n        <path d=\"M12.4785058,12.6666667 C12.3144947,12.6666667 12.1458852,12.6272044 11.9926038,12.5440517 C11.537358,12.2960031 11.3856094,11.7562156 11.6553847,11.3376335 C12.1688774,10.5371131 12.1688774,9.54491867 11.6553847,8.74580756 C11.3856094,8.32581618 11.537358,7.78602861 11.9926038,7.53798001 C12.452448,7.29275014 13.0379829,7.43086811 13.3046926,7.84804076 C14.1737981,9.20103311 14.1737981,10.8809986 13.3046926,12.233991 C13.1268862,12.5130457 12.806528,12.6666667 12.4785058,12.6666667 Z M15.3806784,13.8333333 C15.2408902,13.8333333 15.0958763,13.796281 14.9665396,13.7182064 C14.5785295,13.485306 14.4491928,12.9784829 14.6791247,12.5854634 C15.5949331,11.0160321 15.5949331,9.065491 14.6791247,7.49738299 C14.4491928,7.10436352 14.5785295,6.59621712 14.9665396,6.36331669 C15.3558562,6.13438616 15.8549129,6.26274605 16.0848448,6.65444223 C17.3050517,8.74260632 17.3050517,11.3389168 16.0848448,13.4270809 C15.9319924,13.6890939 15.6602547,13.8333333 15.3806784,13.8333333 Z M10.3043478,5.62501557 L10.3043478,13.873675 C10.3043478,14.850934 9.10969849,15.3625101 8.36478311,14.7038052 L6.7566013,13.2797607 C6.18712394,12.7762834 5.44499329,12.4968737 4.67362297,12.4968737 L4.3923652,12.4968737 C3.62377961,12.4968737 3,11.8935108 3,11.1470686 L3,8.36646989 C3,7.62137743 3.62377961,7.01666471 4.3923652,7.01666471 L4.65830695,7.01666471 C5.42967727,7.01666471 6.17180792,6.73725504 6.74128529,6.23377771 L8.36478311,4.79623519 C9.10969849,4.13753026 10.3043478,4.64910643 10.3043478,5.62501557 Z\" id=\"Combined-Shape\" fill=\"#575E75\"></path>\n    </g>\n</svg>`;\n  const soundIconHref = `data:image/svg+xml;base64,${btoa(imageIconSource)}`;\n\n  let folderColorStylesheet = null;\n  const folderColors = Object.create(null);\n  const getFolderColorClass = (folderName) => {\n    const mulberry32 = (a) => {\n      // https://stackoverflow.com/a/47593316\n      return function () {\n        var t = (a += 0x6d2b79f5);\n        t = Math.imul(t ^ (t >>> 15), t | 1);\n        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n      };\n    };\n\n    const hashCode = (str) => {\n      // Based on Java's String.hashCode\n      // https://hg.openjdk.java.net/jdk8/jdk8/jdk/file/687fd7c7986d/src/share/classes/java/lang/String.java#l1452\n      let hash = 0;\n      for (let i = 0; i < str.length; i++) {\n        hash = 31 * hash + str.charCodeAt(i);\n        hash = hash | 0;\n      }\n      return hash;\n    };\n\n    const random = (str) => {\n      const seed = hashCode(str);\n      const rng = mulberry32(seed);\n      // Run RNG a few times to get more random numbers, otherwise similar seeds tend to give somewhat similar results\n      rng();\n      rng();\n      rng();\n      rng();\n      return rng();\n    };\n\n    if (!folderColors[folderName]) {\n      if (!folderColorStylesheet) {\n        folderColorStylesheet = document.createElement(\"style\");\n        document.head.appendChild(folderColorStylesheet);\n      }\n      const hue = random(folderName) * 360;\n      const color = `hsla(${hue}deg, 100%, 85%, 0.5)`;\n      const id = Object.keys(folderColors).length;\n      const className = `sa-folders-color-${id}`;\n      folderColors[folderName] = className;\n      folderColorStylesheet.textContent += `.${className}{background-color:${color} !important;}`;\n      folderColorStylesheet.textContent += `.${className}[class*=\"sprite-selector_raised\"]:not([class*=\"sa-folders-folder\"]){background-color:hsla(${hue}deg, 100%, 77%, 1) !important;}`;\n    }\n    return folderColors[folderName];\n  };\n\n  const fixOrderOfItemsInFolders = (items) => {\n    const folders = Object.create(null);\n    const result = [];\n    for (const item of items) {\n      const name = item.getName ? item.getName() : item.name;\n      const folder = getFolderFromName(name);\n      if (typeof folder === \"string\") {\n        if (!folders[folder]) {\n          folders[folder] = [];\n          result.push(folders[folder]);\n        }\n        folders[folder].push(item);\n      } else {\n        result.push(item);\n      }\n    }\n    const flatResult = result.flat();\n    for (let i = 0; i < items.length; i++) {\n      if (result[i] !== items[i]) {\n        return { items: flatResult, changed: true };\n      }\n    }\n    return { items: flatResult, changed: false };\n  };\n\n  const fixTargetOrder = () => {\n    const { items, changed } = fixOrderOfItemsInFolders(vm.runtime.targets);\n    if (changed) {\n      vm.runtime.targets = items;\n      vm.emitTargetsUpdate();\n    }\n  };\n\n  const fixCostumeOrder = (target = vm.editingTarget) => {\n    const { items, changed } = fixOrderOfItemsInFolders(target.sprite.costumes);\n    if (changed) {\n      target.sprite.costumes = items;\n      vm.emitTargetsUpdate();\n    }\n  };\n\n  const fixSoundOrder = (target = vm.editingTarget) => {\n    const { items, changed } = fixOrderOfItemsInFolders(target.sprite.sounds);\n    if (changed) {\n      target.sprite.sounds = items;\n      vm.emitTargetsUpdate();\n    }\n  };\n\n  const verifySortableHOC = (sortableHOCInstance) => {\n    const SortableHOC = sortableHOCInstance.constructor;\n    if (\n      Array.isArray(sortableHOCInstance.props.items) &&\n      (typeof sortableHOCInstance.props.selectedId === \"string\" ||\n        typeof sortableHOCInstance.props.selectedItemIndex === \"number\") &&\n      typeof sortableHOCInstance.containerBox !== \"undefined\" &&\n      typeof SortableHOC.prototype.componentDidMount === \"undefined\" &&\n      typeof SortableHOC.prototype.componentDidUpdate === \"undefined\" &&\n      typeof SortableHOC.prototype.handleAddSortable === \"function\" &&\n      typeof SortableHOC.prototype.handleRemoveSortable === \"function\" &&\n      typeof SortableHOC.prototype.setRef === \"function\"\n    )\n      return;\n    throw new Error(\"Can not comprehend SortableHOC\");\n  };\n\n  const verifySpriteSelectorItem = (spriteSelectorItemInstance) => {\n    const SpriteSelectorItem = spriteSelectorItemInstance.constructor;\n    if (\n      typeof spriteSelectorItemInstance.props.asset === \"object\" &&\n      typeof spriteSelectorItemInstance.props.name === \"string\" &&\n      typeof spriteSelectorItemInstance.props.dragType === \"string\" &&\n      typeof SpriteSelectorItem.prototype.handleClick === \"function\" &&\n      typeof SpriteSelectorItem.prototype.setRef === \"function\" &&\n      typeof SpriteSelectorItem.prototype.handleDrag === \"function\" &&\n      typeof SpriteSelectorItem.prototype.handleDragEnd === \"function\" &&\n      typeof SpriteSelectorItem.prototype.handleDelete === \"function\" &&\n      typeof SpriteSelectorItem.prototype.handleDuplicate === \"function\" &&\n      typeof SpriteSelectorItem.prototype.handleExport === \"function\"\n    )\n      return;\n    throw new Error(\"Can not comprehend SpriteSelectorItem\");\n  };\n\n  const verifyVM = (vm) => {\n    const target = vm.runtime.targets[0];\n    if (\n      typeof vm.installTargets === \"function\" &&\n      typeof vm.reorderTarget === \"function\" &&\n      typeof target.reorderCostume === \"function\" &&\n      typeof target.reorderSound === \"function\" &&\n      typeof target.addCostume === \"function\" &&\n      typeof target.addSound === \"function\"\n    )\n      return;\n    throw new Error(\"Can not comprehend VM\");\n  };\n\n  const verifyBackpack = (backpackInstance) => {\n    const Backpack = backpackInstance.constructor;\n    if (\n      typeof Backpack.prototype.handleDrop === \"function\" &&\n      typeof Backpack.prototype.componentDidUpdate === \"undefined\"\n    ) {\n      return;\n    }\n    throw new Error(\"Can not comprehend Backpack\");\n  };\n\n  class Cache {\n    constructor() {\n      this.cache = new Map();\n      this.usedThisTick = new Set();\n    }\n\n    has(id) {\n      return this.cache.has(id);\n    }\n\n    get(id) {\n      this.usedThisTick.add(id);\n      return this.cache.get(id);\n    }\n\n    set(id, value) {\n      this.usedThisTick.add(id);\n      this.cache.set(id, value);\n    }\n\n    startTick() {\n      this.usedThisTick.clear();\n    }\n\n    endTick() {\n      for (const id of Array.from(this.cache.keys())) {\n        if (!this.usedThisTick.has(id)) {\n          this.cache.delete(id);\n        }\n      }\n    }\n\n    clear() {\n      this.usedThisTick.clear();\n      this.cache.clear();\n    }\n  }\n\n  const patchSortableHOC = (SortableHOC, type) => {\n    // SortableHOC should be: https://github.com/scratchfoundation/scratch-gui/blob/29d9851778febe4e69fa5111bf7559160611e366/src/lib/sortable-hoc.jsx#L8\n\n    const itemCache = new Cache();\n    const folderItemCache = new Cache();\n    const folderAssetCache = new Cache();\n\n    const PREVIEW_SIZE = 80;\n    const PREVIEW_POSITIONS = [\n      // x, y\n      [0, 0],\n      [PREVIEW_SIZE / 2, 0],\n      [0, PREVIEW_SIZE / 2],\n      [PREVIEW_SIZE / 2, PREVIEW_SIZE / 2],\n    ];\n\n    const createFolderPreview = (items) => {\n      // Directly generate a string instead of using DOM API for performance as we deal with very large inlined images\n      // Because the result is only used as an img src, XSS shouldn't be a concern\n      let result = `data:image/svg+xml;,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"${PREVIEW_SIZE}\" height=\"${PREVIEW_SIZE}\">`;\n      for (let i = 0; i < Math.min(PREVIEW_POSITIONS.length, items.length); i++) {\n        const item = items[i];\n        const width = PREVIEW_SIZE / 2;\n        const height = PREVIEW_SIZE / 2;\n        const [x, y] = PREVIEW_POSITIONS[i];\n        let src;\n        if (item.asset) {\n          // TW: We can be 100% certain that escaping here is unnecessary\n          src = item.asset.encodeDataURI();\n        } else if (item.costume && item.costume.asset) {\n          src = item.costume.asset.encodeDataURI();\n        } else if (item.url) {\n          src = soundIconHref;\n        }\n        if (src) {\n          result += `<image width=\"${width}\" height=\"${height}\" x=\"${x}\" y=\"${y}\" href=\"${src}\"/>`;\n        }\n      }\n      result += \"</svg>\";\n      return result;\n    };\n\n    const getUniqueIdOfFolderItems = (items) => {\n      let id = \"sa_folder&&\";\n      for (let i = 0; i < Math.min(PREVIEW_POSITIONS.length, items.length); i++) {\n        const item = items[i];\n        if (item.asset) {\n          id += item.asset.assetId;\n        } else if (item.costume && item.costume.asset) {\n          id += item.costume.asset.assetId;\n        } else if (item.url) {\n          id += item.url;\n        }\n        id += \"&&\";\n      }\n      return id;\n    };\n\n    const processItems = (openFolders, props) => {\n      const processItem = (item) => {\n        const itemId = item.name;\n\n        let newItem;\n        let itemData;\n        if (itemCache.has(itemId)) {\n          newItem = itemCache.get(itemId);\n          itemData = newItem.name;\n        } else {\n          itemData = {\n            toString() {\n              return `_${item.name}`;\n            },\n          };\n          newItem = {};\n          itemCache.set(itemId, newItem);\n        }\n\n        const itemFolderName = getFolderFromName(item.name);\n\n        Object.assign(newItem, item);\n        itemData.realName = item.name;\n        itemData.realIndex = i;\n        itemData.inFolder = itemFolderName;\n        newItem.name = itemData;\n\n        return {\n          newItem,\n          itemData,\n        };\n      };\n\n      itemCache.startTick();\n      folderItemCache.startTick();\n      folderAssetCache.startTick();\n\n      const folderOccurrences = new Map();\n      const items = [];\n      const result = {\n        items,\n      };\n\n      let i = 0;\n      while (i < props.items.length) {\n        const item = props.items[i];\n        const folderName = getFolderFromName(item.name);\n\n        if (folderName === null) {\n          items.push(processItem(item).newItem);\n          if (type === TYPE_ASSETS) {\n            const isSelected = props.selectedItemIndex === i;\n            if (isSelected) {\n              result.selectedItemIndex = items.length - 1;\n            }\n          }\n        } else {\n          const isOpen = openFolders.indexOf(folderName) !== -1;\n          const folderItems = [];\n          while (i < props.items.length) {\n            const childItem = props.items[i];\n            const processedItem = processItem(childItem);\n            if (getFolderFromName(childItem.name) !== folderName) {\n              break;\n            }\n            folderItems.push(processedItem.newItem);\n            if (type === TYPE_ASSETS) {\n              const isSelected = props.selectedItemIndex === i;\n              if (isSelected) {\n                if (isOpen) {\n                  result.selectedItemIndex = items.length + folderItems.length;\n                } else {\n                  result.selectedItemIndex = -1;\n                }\n              }\n            }\n            i++;\n          }\n          i--;\n\n          const occurrence = folderOccurrences.get(folderName) || 0;\n          folderOccurrences.set(folderName, occurrence + 1);\n          const baseUniqueId = getUniqueIdOfFolderItems(folderItems);\n          const itemUniqueId = `${isOpen}&${occurrence}&${folderName}&${baseUniqueId}&`;\n          const reactKey = `&__${occurrence}_${folderName}`;\n          const assetUniqueId = baseUniqueId;\n\n          let folderItem;\n          let folderData;\n          if (folderItemCache.has(itemUniqueId)) {\n            folderItem = folderItemCache.get(itemUniqueId);\n            folderData = folderItem.name;\n          } else {\n            folderItem = {\n              // Can be used as a react key\n              id: {\n                toString() {\n                  return reactKey;\n                },\n              },\n            };\n            folderData = {\n              // Can be used as a react key\n              toString() {\n                return reactKey;\n              },\n            };\n            folderItemCache.set(itemUniqueId, folderItem);\n          }\n\n          folderData.folder = folderName;\n          folderData.folderOpen = isOpen;\n          folderItem.items = folderItems;\n          folderItem.name = folderData;\n\n          let folderAsset;\n          if (isOpen) {\n            folderAsset = openFolderAsset;\n          } else {\n            if (folderAssetCache.has(assetUniqueId)) {\n              folderAsset = folderAssetCache.get(assetUniqueId);\n            } else {\n              folderAsset = {\n                assetId: assetUniqueId,\n                encodeDataURI() {\n                  return createFolderPreview(folderItems);\n                },\n              };\n              folderAssetCache.set(assetUniqueId, folderAsset);\n            }\n          }\n\n          if (type === TYPE_SPRITES) {\n            if (!folderItem.costume) folderItem.costume = {};\n            folderItem.costume.asset = folderAsset;\n            // For sprite items, `id` is used as the drag payload and toString is used as a React key\n            if (!folderItem.id) folderItem.id = {};\n            folderItem.id.sa_folder_items = folderItems;\n            folderItem.id.toString = () => reactKey;\n          } else {\n            folderItem.asset = folderAsset;\n            if (!folderItem.dragPayload) folderItem.dragPayload = {};\n            folderItem.dragPayload.sa_folder_items = folderItems;\n          }\n\n          items.push(folderItem);\n          if (isOpen) {\n            for (const item of folderItems) {\n              items.push(item);\n            }\n          }\n        }\n\n        i++;\n      }\n\n      itemCache.endTick();\n      folderItemCache.endTick();\n      folderAssetCache.endTick();\n\n      return result;\n    };\n\n    const getSelectedItem = (sortable) => {\n      if (type === TYPE_SPRITES) {\n        const selectedItem = sortable.props.items.find((i) => i.id === sortable.props.selectedId);\n        return selectedItem;\n      } else if (type === TYPE_ASSETS) {\n        const selectedItem = sortable.props.items[sortable.props.selectedItemIndex];\n        return selectedItem;\n      }\n      return null;\n    };\n\n    SortableHOC.prototype.saInitialSetup = function () {\n      itemCache.clear();\n      folderItemCache.clear();\n      folderAssetCache.clear();\n      const folders = [];\n      const selectedItem = getSelectedItem(this);\n      if (selectedItem && !selectedItem.isStage) {\n        const folder = getFolderFromName(selectedItem.name);\n        folders.push(folder);\n        if (type === TYPE_SPRITES) {\n          currentSpriteFolder = folder;\n        } else if (type === TYPE_ASSETS) {\n          currentAssetFolder = folder;\n        }\n      }\n      this.setState({\n        folders,\n      });\n    };\n\n    SortableHOC.prototype.componentDidMount = function () {\n      // Do part of componentDidUpdate on mount as well\n      const selectedItem = getSelectedItem(this);\n      if (selectedItem) {\n        const folder = getFolderFromName(selectedItem.name);\n        if (type === TYPE_SPRITES) {\n          currentSpriteFolder = folder;\n        } else if (type === TYPE_ASSETS) {\n          currentAssetFolder = folder;\n        }\n      }\n      this.saInitialSetup();\n    };\n\n    SortableHOC.prototype.componentDidUpdate = function (prevProps, prevState) {\n      const selectedItem = getSelectedItem(this);\n      if (selectedItem) {\n        const folder = getFolderFromName(selectedItem.name);\n        const currentFolder = this.state.folders.includes(folder) ? folder : null;\n        if (type === TYPE_SPRITES) {\n          currentSpriteFolder = currentFolder;\n        } else if (type === TYPE_ASSETS) {\n          currentAssetFolder = currentFolder;\n        }\n        let selectedItemChanged;\n        if (this.props.selectedId) {\n          selectedItemChanged = this.props.selectedId !== prevProps.selectedId;\n        } else {\n          selectedItemChanged =\n            this.props.items[this.props.selectedItemIndex] &&\n            prevProps.items[prevProps.selectedItemIndex] &&\n            this.props.items[this.props.selectedItemIndex].name !== prevProps.items[prevProps.selectedItemIndex].name;\n        }\n        if (selectedItemChanged) {\n          if (!selectedItem.isStage) {\n            if (typeof folder === \"string\" && !this.state.folders.includes(folder)) {\n              this.setState((prevState) => ({\n                folders: [...prevState.folders, folder],\n              }));\n            }\n          }\n        }\n      }\n    };\n\n    const originalSortableHOCRender = SortableHOC.prototype.render;\n    SortableHOC.prototype.render = function () {\n      const originalProps = this.props;\n      this.props = {\n        ...this.props,\n        ...processItems((this.state && this.state.folders) || [], this.props),\n      };\n\n      if (type === TYPE_SPRITES) {\n        currentSpriteItems = this.props.items;\n      } else if (type === TYPE_ASSETS) {\n        currentAssetItems = this.props.items;\n      }\n      const result = originalSortableHOCRender.call(this);\n      this.props = originalProps;\n      return result;\n    };\n  };\n\n  const getAllFolders = (component) => {\n    const result = new Set();\n    let items;\n    if (component.props.dragType === \"SPRITE\") {\n      items = currentSpriteItems;\n    } else {\n      items = currentAssetItems;\n    }\n    for (const item of items) {\n      const data = getItemData(item);\n      if (typeof data.folder === \"string\") {\n        result.add(data.folder);\n      }\n    }\n    return Array.from(result);\n  };\n\n  const isFolderOpen = (component, folder) => {\n    const sortableHOCInstance = getSortableHOCFromElement(component.ref);\n    const folders = (sortableHOCInstance.state && sortableHOCInstance.state.folders) || [];\n    return folders.includes(folder);\n  };\n\n  const setFolderOpen = (component, folder, open) => {\n    const sortableHOCInstance = getSortableHOCFromElement(component.ref);\n    sortableHOCInstance.setState((prevState) => {\n      let folders = (prevState && prevState.folders) || [];\n      folders = folders.filter((i) => i !== folder);\n      if (open) {\n        return {\n          folders: [...folders, folder],\n        };\n      }\n      return {\n        folders,\n      };\n    });\n  };\n\n  await addon.tab.scratchClassReady();\n  addon.tab.createEditorContextMenu((ctxType, ctx) => {\n    if (ctxType !== \"sprite\" && ctxType !== \"costume\" && ctxType !== \"sound\") return;\n    const component = ctx.target[addon.tab.traps.getInternalKey(ctx.target)].return.return.return.stateNode;\n    const data = getItemData(component.props);\n    if (!data) return;\n    if (typeof data.folder === \"string\") {\n      ctx.target.setAttribute(\"sa-folders-context-type\", \"folder\");\n\n      const renameItems = (newName) => {\n        const isOpen = isFolderOpen(component, data.folder);\n        setFolderOpen(component, data.folder, false);\n        if (isOpen && typeof newName === \"string\") {\n          setFolderOpen(component, newName, true);\n        }\n        if (component.props.dragType === \"SPRITE\") {\n          for (const target of vm.runtime.targets) {\n            if (target.isOriginal) {\n              if (getFolderFromName(target.getName()) === data.folder) {\n                vm.renameSprite(target.id, ensureNotReserved(setFolderOfName(target.getName(), newName)));\n              }\n            }\n          }\n          vm.emitWorkspaceUpdate();\n          fixTargetOrder();\n        } else if (component.props.dragType === \"COSTUME\") {\n          for (let i = 0; i < vm.editingTarget.sprite.costumes.length; i++) {\n            const costume = vm.editingTarget.sprite.costumes[i];\n            if (getFolderFromName(costume.name) === data.folder) {\n              vm.renameCostume(i, setFolderOfName(costume.name, newName));\n            }\n          }\n          fixCostumeOrder();\n        } else if (component.props.dragType === \"SOUND\") {\n          for (let i = 0; i < vm.editingTarget.sprite.sounds.length; i++) {\n            const sound = vm.editingTarget.sprite.sounds[i];\n            if (getFolderFromName(sound.name) === data.folder) {\n              vm.renameSound(i, setFolderOfName(sound.name, newName));\n            }\n          }\n          fixSoundOrder();\n        }\n      };\n      const renameFolder = async () => {\n        let newName = await addon.tab.prompt(\n          msg(\"rename-folder-prompt-title\"),\n          msg(\"rename-folder-prompt\"),\n          data.folder,\n          { useEditorClasses: true }\n        );\n        // Prompt cancelled, do not rename\n        if (newName === null) {\n          return;\n        }\n        if (!isValidFolderName(newName)) {\n          alert(msg(\"name-not-allowed\"));\n          return;\n        }\n        // Empty name will remove the folder\n        if (!newName) {\n          newName = null;\n        }\n        renameItems(newName);\n      };\n\n      const removeFolder = () => {\n        renameItems(null);\n      };\n      return [\n        {\n          className: \"sa-folders-rename-folder\",\n          label: msg(\"rename-folder\"),\n          callback: renameFolder,\n          position: \"assetContextMenuAfterDelete\",\n          order: 10,\n        },\n        {\n          className: \"sa-folders-remove-folder\",\n          label: msg(\"remove-folder\"),\n          callback: removeFolder,\n          position: \"assetContextMenuAfterDelete\",\n          order: 11,\n        },\n      ];\n    } else {\n      ctx.target.setAttribute(\"sa-folders-context-type\", \"asset\");\n      const setFolder = (folder) => {\n        if (component.props.dragType === \"SPRITE\") {\n          const target = vm.runtime.getTargetById(component.props.id);\n          vm.renameSprite(component.props.id, ensureNotReserved(setFolderOfName(target.getName(), folder)));\n          fixTargetOrder();\n          vm.emitWorkspaceUpdate();\n        } else if (component.props.dragType === \"COSTUME\") {\n          const data = getItemData(component.props);\n          const index = data.realIndex;\n          const asset = vm.editingTarget.sprite.costumes[index];\n          vm.renameCostume(vm.editingTarget.sprite.costumes.indexOf(asset), setFolderOfName(asset.name, folder));\n          fixCostumeOrder();\n        } else if (component.props.dragType === \"SOUND\") {\n          const data = getItemData(component.props);\n          const index = data.realIndex;\n          const asset = vm.editingTarget.sprite.sounds[index];\n          vm.renameSound(vm.editingTarget.sprite.sounds.indexOf(asset), setFolderOfName(asset.name, folder));\n          fixSoundOrder();\n        }\n      };\n\n      const createFolder = async () => {\n        const name = await addon.tab.prompt(\n          msg(\"name-prompt-title\"),\n          msg(\"name-prompt\"),\n          getNameWithoutFolder(data.realName),\n          { useEditorClasses: true }\n        );\n        if (name === null) {\n          return;\n        }\n        if (!isValidFolderName(name)) {\n          alert(msg(\"name-not-allowed\"));\n          return;\n        }\n        setFolder(name);\n      };\n      const base = [\n        {\n          border: true,\n          className: \"sa-folders-create-folder\",\n          label: msg(\"create-folder\"),\n          callback: createFolder,\n          position: \"assetContextMenuAfterDelete\",\n          order: 13,\n        },\n      ];\n      const currentFolder = data.inFolder;\n      if (typeof currentFolder === \"string\") {\n        base.push({\n          className: \"sa-folders-remove-from-folder\",\n          label: msg(\"remove-from-folder\"),\n          callback: () => setFolder(null),\n          position: \"assetContextMenuAfterDelete\",\n          order: 14,\n        });\n      }\n      return base.concat(\n        getAllFolders(component)\n          .filter((folder) => folder !== currentFolder)\n          .map((folder, i) => {\n            return {\n              className: \"sa-folders-add-to-folder\",\n              label: msg(\"add-to-folder\", {\n                folder,\n              }),\n              callback: () => setFolder(folder),\n              position: \"assetContextMenuAfterDelete\",\n              order: 20 + i,\n            };\n          })\n      );\n    }\n  });\n\n  const patchSpriteSelectorItem = (SpriteSelectorItem) => {\n    for (const method of [\"handleDelete\", \"handleDuplicate\", \"handleExport\"]) {\n      const original = SpriteSelectorItem.prototype[method];\n      SpriteSelectorItem.prototype[method] = function (...args) {\n        if (typeof this.props.id === \"number\") {\n          const itemData = getItemData(this.props);\n          if (itemData) {\n            const originalProps = this.props;\n            this.props = {\n              ...originalProps,\n              id: itemData.realIndex,\n            };\n            const ret = original.call(this, ...args);\n            this.props = originalProps;\n            return ret;\n          }\n        }\n        return original.call(this, ...args);\n      };\n    }\n\n    const originalHandleDragEnd = SpriteSelectorItem.prototype.handleDragEnd;\n    SpriteSelectorItem.prototype.handleDragEnd = function (...args) {\n      const itemData = getItemData(this.props);\n      if (itemData) {\n        if (typeof itemData.realIndex === \"number\" && this.props.dragging) {\n          // If the item is being dragged onto another group (eg. costume list -> sprite list)\n          // then we fake a drag event to make the `index` be the real index\n          const originalIndex = this.props.index;\n          const realIndex = itemData.realIndex;\n          if (originalIndex !== realIndex) {\n            const currentOffset = addon.tab.redux.state.scratchGui.assetDrag.currentOffset;\n            const sortableHOCInstance = getSortableHOCFromElement(this.ref);\n            if (currentOffset && sortableHOCInstance && sortableHOCInstance.getMouseOverIndex() === null) {\n              this.props.index = realIndex;\n              this.handleDrag(currentOffset);\n              this.props.index = originalIndex;\n            }\n          }\n        }\n      }\n      return originalHandleDragEnd.call(this, ...args);\n    };\n\n    const originalHandleClick = SpriteSelectorItem.prototype.handleClick;\n    SpriteSelectorItem.prototype.handleClick = function (...args) {\n      const e = args[0];\n      if (e && !this.noClick) {\n        const itemData = getItemData(this.props);\n        if (itemData) {\n          if (typeof itemData.folder === \"string\") {\n            e.preventDefault();\n            setFolderOpen(this, itemData.folder, !isFolderOpen(this, itemData.folder));\n            return;\n          }\n          if (typeof this.props.number === \"number\" && typeof itemData.realIndex === \"number\") {\n            e.preventDefault();\n            if (this.props.onClick) {\n              this.props.onClick(itemData.realIndex);\n            }\n            return;\n          }\n        }\n      }\n      return originalHandleClick.call(this, ...args);\n    };\n\n    const originalRender = SpriteSelectorItem.prototype.render;\n    SpriteSelectorItem.prototype.render = function () {\n      const itemData = getItemData(this.props);\n      if (itemData) {\n        const originalProps = this.props;\n        this.props = {\n          ...this.props,\n        };\n\n        if (typeof itemData.realName === \"string\") {\n          this.props.name = getNameWithoutFolder(itemData.realName);\n        }\n        if (typeof this.props.number === \"number\" && typeof itemData.realIndex === \"number\") {\n          // Convert 0-indexed to 1-indexed\n          this.props.number = itemData.realIndex + 1;\n        }\n        if (typeof itemData.folder === \"string\") {\n          this.props.name = itemData.folder;\n          if (itemData.folderOpen) {\n            this.props.details = msg(\"open-folder\");\n          } else {\n            this.props.details = msg(\"closed-folder\");\n          }\n          this.props.selected = false;\n          this.props.number = null;\n          this.props.className += ` ${getFolderColorClass(itemData.folder)} sa-folders-folder`;\n        }\n        if (typeof itemData.inFolder === \"string\") {\n          this.props.className += ` ${getFolderColorClass(itemData.inFolder)}`;\n        }\n\n        const result = originalRender.call(this);\n\n        this.props = originalProps;\n        return result;\n      }\n      return originalRender.call(this);\n    };\n  };\n\n  const patchVM = () => {\n    const RenderedTarget = vm.runtime.targets[0].constructor;\n\n    const originalInstallTargets = vm.installTargets;\n    vm.installTargets = function (...args) {\n      if (currentSpriteFolder !== null) {\n        const targets = args[0];\n        const wholeProject = args[2];\n        if (Array.isArray(targets) && !wholeProject) {\n          for (const target of targets) {\n            if (target.sprite) {\n              target.sprite.name = setFolderOfName(target.sprite.name, currentSpriteFolder);\n            }\n          }\n        }\n      }\n      return originalInstallTargets.call(this, ...args).then((r) => {\n        fixTargetOrder();\n        return r;\n      });\n    };\n\n    const originalDuplicateSprite = vm.duplicateSprite;\n    vm.duplicateSprite = function (...args) {\n      return originalDuplicateSprite.call(this, ...args).then((r) => {\n        fixTargetOrder();\n        return r;\n      });\n    };\n\n    const originalAddCostume = RenderedTarget.prototype.addCostume;\n    RenderedTarget.prototype.addCostume = function (...args) {\n      if (currentAssetFolder !== null) {\n        const costume = args[0];\n        if (costume && typeof getFolderFromName(costume.name) !== \"string\") {\n          costume.name = setFolderOfName(costume.name, currentAssetFolder);\n        }\n      }\n      const r = originalAddCostume.call(this, ...args);\n      fixCostumeOrder(this);\n      return r;\n    };\n\n    const originalAddSound = RenderedTarget.prototype.addSound;\n    RenderedTarget.prototype.addSound = function (...args) {\n      if (currentAssetFolder !== null) {\n        const sound = args[0];\n        if (sound && typeof getFolderFromName(sound.name) !== \"string\") {\n          sound.name = setFolderOfName(sound.name, currentAssetFolder);\n        }\n      }\n      const r = originalAddSound.call(this, ...args);\n      fixSoundOrder(this);\n      return r;\n    };\n\n    const abstractReorder = (\n      { guiItems, getAll, set, rename, getVMItemFromGUIItem, zeroIndexed, onFolderChanged },\n      itemIndex,\n      newIndex\n    ) => {\n      // First index depends on zeroIndexed\n      itemIndex = clamp(itemIndex, zeroIndexed ? 0 : 1, zeroIndexed ? guiItems.length - 1 : guiItems.length);\n      newIndex = clamp(newIndex, zeroIndexed ? 0 : 1, zeroIndexed ? guiItems.length - 1 : guiItems.length);\n      if (itemIndex === newIndex) {\n        return false;\n      }\n\n      let assets = getAll();\n      const originalAssets = getAll();\n\n      const targetItem = guiItems[itemIndex - (zeroIndexed ? 0 : 1)];\n      const itemAtNewIndex = guiItems[newIndex - (zeroIndexed ? 0 : 1)];\n      const targetItemData = getItemData(targetItem);\n      const itemAtNewIndexData = getItemData(itemAtNewIndex);\n\n      if (!targetItemData || !itemAtNewIndexData) {\n        console.warn(\"should never happen\");\n        return false;\n      }\n\n      const reorderingItems = typeof targetItemData.folder === \"string\" ? targetItem.items : [targetItem];\n      const reorderingAssets = reorderingItems.map((i) => getVMItemFromGUIItem(i, assets)).filter((i) => i);\n      if (typeof itemAtNewIndexData.realIndex === \"number\") {\n        const newTarget = getVMItemFromGUIItem(itemAtNewIndex, assets);\n        if (!newTarget || reorderingAssets.includes(newTarget)) {\n          // Dragging folder into itself or target doesn't exist. Ignore.\n          return false;\n        }\n      }\n\n      let newFolder = null;\n\n      assets = assets.filter((i) => !reorderingAssets.includes(i));\n\n      let realNewIndex;\n      if (newIndex === (zeroIndexed ? 0 : 1)) {\n        realNewIndex = zeroIndexed ? 0 : 1;\n      } else if (newIndex === guiItems.length - (zeroIndexed ? 1 : 0)) {\n        realNewIndex = assets.length;\n      } else if (typeof itemAtNewIndexData.realIndex === \"number\") {\n        newFolder = typeof itemAtNewIndexData.inFolder === \"string\" ? itemAtNewIndexData.inFolder : null;\n        let newAsset = getVMItemFromGUIItem(itemAtNewIndex, assets);\n        if (!newAsset) {\n          console.warn(\"should never happen\");\n          return false;\n        }\n        realNewIndex = assets.indexOf(newAsset);\n        if (newIndex > itemIndex) {\n          realNewIndex++;\n        }\n      } else if (typeof itemAtNewIndexData.folder === \"string\") {\n        let item;\n        let offset = 0;\n        if (newIndex < itemIndex) {\n          // A B [C D E] F G\n          //    ^----------*\n          // A B C [D] E F G\n          //      ^--------*\n          item = itemAtNewIndex.items[0];\n        } else if (itemAtNewIndexData.folderOpen) {\n          // A B [C D E] F G\n          //   *---^\n          item = itemAtNewIndex.items[0];\n          newFolder = itemAtNewIndexData.folder;\n        } else {\n          // A B [C] D E F G\n          //   *----^\n          item = itemAtNewIndex.items[itemAtNewIndex.items.length - 1];\n          offset = 1;\n        }\n        let newAsset = getVMItemFromGUIItem(item, assets);\n        if (newAsset) {\n          realNewIndex = assets.indexOf(newAsset) + offset;\n        } else {\n          // Edge case: Dragging the first item of a list on top of the folder item\n          // A B [C D E] F G\n          //    ^---*\n          newAsset = getVMItemFromGUIItem(item, originalAssets);\n          if (!newAsset) {\n            console.warn(\"should never happen\");\n            return false;\n          }\n          realNewIndex = originalAssets.indexOf(newAsset) + offset;\n        }\n      } else {\n        console.warn(\"should never happen\");\n        return false;\n      }\n\n      if (typeof targetItemData.folder === \"string\" && newFolder !== null) {\n        // Cannot drag a folder into another folder\n        return;\n      }\n\n      if (realNewIndex < (zeroIndexed ? 0 : 1) || realNewIndex > assets.length) {\n        console.warn(\"should never happen\");\n        return false;\n      }\n\n      assets.splice(realNewIndex, 0, ...reorderingAssets);\n      set(assets);\n\n      // If the folder has changed, update item names to match.\n      if (typeof targetItemData.folder !== \"string\" && targetItemData.inFolder !== newFolder) {\n        for (const asset of reorderingAssets) {\n          const name = asset.getName ? asset.getName() : asset.name;\n          rename(asset, setFolderOfName(name, newFolder));\n        }\n        if (onFolderChanged) {\n          onFolderChanged();\n        }\n      }\n\n      return true;\n    };\n\n    vm.constructor.prototype.reorderTarget = function (targetIndex, newIndex) {\n      return abstractReorder(\n        {\n          getAll: () => {\n            return this.runtime.targets;\n          },\n          set: (targets) => {\n            this.runtime.targets = targets;\n            this.emitTargetsUpdate();\n          },\n          rename: (item, name) => {\n            this.renameSprite(item.id, ensureNotReserved(name));\n          },\n          getVMItemFromGUIItem: (item, targets) => {\n            return targets.find((i) => i.id === item.id);\n          },\n          onFolderChanged: () => {\n            this.emitWorkspaceUpdate();\n          },\n          guiItems: currentSpriteItems,\n          zeroIndexed: false,\n        },\n        targetIndex,\n        newIndex\n      );\n    };\n\n    RenderedTarget.prototype.reorderCostume = function (costumeIndex, newIndex) {\n      return abstractReorder(\n        {\n          getAll: () => {\n            return this.sprite.costumes;\n          },\n          set: (assets) => {\n            this.sprite.costumes = assets;\n          },\n          rename: (item, name) => {\n            this.renameCostume(this.sprite.costumes.indexOf(item), name);\n          },\n          getVMItemFromGUIItem: (item, costumes) => {\n            const itemData = getItemData(item);\n            return costumes.find((c) => c.name === itemData.realName);\n          },\n          guiItems: currentAssetItems,\n          zeroIndexed: true,\n        },\n        costumeIndex,\n        newIndex\n      );\n    };\n\n    RenderedTarget.prototype.reorderSound = function (soundIndex, newIndex) {\n      return abstractReorder(\n        {\n          getAll: () => {\n            return this.sprite.sounds;\n          },\n          set: (assets) => {\n            this.sprite.sounds = assets;\n          },\n          rename: (item, name) => {\n            this.renameSound(this.sprite.sounds.indexOf(item), name);\n          },\n          getVMItemFromGUIItem: (item, sounds) => {\n            const itemData = getItemData(item);\n            return sounds.find((c) => c.name === itemData.realName);\n          },\n          guiItems: currentAssetItems,\n          zeroIndexed: true,\n        },\n        soundIndex,\n        newIndex\n      );\n    };\n\n    // Temporal bug fix for #5762\n    const originalShareSoundToTarget = vm.shareSoundToTarget;\n    vm.shareSoundToTarget = function (...args) {\n      const target = this.runtime.getTargetById(args[1]);\n      if (!target) {\n        // Avoid reading property from null\n        return Promise.reject(new Error(\"Dropping sound into folder is not supported\"));\n        // This would also work no matter what we returned, probably\n        // Original method returns a promise, so here too\n      }\n      return originalShareSoundToTarget.call(this, ...args);\n    };\n  };\n\n  const patchBackpack = (backpackInstance) => {\n    const Backpack = backpackInstance.constructor;\n    Backpack.prototype.sa_loadNextItem = function () {\n      if (!this.sa_queuedItems) return;\n      const item = this.sa_queuedItems.pop();\n      if (item) {\n        let payload;\n        let type;\n        if (item.dragPayload) {\n          if (item.url) {\n            type = \"SOUND\";\n          } else {\n            type = \"COSTUME\";\n          }\n          payload = item.dragPayload;\n        } else if (item.id) {\n          type = \"SPRITE\";\n          payload = item.id;\n        }\n        if (type && payload) {\n          originalHandleDrop.call(this, {\n            dragType: type,\n            payload: payload,\n          });\n        }\n      }\n    };\n\n    Backpack.prototype.componentDidUpdate = function (prevProps, prevState) {\n      if (!this.state.loading && prevState.loading && !this.state.error) {\n        this.sa_loadNextItem();\n      }\n    };\n\n    const originalHandleDrop = Backpack.prototype.handleDrop;\n    Backpack.prototype.handleDrop = function (...args) {\n      // When a folder is dropped into the backpack, upload all the items in the folder.\n      const dragInfo = args[0];\n      const folderItems = dragInfo && dragInfo.payload && dragInfo.payload.sa_folder_items;\n      if (Array.isArray(folderItems)) {\n        addon.tab.confirm(\"\", msg(\"confirm-backpack-folder\"), { useEditorClasses: true }).then((result) => {\n          if (!result) return;\n          this.sa_queuedItems = folderItems;\n          this.sa_loadNextItem();\n        });\n        return;\n      }\n      return originalHandleDrop.call(this, ...args);\n    };\n    backpackInstance.handleDrop = Backpack.prototype.handleDrop.bind(backpackInstance);\n  };\n\n  // Backpack\n  {\n    const clickListener = (e) => {\n      if (!e.target.closest('[class*=\"backpack_backpack-header_\"]')) {\n        return;\n      }\n      setTimeout(() => {\n        const backpackContainer = document.querySelector(\"[class^='backpack_backpack-list_']\");\n        if (!backpackContainer) {\n          return;\n        }\n        document.removeEventListener(\"click\", clickListener);\n        const backpackInstance = getBackpackFromElement(backpackContainer);\n        verifyBackpack(backpackInstance);\n        patchBackpack(backpackInstance);\n      });\n    };\n    document.addEventListener(\"click\", clickListener, true);\n  }\n\n  // Sprite list\n  {\n    const spriteSelectorItemElement = await addon.tab.waitForElement(\"[class^='sprite-selector_sprite-wrapper']\", {\n      reduxCondition: (state) => !state.scratchGui.mode.isPlayerOnly,\n    });\n    vm = addon.tab.traps.vm;\n    reactInternalKey = Object.keys(spriteSelectorItemElement).find((i) => i.startsWith(REACT_INTERNAL_PREFIX));\n    const sortableHOCInstance = getSortableHOCFromElement(spriteSelectorItemElement);\n    const spriteSelectorItemInstance = spriteSelectorItemElement[reactInternalKey].child.child.child.stateNode;\n    verifySortableHOC(sortableHOCInstance);\n    verifySpriteSelectorItem(spriteSelectorItemInstance);\n    verifyVM(vm);\n    patchSortableHOC(sortableHOCInstance.constructor, TYPE_SPRITES);\n    patchSpriteSelectorItem(spriteSelectorItemInstance.constructor);\n    sortableHOCInstance.saInitialSetup();\n    patchVM();\n  }\n\n  // Costume and sound list\n  {\n    const selectorListItem = await addon.tab.waitForElement(\"[class*='selector_list-item']\", {\n      reduxCondition: (state) => state.scratchGui.editorTab.activeTabIndex !== 0 && !state.scratchGui.mode.isPlayerOnly,\n    });\n    const sortableHOCInstance = getSortableHOCFromElement(selectorListItem);\n    verifySortableHOC(sortableHOCInstance);\n    patchSortableHOC(sortableHOCInstance.constructor, TYPE_ASSETS);\n    sortableHOCInstance.saInitialSetup();\n  }\n}\n","/**\n * @file Contains the code for rendering the blocks in the middle click dropdown.\n * Main function is {@link renderBlock} which takes in a block and returns a renderer SVG element.\n * @author Tacodiva\n */\n\nimport { BlockShape, BlockInstance, BlockInputEnum, BlockInputBoolean, BlockInputBlock } from \"./BlockTypeInfo.js\";\nimport { getTextWidth } from \"./module.js\";\n\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\n\nconst BlockShapes = {\n  // eg (my variable)\n  Round: {\n    padding: 12,\n    minWidth: 20,\n    backgroundPath: (width) => `m -12 -20 m 20 0 h ${width - 16} a 20 20 0 0 1 0 40 H 8 a 20 20 0 0 1 0 -40 z`,\n\n    /**\n     * 'Snuggling' is my wholesome term for when a block can sit extra close to a block\n     * of the same shape as it. Take a look at the blocks ( ( \"\" + \"\" ) - \"\" ) and\n     * ( < \"\" = \"\" > - \"\" ), observe how there's a lot more blank space in the outer\n     * block in the second example, this is because in the first example the '+' block\n     * can snuggle with the '-' block.\n     */\n    snugglePadding: 0,\n    get snuggleWith() {\n      // Don't feel bad BlockShapes.Round, I only snuggle with myself too :_(\n      return [BlockShapes.Round];\n    },\n  },\n\n  // eg <() = ()>\n  Boolean: {\n    padding: 20,\n    minWidth: 20,\n    backgroundPath: (width) => `m -20 -20 m 20 0 h ${width} l 20 20 l -20 20 H 0 l -20 -20 l 20 -20 z`,\n\n    snugglePadding: 0,\n    get snuggleWith() {\n      return [BlockShapes.Boolean];\n    },\n  },\n\n  // Square dropdowns like variables\n  SquareInput: {\n    padding: 8,\n    minWidth: 20,\n    backgroundPath: (width) =>\n      `m -2 -16 h ${width + 4} a 4 4 0 0 1 4 4 V 12 a 4 4 0 0 1 -4 4 H -2 a 4 4 0 0 1 -4 -4 V -12 a 4 4 0 0 1 4 -4`,\n  },\n\n  // eg show\n  Stack: {\n    padding: 8,\n    minWidth: 60,\n    backgroundPath: (width) =>\n      `m -8 -20 A 4 4 0 0 1 -4 -24 H 4 c 2 0 3 1 4 2 l 4 4 c 1 1 2 2 4 2 h 12 c 2 0 3 -1 4 -2 l 4 -4 C 37 -23 38 -24 40 -24 H ${width} a 4 4 0 0 1 4 4 v 40 a 4 4 0 0 1 -4 4 H 40 c -2 0 -3 1 -4 2 l -4 4 c -1 1 -2 2 -4 2 h -12 c -2 0 -3 -1 -4 -2 l -4 -4 c -1 -1 -2 -2 -4 -2 H -4 a 4 4 0 0 1 -4 -4 z`,\n  },\n\n  // eg when I start as a clone\n  Hat: {\n    padding: 8,\n    minWidth: 60,\n    backgroundPath: (width) =>\n      `m -8 -20 A 4 4 0 0 1 -4 -24 H ${width} a 4 4 0 0 1 4 4 v 40 a 4 4 0 0 1 -4 4 H 40 c -2 0 -3 1 -4 2 l -4 4 c -1 1 -2 2 -4 2 h -12 c -2 0 -3 -1 -4 -2 l -4 -4 c -1 -1 -2 -2 -4 -2 H -4 a 4 4 0 0 1 -4 -4 z`,\n  },\n\n  // eg delete this clone\n  End: {\n    padding: 8,\n    minWidth: 60,\n    backgroundPath: (width) =>\n      `m -8 -20 A 4 4 0 0 1 -4 -24 H 4 c 2 0 3 1 4 2 l 4 4 c 1 1 2 2 4 2 h 12 c 2 0 3 -1 4 -2 l 4 -4 C 37 -23 38 -24 40 -24 H ${width} a 4 4 0 0 1 4 4 v 40 a 4 4 0 0 1 -4 4 H -4 a 4 4 0 0 1 -4 -4 z`,\n  },\n\n  // The white oval for text or number inputs\n  TextInput: {\n    padding: 12,\n    minWidth: 16,\n    backgroundPath: (width) => `m -12 -16 m 16 0 h ${width - 8} a 16 16 0 0 1 0 32 H 4 a 16 16 0 0 1 0 -32 z`,\n\n    snugglePadding: 4,\n    get snuggleWith() {\n      return [BlockShapes.Round];\n    },\n  },\n\n  BooleanInput: {\n    padding: 16,\n    minWidth: 16,\n    backgroundPath: (width) => `m 0 -16 h ${width} l 16 16 l -16 16 h -16 l -16 -16 l 16 -16 z`,\n\n    snugglePadding: 6,\n    get snuggleWith() {\n      return [BlockShapes.Boolean];\n    },\n  },\n\n  HorizontalBlock: {\n    padding: 16,\n    minWidth: 45,\n    backgroundPath: (width) =>\n      `M -4 -20 a 4 4 0 0 1 4 -4 H ${\n        width + 8\n      } a 4 4 0 0 1 4 4 v 2 c 0 2 -1 3 -2 4 l -4 4 c -1 1 -2 2 -2 4 v 12 c 0 2 1 3 2 4 l 4 4 c 1 1 2 2 2 4 v 2 a 4 4 0 0 1 -4 4 H 0 a 4 4 0 0 1 -4 -4 v -2 c 0 -2 -1 -3 -2 -4 l -4 -4 c -1 -1 -2 -2 -2 -4 v -12 c 0 -2 1 -3 2 -4 l 4 -4 c 1 -1 2 -2 2 -4 z`,\n  },\n\n  HorizontalBlockEnd: {\n    padding: 16,\n    minWidth: 45,\n    backgroundPath: (width) =>\n      `M -4 -20 a 4 4 0 0 1 4 -4 H ${\n        width + 8\n      } a 4 4 0 0 1 4 4 V 20 a 4 4 0 0 1 -4 4 H 0 a 4 4 0 0 1 -4 -4 v -2 c 0 -2 -1 -3 -2 -4 l -4 -4 c -1 -1 -2 -2 -2 -4 v -12 c 0 -2 1 -3 2 -4 l 4 -4 c 1 -1 2 -2 2 -4 z`,\n  },\n};\n\n/**\n * Gets the block shape info from {@link BlockShapes} given a {@link BlockShape}.\n * @param {BlockShape} shape\n */\nfunction getShapeInfo(shape, isVertical) {\n  if (shape === BlockShape.Round) return BlockShapes.Round;\n  if (shape === BlockShape.Boolean) return BlockShapes.Boolean;\n  if (shape === BlockShape.Stack) return isVertical ? BlockShapes.Stack : BlockShapes.HorizontalBlock;\n  if (shape === BlockShape.Hat) return BlockShapes.Hat;\n  if (shape === BlockShape.End) return isVertical ? BlockShapes.End : BlockShapes.HorizontalBlockEnd;\n  throw new Error(shape);\n}\n\n/**\n * @param {BlockInstance} block\n * @returns {number}\n */\nexport function getBlockHeight(block) {\n  switch (block.typeInfo.shape) {\n    case BlockShape.End:\n    case BlockShape.Hat:\n    case BlockShape.Stack:\n      return 62;\n    case BlockShape.Boolean:\n    case BlockShape.Round:\n      return 48;\n  }\n  return 0;\n}\n\nconst BLOCK_ELEMENT_SPACING = 8;\n\n/**\n * A part of a block. Think of these like the different parts in the 'make a block' menu.\n */\nexport class BlockComponent {\n  constructor(element, padding, width, snuggleWith, snugglePadding) {\n    this.dom = element;\n    this.padding = padding;\n    this.width = width;\n    this.snuggleWith = snuggleWith;\n    this.snugglePadding = snugglePadding;\n  }\n}\n\n/**\n * Creates a BlockComponent with some text. Like the 'label' element in the make a block menu.\n * @param {string} text The contents of the component.\n * @param {SVGElement} container The element to add the text to.\n * @returns {BlockComponent} The BlockComponent.\n */\nfunction createTextComponent(text, fillVar, container) {\n  let textElement = container.appendChild(document.createElementNS(SVG_NS, \"text\"));\n  textElement.setAttribute(\"class\", \"blocklyText\");\n  textElement.style.fill = `var(${fillVar})`;\n  textElement.setAttribute(\"dominant-baseline\", \"middle\");\n  textElement.setAttribute(\"dy\", 1);\n  textElement.appendChild(document.createTextNode(text));\n  return new BlockComponent(textElement, 0, getTextWidth(textElement));\n}\n\n/**\n * Creates a DOM element to hold all the contents of a block.\n * A block could be the top level block, or it could be a block like (() + ()) that's inside\n * another block.\n * @returns {SVGElement} The SVGElement which will contain all the block's components.\n */\nfunction createBlockContainer() {\n  let container = document.createElementNS(SVG_NS, \"g\");\n  let background = document.createElementNS(SVG_NS, \"path\");\n  background.setAttribute(\"class\", \"blocklyPath\");\n  container.appendChild(background);\n  return container;\n}\n\n/**\n * Creates a block component from a container containing all its components.\n * @param {SVGElement} container The block container, created by {@link createBlockContainer}.\n * @param {object} shape An object containing information of the shape of the block to be created. From the {@link BlockShapes} object.\n * @param {string|null} categoryClass The category of the block, used for filling the background.\n * @param {string} fill\n * @param {string} stroke\n * @param {number} width The width of the background of the block.\n */\nfunction createBlockComponent(container, shape, categoryClass, fill, stroke, width) {\n  if (width < shape.minWidth) width = shape.minWidth;\n  container.classList.add(\"sa-block-color\");\n  if (categoryClass) {\n    container.classList.add(categoryClass);\n  }\n  const background = container.children[0];\n  let style = \"\";\n  if (fill) style += `fill: var(${fill});`;\n  if (stroke) style += `stroke: var(${stroke});`;\n  background.setAttribute(\"style\", style);\n  background.setAttribute(\"d\", shape.backgroundPath(width));\n  return new BlockComponent(\n    container,\n    shape.padding,\n    width + shape.padding * 2,\n    shape.snuggleWith,\n    shape.snugglePadding\n  );\n}\n\nfunction createBackedTextedComponent(text, container, shape, categoryClass, fill, stroke, textVar) {\n  const blockContainer = createBlockContainer();\n  container.appendChild(blockContainer);\n  const textElement = createTextComponent(text, textVar, blockContainer);\n  if (textElement.width < shape.minWidth) {\n    textElement.dom.setAttribute(\"x\", (shape.minWidth - textElement.width) / 2);\n  }\n\n  const blockElement = createBlockComponent(blockContainer, shape, categoryClass, fill, stroke, textElement.width);\n  return blockElement;\n}\n\n/**\n * Renders a block, with the center of it's leftmost side located at 0, 0.\n * @param {BlockInstance} block\n * @param {SVGElement} container\n * @returns {BlockComponent} The rendered block\n */\nexport default function renderBlock(block, container) {\n  var blockComponent = _renderBlock(block, container, block.typeInfo.category, true);\n  blockComponent.dom.classList.add(\"sa-block-color\");\n  blockComponent.dom.setAttribute(\"transform\", `translate(${blockComponent.padding}, 0)`);\n  return blockComponent;\n}\n\n/**\n * Renders a block, with the center of it's leftmost side located at 0, 0.\n * @param {BlockInstance} block\n * @param {SVGAElement} container\n * @param {string} parentCategory The category of this blocks parent. If no parent, than this blocks category.\n * @returns {BlockComponent} The rendered component.\n */\nfunction _renderBlock(block, container, parentCategory, isVertical) {\n  const blockContainer = container.appendChild(createBlockContainer());\n  const shape = getShapeInfo(block.typeInfo.shape, isVertical);\n  const category = block.typeInfo.category;\n\n  const COLOR_CLASSES = [\n    \"motion\",\n    \"looks\",\n    \"sounds\",\n    \"events\",\n    \"control\",\n    \"sensing\",\n    \"operators\",\n    \"data\",\n    \"data-lists\",\n    \"list\",\n    \"more\",\n    \"pen\",\n    \"addon-custom-block\"\n  ];\n  const categoryClass = COLOR_CLASSES.includes(category.name) ? \"sa-block-color-\" + category.name : null;\n\n  let xOffset = 0;\n  let inputIdx = 0;\n\n  for (let partIdx = 0; partIdx < block.typeInfo.parts.length; partIdx++) {\n    const blockPart = block.typeInfo.parts[partIdx];\n\n    let component;\n    if (typeof blockPart === \"string\") {\n      component = createTextComponent(blockPart, \"--sa-block-text\", blockContainer);\n    } else {\n      const blockInput = block.inputs[inputIdx++];\n      if (blockInput instanceof BlockInstance) {\n        component = _renderBlock(blockInput, blockContainer, block.typeInfo.category, false);\n      } else if (blockPart instanceof BlockInputEnum) {\n        if (blockPart.isRound) {\n          component = createBackedTextedComponent(\n            blockInput.string,\n            blockContainer,\n            BlockShapes.TextInput,\n            categoryClass,\n            `--sa-block-background-secondary, ${category.colorSecondary}`,\n            `--sa-block-background-tertiary, ${category.colorTertiary}`,\n            \"--sa-block-text\"\n          );\n        } else {\n          component = createBackedTextedComponent(\n            blockInput.string,\n            blockContainer,\n            BlockShapes.SquareInput,\n            categoryClass,\n            `--sa-block-background-primary, ${category.colorPrimary}`,\n            `--sa-block-background-tertiary, ${category.colorTertiary}`,\n            \"--sa-block-text\"\n          );\n        }\n      } else if (blockPart instanceof BlockInputBoolean) {\n        component = createBackedTextedComponent(\n          \"\",\n          blockContainer,\n          BlockShapes.BooleanInput,\n          categoryClass,\n          `--sa-block-field-background, ${category.colorTertiary}`,\n          `--sa-block-field-background, ${category.colorTertiary}`,\n          \"--sa-block-text\"\n        );\n      } else if (blockPart instanceof BlockInputBlock) {\n        component = createBackedTextedComponent(\n          \"\",\n          blockContainer,\n          BlockShapes.HorizontalBlock,\n          categoryClass,\n          `--sa-block-field-background, ${category.colorTertiary}`,\n          `--sa-block-field-background, ${category.colorTertiary}`,\n          \"--sa-block-text\"\n        );\n      } else {\n        component = createBackedTextedComponent(\n          blockInput?.toString() ?? blockPart.defaultValue ?? \"\",\n          blockContainer,\n          BlockShapes.TextInput,\n          categoryClass,\n          `--sa-block-input-color, ${category.colorColor}`,\n          `--sa-block-background-tertiary, ${category.colorTertiary}`,\n          \"--sa-block-input-text\"\n        );\n        component.dom.classList.add(\"blocklyNonEditableText\");\n      }\n    }\n\n    let xTranslation = xOffset + component.padding;\n\n    if (partIdx === 0 || partIdx === block.typeInfo.parts.length - 1) {\n      if (component.snuggleWith && component.snuggleWith.indexOf(shape) !== -1) {\n        const positionDelta = component.snugglePadding - component.padding;\n        component.width += positionDelta;\n\n        if (partIdx === 0) {\n          xTranslation += positionDelta;\n        }\n      }\n    }\n\n    component.dom.setAttribute(\"transform\", `translate(${xTranslation}, 0)`);\n    xOffset += BLOCK_ELEMENT_SPACING + component.width;\n  }\n\n  return createBlockComponent(\n    blockContainer,\n    shape,\n    categoryClass,\n    `--sa-block-background-primary, ${category.colorPrimary}`,\n    `--sa-block-background-tertiary, ${category.colorTertiary}`,\n    xOffset - BLOCK_ELEMENT_SPACING\n  );\n}\n","/**\n * @file Contains the code for enumerating the different types of blocks in a workspace,\n * and provides a more friendly way to create instances blocks with some inputs.\n */\n\n/**\n * A numeric value to represent the type of an {@link BlockInput}\n * @readonly\n * @enum {number}\n */\nexport const BlockInputType = {\n  STRING: 0,\n  NUMBER: 1,\n  BOOLEAN: 2,\n  COLOUR: 3,\n  ENUM: 4,\n  BLOCK: 5,\n};\n\n/**\n * @abstract\n */\nexport class BlockInput {\n  /**\n   * @param {BlockInputType} type\n   * @param {number} inputIdx\n   * @param {number} fieldIdx\n   */\n  constructor(type, inputIdx, fieldIdx) {\n    if (this.constructor === BlockInput) throw new Error(\"Abstract classes can't be instantiated.\");\n    /** @type {BlockInputType} */\n    this.type = type;\n    /** @type {number} The index of this input in the workspace version of the block's input array.  */\n    this.inputIdx = inputIdx;\n    /**\n     * The index of this input in the workspace version of the block's field array.\n     * The special case of -1 means that in the workspace version, this input is inside a sub-block,\n     * that has been abstracted away.\n     *  @type {number}\n     */\n    this.fieldIdx = fieldIdx;\n    /** @type {*} The default value to set this input to, or null to not set it to anything. */\n    this.defaultValue = null;\n  }\n\n  /**\n   * Sets the field this input refers to on a block to a value.\n   * @param {BlockInstance} block\n   * @param {*} value\n   * @abstract\n   */\n  setValue(block, value) {\n    throw new Error(\"Sub-class must override abstract method.\");\n  }\n\n  /**\n   * Gets the input this block input refers to on block.\n   * @param {BlockInstance} block\n   * @returns {*}\n   * @protected\n   */\n  getInput(block) {\n    return block.inputList[this.inputIdx];\n  }\n\n  /**\n   * Gets the field this block input refers to on block.\n   * @param {BlockInstance} block\n   * @returns {*}\n   * @protected\n   */\n  getField(block) {\n    if (this.fieldIdx === -1) {\n      return this.getInput(block).connection.targetBlock().inputList[0].fieldRow[0];\n    } else {\n      return this.getInput(block).fieldRow[this.fieldIdx];\n    }\n  }\n}\n\n/**\n * The base class for any round input.\n * @abstract\n */\nexport class BlockInputRound extends BlockInput {\n  constructor(type, inputIdx, fieldIdx, defaultValue) {\n    super(type, inputIdx, fieldIdx);\n    if (this.constructor === BlockInputRound) throw new Error(\"Abstract classes can't be instantiated.\");\n    this.defaultValue = defaultValue;\n  }\n\n  setValue(block, value) {\n    if (value instanceof BlockInstance) {\n      const subblock = value.createWorkspaceForm();\n      if (!subblock.outputConnection)\n        throw new Error('Cannot put block \"' + subblock.typeInfo.id + '\" into a round type input.');\n      subblock.outputConnection.connect(this.getInput(block).connection);\n    } else {\n      this.getField(block).setValue(this._toFieldValue(value));\n    }\n  }\n\n  /**\n   * Converts a value passed in to setValue to a value we can set the block's field to.\n   * @param {*} value\n   * @protected\n   */\n  _toFieldValue(value) {\n    throw new Error(\"Sub-class must override abstract method.\");\n  }\n}\n\nexport class BlockInputString extends BlockInputRound {\n  constructor(inputIdx, fieldIdx, defaultValue) {\n    super(BlockInputType.STRING, inputIdx, fieldIdx, defaultValue);\n  }\n\n  _toFieldValue(value) {\n    const type = typeof value;\n    if (type === \"number\") return value;\n    if (type === \"string\") return value;\n    throw new Error(\"Cannot set round type input to value of type \" + type);\n  }\n}\n\nexport class BlockInputNumber extends BlockInputRound {\n  constructor(inputIdx, fieldIdx, defaultValue) {\n    super(BlockInputType.NUMBER, inputIdx, fieldIdx, defaultValue);\n  }\n\n  _toFieldValue(value) {\n    const type = typeof value;\n    if (type === \"number\") return value;\n    if (type === \"string\") {\n      if (value.length === 0) return value;\n      const number = parseFloat(value);\n      if (isNaN(number)) throw new Error('Cannot set numeric type input to string \"' + value + '\".');\n      return value;\n    }\n    throw new Error(\"Cannot set round type input to value of type \" + type);\n  }\n}\n\nexport class BlockInputBoolean extends BlockInput {\n  constructor(inputIdx, fieldIdx) {\n    super(BlockInputType.BOOLEAN, inputIdx, fieldIdx);\n  }\n\n  setValue(block, value) {\n    if (value instanceof BlockInstance) {\n      const subblock = value.createWorkspaceForm();\n      if (!subblock.outputConnection || value.typeInfo.shape !== BlockShape.Boolean)\n        throw new Error('Cannot put block \"' + value.typeInfo.id + '\" into a boolean type input.');\n      subblock.outputConnection.connect(this.getInput(block).connection);\n    } else {\n      throw new Error(\"Boolean type inputs can only contain blocks.\");\n    }\n  }\n}\n\nexport class BlockInputColour extends BlockInput {\n  constructor(inputIdx, fieldIdx) {\n    super(BlockInputType.COLOUR, inputIdx, fieldIdx);\n  }\n\n  setValue(block, value) {\n    if (typeof value !== \"string\") throw new Error(\"Cannot set color type input to value of type \" + typeof type);\n    if (!value.match(/^#[0-9a-fA-F]{6}$/)) throw new Error('Invalid color \"' + value + '\".');\n    this.getField(block).setValue(value);\n  }\n}\n\n/**\n * @typedef BlockInputEnumOption\n * @property {string} value The internal name of this input option\n * @property {string} string The localized name of this input option.\n */\n\n/**\n * A block input that can be one of a list of values.\n * Usually represented by a dropdown menu in Scratch.\n */\nexport class BlockInputEnum extends BlockInput {\n  static INVALID_VALUES = [\n    \"DELETE_VARIABLE_ID\",\n    \"RENAME_VARIABLE_ID\",\n    \"NEW_BROADCAST_MESSAGE_ID\",\n    \"NEW_BROADCAST_MESSAGE_ID\",\n    // editor-searchable-dropdowns compatibility\n    \"createGlobalVariable\",\n    \"createLocalVariable\",\n    \"createGlobalList\",\n    \"createLocalList\",\n    \"createBroadcast\",\n    // rename-broadcasts compatibility\n    \"RENAME_BROADCAST_MESSAGE_ID\",\n  ];\n\n  /**\n   * @param {Array} options\n   * @param {number} inputIdx\n   * @param {number} fieldIdx\n   */\n  constructor(options, inputIdx, fieldIdx, isRound) {\n    super(BlockInputType.ENUM, inputIdx, fieldIdx);\n    /** @type {BlockInputEnumOption[]} */\n    this.values = [];\n    for (let i = 0; i < options.length; i++) {\n      if (typeof options[i][1] === \"string\" && BlockInputEnum.INVALID_VALUES.indexOf(options[i][1]) === -1) {\n        this.values.push({ value: options[i][1], string: options[i][0].replaceAll(String.fromCharCode(160), \" \") });\n      }\n    }\n    this.isRound = isRound;\n    this.defaultValue = this.values[0];\n  }\n\n  /**\n   * @param {BlockInputEnumOption} value\n   */\n  setValue(block, value) {\n    if (this.isRound && value instanceof BlockInstance) {\n      value.createWorkspaceForm().outputConnection.connect(this.getInput(block).connection);\n    } else {\n      if (this.values.indexOf(value) === -1) throw new Error(\"Invalid enum value. Expected item from the values list.\");\n      this.getField(block).setValue(value.value);\n    }\n  }\n}\n\n/**\n * A block input that is a stack of blocks.\n * The 'if' block has a single block input, the 'if else' block has two block inputs.\n */\nexport class BlockInputBlock extends BlockInput {\n  constructor(inputIdx, fieldIdx) {\n    super(BlockInputType.BLOCK, inputIdx, fieldIdx);\n  }\n\n  setValue(block, value) {\n    if (value instanceof BlockInstance) {\n      const subblock = value.createWorkspaceForm();\n      if (!subblock.previousConnection || !value.typeInfo.shape.canStackUp)\n        throw new Error('Cannot put block \"' + value.typeInfo.id + '\" into a block type input.');\n      subblock.previousConnection.connect(this.getInput(block).connection);\n    } else {\n      throw new Error(\"Block type inputs can only contain blocks.\");\n    }\n  }\n}\n\n/**\n * Because everyone was thinking \"You know what Scratch really needs, ANOTHER way to represent blocks!\"\n *\n * Another way to represent a Scratch block.\n */\nexport class BlockInstance {\n  constructor(typeInfo, ...inputs) {\n    /** @type {BlockTypeInfo} */\n    this.typeInfo = typeInfo;\n    /** @type {Array} */\n    this.inputs = inputs;\n\n    for (let i = 0; i < this.typeInfo.inputs.length; i++) {\n      if (this.inputs[i] == null) this.inputs[i] = this.typeInfo.inputs[i].defaultValue;\n    }\n  }\n\n  /**\n   * Creates a real Scratch block from this imaginary representation.\n   * @returns {*} A 'workspace form' block.\n   */\n  createWorkspaceForm() {\n    if (this.typeInfo.id === \"control_stop\") {\n      this.typeInfo.domForm\n        .querySelector(\"mutation\")\n        .setAttribute(\"hasnext\", \"\" + (this.inputs[0].value === \"other scripts in sprite\"));\n    }\n\n    const block = this.typeInfo.Blockly.Xml.domToBlock(this.typeInfo.domForm, this.typeInfo.workspace);\n    for (let i = 0; i < this.typeInfo.inputs.length; i++) {\n      const inputValue = this.inputs[i];\n      if (inputValue != null) this.typeInfo.inputs[i].setValue(block, inputValue);\n    }\n\n    return block;\n  }\n}\n\n/**\n * An enum for the different shapes of blocks.\n * Contains information on what each type of block can do.\n */\nexport class BlockShape {\n  static Round = new BlockShape(false, false, true);\n  static Boolean = new BlockShape(false, false, true);\n  static Hat = new BlockShape(false, true, false);\n  static End = new BlockShape(true, false, false);\n  static Stack = new BlockShape(true, true, false);\n\n  static getBlockShape(workspaceBlock) {\n    if (workspaceBlock.edgeShape_ === 2) {\n      return BlockShape.Round;\n    } else if (workspaceBlock.edgeShape_ === 1) {\n      return BlockShape.Boolean;\n    } else if (workspaceBlock.startHat_) {\n      return BlockShape.Hat;\n    } else if (!workspaceBlock.nextConnection) {\n      return BlockShape.End;\n    } else {\n      return BlockShape.Stack;\n    }\n  }\n\n  constructor(canStackUp, canStackDown, canBeRound) {\n    /** @type {boolean} Can blocks be stacked above this block? */\n    this.canStackUp = canStackUp;\n    /** @type {boolean} Can blocks be stacked below this block? */\n    this.canStackDown = canStackDown;\n    /** @type {boolean} Does this block fit into a round hole? */\n    this.canBeRound = canBeRound;\n  }\n}\n\n/**\n * @typedef BlockCategory\n * @property {string} name\n * @property {string} colorPrimary\n * @property {string} colorSecondary\n * @property {string} colorTertiary\n */\n\n/**\n * A type of Scratch block, like 'move () steps'. Every instance of the 'move () steps'\n * block shares this type info.\n */\nexport class BlockTypeInfo {\n  /**\n   * @param {*} block Block in workspace form\n   * @param {*} vm\n   * @returns {BlockCategory} The block's category\n   */\n  static getBlockCategory(block, vm) {\n    let name;\n\n    if (block.type === \"procedures_call\") {\n      if (vm.getAddonBlock(block.getProcCode())) name = \"addon-custom-block\";\n      else name = \"more\";\n    } else if (block.usesDefaultExtensionColors) name = \"pen\";\n    else if (block.type === \"sensing_of\") name = \"sensing\";\n    else if (block.type === \"event_whenbackdropswitchesto\") name = \"events\";\n    else name = block.category_;\n\n    return {\n      name,\n      colorPrimary: block.colour_,\n      colorSecondary: block.colourSecondary_,\n      colorTertiary: block.colourTertiary_,\n    };\n  }\n\n  /**\n   * Enumerates all the different types of blocks, given a workspace.\n   * @param {Blockly} Blockly\n   * @param {*} vm\n   * @param {*} workspace\n   * @param {(string) => string} locale The translations used for converting icons into text\n   * @returns {BlockTypeInfo[]}\n   */\n  static getBlocks(Blockly, vm, workspace, locale) {\n    const flyoutWorkspace = workspace.getToolbox()?.flyout_.getWorkspace();\n    if (!flyoutWorkspace) return [];\n\n    const blocks = [];\n\n    const flyoutDom = Blockly.Xml.workspaceToDom(flyoutWorkspace);\n    const flyoutDomBlockMap = {};\n    for (const blockDom of flyoutDom.children) {\n      if (blockDom.tagName === \"BLOCK\") {\n        let id = blockDom.getAttribute(\"id\");\n        flyoutDomBlockMap[id] = blockDom;\n      }\n    }\n    for (const workspaceBlock of flyoutWorkspace.getTopBlocks()) {\n      blocks.push(\n        ...BlockTypeInfo._createBlocks(\n          workspace,\n          vm,\n          Blockly,\n          locale,\n          workspaceBlock,\n          flyoutDomBlockMap[workspaceBlock.id]\n        )\n      );\n    }\n\n    return blocks;\n  }\n\n  static _createBlocks(workspace, vm, Blockly, locale, workspaceForm, domForm) {\n    let parts = [];\n    let inputs = [];\n\n    const addInput = (input) => {\n      parts.push(input);\n      inputs.push(input);\n    };\n\n    const addFieldInputs = (field, inputIdx, fieldIdx) => {\n      if (field.className_ === \"blocklyText blocklyDropdownText\") {\n        const options = field.getOptions();\n        addInput(new BlockInputEnum(options, inputIdx, fieldIdx, fieldIdx === -1));\n      } else if (field instanceof Blockly.FieldImage) {\n        switch (field.src_.split(\"/\").pop()) {\n          case \"green-flag.svg\":\n            parts.push(locale(\"/_general/blocks/green-flag\"));\n            break;\n          case \"rotate-right.svg\":\n            parts.push(locale(\"/_general/blocks/clockwise\"));\n            break;\n          case \"rotate-left.svg\":\n            parts.push(locale(\"/_general/blocks/anticlockwise\"));\n            break;\n        }\n      } else {\n        if (!field.argType_) {\n          if (field.getText().trim().length !== 0) parts.push(field.getText());\n        } else if (field.argType_[0] === \"colour\") {\n          addInput(new BlockInputColour(inputIdx, fieldIdx));\n        } else if (field.argType_[1] === \"number\") {\n          addInput(new BlockInputNumber(inputIdx, fieldIdx, field.text_));\n        } else {\n          addInput(new BlockInputString(inputIdx, fieldIdx, field.text_));\n        }\n      }\n    };\n\n    for (let inputIdx = 0; inputIdx < workspaceForm.inputList?.length; inputIdx++) {\n      const input = workspaceForm.inputList[inputIdx];\n      for (let fieldIdx = 0; fieldIdx < input.fieldRow.length; fieldIdx++) {\n        addFieldInputs(input.fieldRow[fieldIdx], inputIdx, fieldIdx);\n      }\n\n      if (input.connection) {\n        const innerBlock = input.connection.targetBlock();\n        if (innerBlock) {\n          if (innerBlock.inputList.length !== 1 || innerBlock.inputList[0].fieldRow.length !== 1)\n            throw new Error(\"This should never happen.\");\n          let innerField = innerBlock.inputList[0].fieldRow[0];\n          addFieldInputs(innerField, inputIdx, -1);\n        } else {\n          if (input.outlinePath) {\n            addInput(new BlockInputBoolean(inputIdx, -1));\n          } else {\n            addInput(new BlockInputBlock(inputIdx, -1));\n          }\n        }\n      }\n    }\n\n    if (workspaceForm.id === \"of\") {\n      let blocks = [];\n\n      let baseVarInputIdx, baseTargetInputIdx;\n      // In most languages, the 'of' block inputs are: [variable] of [sprite], and in others\n      // it's the opposite (sprite then variable). We can tell that the variable comes first\n      // if the first input is round.\n      if (inputs[0].isRound) {\n        baseVarInputIdx = 1;\n        baseTargetInputIdx = 0;\n      } else {\n        baseVarInputIdx = 0;\n        baseTargetInputIdx = 1;\n      }\n\n      let baseVarInput = inputs[baseVarInputIdx];\n      let baseTargetInput = inputs[baseTargetInputIdx];\n\n      const baseVarPartIdx = parts.indexOf(baseVarInput);\n      const baseTargetPartIdx = parts.indexOf(baseTargetInput);\n\n      // Adapted from https://github.com/scratchfoundation/scratch-gui/blob/cc6e6324064493cf1788f3c7c0ff31e4057964ee/src/lib/blocks.js#L230\n      const stageOptions = [\n        [Blockly.Msg.SENSING_OF_BACKDROPNUMBER, \"backdrop #\"],\n        [Blockly.Msg.SENSING_OF_BACKDROPNAME, \"backdrop name\"],\n        [Blockly.Msg.SENSING_OF_VOLUME, \"volume\"],\n      ];\n\n      const spriteOptions = [\n        [Blockly.Msg.SENSING_OF_XPOSITION, \"x position\"],\n        [Blockly.Msg.SENSING_OF_YPOSITION, \"y position\"],\n        [Blockly.Msg.SENSING_OF_DIRECTION, \"direction\"],\n        [Blockly.Msg.SENSING_OF_COSTUMENUMBER, \"costume #\"],\n        [Blockly.Msg.SENSING_OF_COSTUMENAME, \"costume name\"],\n        [Blockly.Msg.SENSING_OF_SIZE, \"size\"],\n        [Blockly.Msg.SENSING_OF_VOLUME, \"volume\"],\n      ];\n\n      for (const targetInput of baseTargetInput.values) {\n        let options;\n        const isStage = targetInput.value === \"_stage_\";\n\n        if (isStage) {\n          const stageVariableOptions = vm.runtime.getTargetForStage().getAllVariableNamesInScopeByType(\"\");\n          options = stageVariableOptions.map((variable) => [variable, variable]).concat(stageOptions);\n        } else {\n          const sprite = vm.runtime.getSpriteTargetByName(targetInput.value);\n          const spriteVariableOptions = sprite.getAllVariableNamesInScopeByType(\"\", true);\n          options = spriteVariableOptions.map((variable) => [variable, variable]).concat(spriteOptions);\n        }\n\n        const ofInputs = [];\n        ofInputs[baseVarInputIdx] = new BlockInputEnum(options, baseVarInput.inputIdx, baseVarInput.fieldIdx, false);\n        ofInputs[baseTargetInputIdx] = new BlockInputEnum(\n          [[targetInput.string, targetInput.value]],\n          baseTargetInput.inputIdx,\n          baseTargetInput.fieldIdx,\n          isStage\n        );\n\n        const ofParts = [...parts];\n        ofParts[baseVarPartIdx] = ofInputs[baseVarInputIdx];\n        ofParts[baseTargetPartIdx] = ofInputs[baseTargetInputIdx];\n\n        blocks.push(new BlockTypeInfo(workspace, Blockly, vm, workspaceForm, domForm, ofParts, ofInputs));\n      }\n\n      return blocks;\n    } else if (workspaceForm.id === \"control_stop\") {\n      // This block is special because when \"other scripts in sprite\" is selected the block\n      //  needs to be BlockShape.End.\n      const oldInput = inputs[0];\n      const otherScriptsOptionIdx = oldInput.values.findIndex((option) => option.string === \"other scripts in sprite\");\n      const otherScriptsOption = oldInput.values.splice(otherScriptsOptionIdx, 1)[0];\n      const newInput = new BlockInputEnum(\n        [[otherScriptsOption.string, otherScriptsOption.value]],\n        oldInput.inputIdx,\n        oldInput.fieldIdx,\n        oldInput.isRound\n      );\n\n      const newBlockParts = [...parts];\n      newBlockParts[parts.indexOf(oldInput)] = newInput;\n\n      return [\n        new BlockTypeInfo(workspace, Blockly, vm, workspaceForm, domForm, parts, inputs, BlockShape.End),\n        new BlockTypeInfo(workspace, Blockly, vm, workspaceForm, domForm, newBlockParts, [newInput], BlockShape.Stack),\n      ];\n    } else {\n      return [new BlockTypeInfo(workspace, Blockly, vm, workspaceForm, domForm, parts, inputs)];\n    }\n  }\n\n  constructor(workspace, Blockly, vm, workspaceForm, domForm, parts, inputs, shape) {\n    /** @type {string} */\n    this.id = workspaceForm.id;\n    this.workspaceForm = workspaceForm;\n    this.domForm = domForm;\n    /** @type {BlockShape} */\n    this.shape = shape ?? BlockShape.getBlockShape(this.workspaceForm);\n    /** @type {BlockCategory} */\n    this.category = BlockTypeInfo.getBlockCategory(this.workspaceForm, vm);\n    this.workspace = workspace;\n    this.Blockly = Blockly;\n\n    /**\n     * A list of all the 'parts' of this block. Each part is either an instance\n     * of BlockInput or a string for some text which is a part of a block.\n     *\n     * For example, for the 'say' block, the first element of the array would be\n     * the string 'say', and the second element would be a BlockInput of type\n     * BlockInputString.\n     * @type {(BlockInput | string)[]}\n     */\n    this.parts = parts;\n    /**\n     * A list of all this block's inputs. The same as this.parts, but with the\n     * strings omitted.\n     * @type {BlockInput[]}\n     */\n    this.inputs = inputs;\n  }\n\n  /**\n   * Creates a block of this type with the given inputs\n   * @param  {...any} inputs\n   * @returns {BlockInstance}\n   */\n  createBlock(...inputs) {\n    return new BlockInstance(this, ...inputs);\n  }\n}\n","/**\n * @file Contains all the logic for the parsing of queries by the {@link WorkspaceQuerier}.\n * I'm really sorry if somebody other than me ever has to debug this.\n * Wish you luck <3\n *\n * Once you *think* you understand the function of the major classes, read the docs on\n * {@link WorkspaceQuerier._createTokenGroups} for some more specifics on the algorithm works,\n * and to achieve maximum enlightenment.\n *\n * @author Tacodiva\n */\n\nimport {\n  BlockInputType,\n  BlockInstance,\n  BlockShape,\n  BlockTypeInfo,\n  BlockInputEnum,\n  BlockInputString,\n} from \"./BlockTypeInfo.js\";\n\n/**\n *\n * A token is a part of a query that is interpreted in a specific way.\n *\n * In the query 'say 1 = Hello World', the base tokens are 'say', '1', '=, and 'Hello World'.\n * Each token contains where in the query it is located and what {@link TokenType} it is.\n *\n * Sometimes the same section of a query has multiple tokens because there are different\n * interpretations of what type of token it is. For example, imagine you had a variable named\n * 'x'. The query 'set x to 10', is ambiguous because you could be referring to the motion block\n * `set x to ()` or the data block `set [x] to ()`. This ambiguity results in two different\n * tokens being creating for 'x', one is 'set x to' referring to the motion block, and the other\n * is just 'x', referring to the variable.\n *\n * Calling this a 'token' is somewhat misleading, often language interpreters will have a 'parse tree'\n * with tokens and an 'abstract syntax tree' with higher level elements, but I have chosen to make these\n * two trees one in the same. Because of this, every token represents a logical part of a block.\n * Going back to the 'say 1 = Hello World' example, there are two 'parent' tokens, both are of type\n * {@link TokenTypeBlock}. The first is for the equals block, which contains three subtokens; '1',\n * '=' and 'Hello World'. The second is the say block, whos first child is 'say' and second child is\n * the token for the equals block (which itself has three children). For a query result to be valid,\n * it must have a token which encapsulates the entire query, in this case the say block token starts\n * at the first letter and ends at the last letter, so it's a valid interpretation. The token which\n * encapsulates the whole query is referred to as the root token.\n */\nclass Token {\n  /**\n   * @param {number} start\n   * @param {number} end\n   * @param {TokenType} type\n   * @param {*} value\n   * @param {number} precedence\n   * @param {boolean} isTruncated\n   * @param {boolean} isLegal\n   */\n  constructor(\n    start,\n    end,\n    type,\n    value,\n    { precedence = -1, isProper = true, isTruncated = false, isLegal = true, isDefiningFeature = false } = {}\n  ) {\n    /** @type {number} The index of the first letter of this token in the query */\n    this.start = start;\n    /** @type {number} The index of the last letter of this token in the query */\n    this.end = end;\n    /** @type {TokenType} The type of this token. */\n    this.type = type;\n    /** @type {*} Additional information about this token, controlled and interpreted by the token type. */\n    this.value = value;\n    /**\n     * The precedence of this token, used to implement order of operations. Tokens with a higher\n     * precedence should be evaluated *after* those with a lower precedence. Brackets have a\n     * precedence of 0 so they are always evaluated first. A precedence of -1 means that precedence\n     * is not specified and the parser makes no guarantees about the order of operations.\n     * @type {number}\n     */\n    this.precedence = precedence;\n    /**\n     * True if this token is fully written out. For example, in the query \"m v = 10\" where \"m v\"\n     * expands to \"my variable\", the token \"m v\" is not proper, as it is not fully written.\n     * Note that unlike trauncation, parent tokens do not inherit this property (so in the above\n     * example, the '=' block token would still be proper).\n     */\n    this.isProper = isProper;\n    /**\n     * Sometimes, tokens are truncated. Imagine the query 'say Hello for 10 se', here the last\n     * token should be 'seconds', but it's truncated. For this token, the isTruncated value is set\n     * to true. Additionally, the token for the whole block (which contains the tokens 'say', 'Hello',\n     * 'for', '10' and 'se') also has it's isTruncated value set to true, because it contains a\n     * truncated token.\n     * @type {boolean}\n     */\n    this.isTruncated = isTruncated;\n    /**\n     * Used to generate autocomplete text, even if that autocomplete text doesn't make a valid query\n     * by itself. For example in the query 'if my varia', we want to autocomplete to 'my variable',\n     * but the query 'if my variable' is still not valid, because my variable is not a boolean. In\n     * this case, the 'my variable' token would still be emitted as the second child of the 'if' token,\n     * but it would be marked as illegal.\n     */\n    this.isLegal = isLegal;\n    /**\n     * If we see this token, should we know what block it's connected to?\n     *\n     * For example, in the query 'say Hi', 'say' is a defining feature because\n     * we can narrow down what block it's from based only the fact that it's present.\n     * 'Hi', however, is not a defining feature as it could be a part of lots of\n     * different blocks.\n     *\n     * This is used to help eliminate some dodgey interpretations of queries, if a block\n     * has no subtokens marked a defining feature it's disguarded.\n     * @type {boolean}\n     */\n    this.isDefiningFeature = isDefiningFeature;\n  }\n\n  /**\n   * @see {TokenType.createBlockValue}\n   * @param {QueryInfo} query\n   * @returns\n   */\n  createBlockValue(query) {\n    return this.type.createBlockValue(this, query);\n  }\n}\n\n/**\n * The parent of any class that can enumerate tokens given a query and a location within that\n * query to search.\n *\n * As the same position in a query can have multiple interpretations (see {@link Token}), every\n * token provider's {@link parseTokens} method can return multiple tokens for the same index.\n *\n * Like tokens, there is a token provider tree. See {@link WorkspaceQuerier._createTokenGroups}\n * for more info on this tree.\n *\n * @abstract\n */\nclass TokenProvider {\n  constructor(shouldCache) {\n    if (this.constructor === TokenProvider) throw new Error(\"Abstract classes can't be instantiated.\");\n    /**\n     * Can the results of this token provider be stored? True\n     * if {@link parseTokens} will always return the same thing for the same inputs or if\n     * this token provider already caches it's result, so caching it again is redundant.\n     * @type {boolean}\n     */\n    this.shouldCache = shouldCache;\n  }\n\n  /**\n   * Return the tokens found by this token provider in `query` at character `idx`.\n   * @param {QueryInfo} query The query to search\n   * @param {number} idx The index to start the search at\n   * @param {number} depth The number of blocks this token is inside of.\n   *  For the query 1 + 1, the `+` block token would have a depth of 0 and the `1` tokens would have a depth of 1.\n   * @yields {Token} All the tokens found\n   * @abstract\n   */\n  // eslint-disable-next-line require-yield\n  *parseTokens(query, idx, depth) {\n    throw new Error(\"Sub-class must override abstract method.\");\n  }\n}\n\n/**\n * A token provider which wraps around another token provider, always returning a blank token in\n * addition to whatever the inner token provider returns.\n *\n * Used for tokens that can possibility be omitted, like numbers. For example, the '+' block always\n * needs three inputs, but the user could query '1 +'. In this case its subtokens are '1', '+' and\n * a {@link TokenTypeBlank}, provided by this provider.\n */\nclass TokenProviderOptional extends TokenProvider {\n  /**\n   * @param {TokenProvider} inner\n   */\n  constructor(inner) {\n    super(inner.shouldCache);\n    /** @type {TokenProvider} The inner token provider to return along with the blank token. */\n    this.inner = inner;\n  }\n\n  *parseTokens(query, idx, depth) {\n    yield TokenTypeBlank.INSTANCE.createToken(idx);\n    yield* this.inner.parseTokens(query, idx, depth);\n  }\n}\n\n/**\n * Caches the output of an inner token provider.\n * Used for tokens that are a part of multiple token provider groups.\n */\nclass TokenProviderSingleCache extends TokenProvider {\n  /**\n   * @param {TokenProvider} inner\n   */\n  constructor(inner) {\n    super(false);\n    /** @type {TokenProvider} */\n    this.inner = inner;\n    if (this.inner.shouldCache) {\n      /** @type {Token[]?} */\n      this.cache = [];\n      /** @type {number?} */\n      this.cacheQueryID = null;\n    }\n  }\n\n  *parseTokens(query, idx, depth) {\n    if (!this.inner.shouldCache) {\n      yield* this.inner.parseTokens(query, idx, depth);\n      return;\n    }\n    if (this.cacheQueryID !== query.id) {\n      this.cache = [];\n      this.cacheQueryID = query.id;\n    }\n    let cacheEntry = this.cache[idx];\n    if (cacheEntry) {\n      yield* cacheEntry;\n      return;\n    }\n    this.cache[idx] = cacheEntry = [];\n    for (const token of this.inner.parseTokens(query, idx, depth)) {\n      cacheEntry.push(token);\n      yield token;\n    }\n  }\n}\n\n/**\n * Collects multiple inner token providers into one token provider group.\n * Additionally, caches the results of all the cacheable inner token providers.\n */\nclass TokenProviderGroup extends TokenProvider {\n  constructor() {\n    // No need to cache this as it already caches it's own output.\n    super(false);\n    /** @type {TokenProvider[]} The providers that make up this group */\n    this.providers = [];\n    /** @type {TokenProvider[]} Providers that are a part of the group, but tokens they produce are illegal */\n    this.illegalProviders = [];\n    /** @type {Object<number, CacheEntry>?} The cache */\n    this.cache = null;\n    /** @type {number?} The query ID of the query whos results are currently cached */\n    this.cacheQueryID = null;\n    /** @type {boolean} Are any of our inner tokens cacheable? */\n    this.hasCacheable = false;\n  }\n\n  /**\n   * @typedef CacheEntry\n   * @property {Token[][]} tokenCaches\n   * @property {TokenProvider[][]} providerCaches\n   */\n\n  /**\n   * Adds token providers to this token provider group.\n   * @param {TokenProvider[]} providers\n   * @param {boolean} legal Are the results of this provider legal in the current context?\n   */\n  pushProviders(providers, legal = true) {\n    if (!this.hasCacheable)\n      for (const provider of providers) {\n        if (provider.shouldCache) {\n          this.hasCacheable = true;\n          break;\n        }\n      }\n    if (legal) this.providers.push(...providers);\n    else this.illegalProviders.push(...providers);\n  }\n\n  *parseTokens(query, idx, depth) {\n    // If none of our providers are cacheable, just parse all the tokens again\n    if (!this.hasCacheable) {\n      for (const provider of this.providers) yield* provider.parseTokens(query, idx, depth);\n      return;\n    }\n\n    // If the query ID has changed, the cache is no longer valid\n    if (this.cacheQueryID !== query.id) {\n      this.cache = [];\n      this.cacheQueryID = query.id;\n    } else {\n      // Otherwise, search for a cache entry for idx\n      const cacheEntry = this.cache[idx];\n      if (cacheEntry) {\n        // If we find one, yield all the cached results\n        const tokenCaches = cacheEntry.tokenCaches;\n        const providerCaches = cacheEntry.providerCaches;\n        for (let i = 0; i < tokenCaches.length; i++) {\n          const tokenCache = tokenCaches[i];\n          const providerCache = providerCaches[i];\n          for (const provider of providerCache) yield* provider.parseTokens(query, idx, depth);\n          yield* tokenCache;\n        }\n        return;\n      }\n    }\n\n    // No applicable cache entry was found :(\n    // Call all our child token providers and create a new cache entry\n\n    let tokenCache = [];\n    let providerCache = [];\n\n    const tokenCaches = [tokenCache];\n    const providerCaches = [providerCache];\n    this.cache[idx] = { tokenCaches, providerCaches };\n\n    for (const provider of this.providers) {\n      if (provider.shouldCache) {\n        for (const token of provider.parseTokens(query, idx, depth)) {\n          tokenCache.push(token);\n          yield token;\n        }\n      } else {\n        if (tokenCache.length !== 0) {\n          tokenCache = [];\n          providerCache = [];\n          tokenCaches.push(tokenCache);\n          providerCaches.push(providerCache);\n        }\n        providerCache.push(provider);\n        yield* provider.parseTokens(query, idx, depth);\n      }\n    }\n    for (const provider of this.illegalProviders) {\n      for (let token of provider.parseTokens(query, idx, depth)) {\n        token = { ...token, isLegal: false };\n        tokenCache.push(token);\n        yield token;\n      }\n    }\n  }\n}\n\n/**\n * A class representing the type of a token (see {@link Token.type})\n *\n * All token types extend from {@link TokenProvider} and they provide all the tokens\n * of their type they can find.\n *\n * @abstract\n */\nclass TokenType extends TokenProvider {\n  constructor(dontCache = false) {\n    super(!dontCache);\n\n    if (this.constructor === TokenType) throw new Error(\"Abstract classes can't be instantiated.\");\n\n    /** @type {boolean} Is this token type always represented by the same string of characters? */\n    this.isConstant = false;\n  }\n\n  /**\n   * Turns `token` into a value which can be passed into the {@link BlockInstance} constructor.\n   * For example, in string literal tokens, this gets the string value of the token which can then\n   * be used to create a block.\n   * @param {Token} token\n   * @param {QueryInfo} query\n   * @returns {*}\n   */\n  createBlockValue(token, query) {\n    return token.value;\n  }\n\n  /**\n   * Creates the string form of this token in the same format that was used in the query.\n   * If the token was only partially typed in the query, creating the text will complete the token.\n   * @param {Token} token\n   * @param {QueryInfo} query\n   * @param {boolean} endOnly Should we only append to the end of the query. If this is false, we\n   * can create text in the middle of the query that wasn't there. This is used to autocomplete\n   * {@link StringEnum.GriffTokenType} tokens in the middle of a query.\n   * @returns {string}\n   */\n  createText(token, query, endOnly) {\n    throw new Error(\"Sub-class must override abstract method.\");\n  }\n\n  /**\n   * @param {Token} token\n   * @param {QueryInfo} query\n   * @returns {Token[]}\n   */\n  getSubtokens(token, query) {\n    return undefined;\n  }\n}\n\n/**\n * The type for tokens that represent an omitted field.\n * Used by {@link TokenProviderOptional}\n */\nclass TokenTypeBlank extends TokenType {\n  static INSTANCE = new TokenTypeBlank();\n\n  constructor() {\n    super();\n    this.isConstant = true;\n  }\n\n  *parseTokens(query, idx, depth) {\n    yield this.createToken(idx);\n  }\n\n  /**\n   * Create a new blank token\n   * @param {number} idx The position of the blank token\n   * @returns {Token}\n   */\n  createToken(idx) {\n    return new Token(idx, idx, this, null);\n  }\n\n  createText(token, query) {\n    return \"\";\n  }\n}\n\n/**\n * Represents a token whos value must be one of a predetermined set of strings.\n * For example, a token for a dropdown menu (like the one in `set [my variable] to x`) is a\n * string enum, because the value must be one of a set of strings.\n *\n * String enums are also used for values that can only be one specific value (like the 'set' from\n * `set [my variable] to x`). These cases are just string enums with one possible value.\n */\nclass TokenTypeStringEnum extends TokenType {\n  /**\n   * @typedef StringEnumValue\n   * @property {string} value The string that needs to be in the query\n   * @property {string} lower Cached value.toLowerCase()\n   * @property {string[]} parts lower, split up by ignoreable characters.\n   */\n\n  /**\n   * @param {(import(\"./BlockTypeInfo\").BlockInputEnumOption[]} values\n   */\n  constructor(values) {\n    super();\n    this.isConstant = values.length === 1;\n\n    /** @type {StringEnumValue[]} */\n    this.values = [];\n    for (const value of values) {\n      let lower = value.string.toLowerCase();\n      const parts = [];\n      {\n        let lastPart = 0;\n        for (let i = 0; i <= lower.length; i++) {\n          const char = lower[i];\n          if (QueryInfo.IGNORABLE_CHARS.indexOf(char) !== -1 || !char) {\n            parts.push(lower.substring(lastPart, i));\n            i = QueryInfo.skipIgnorable(lower, i);\n            lastPart = i;\n          }\n        }\n      }\n      this.values.push({ lower, parts, value });\n    }\n  }\n\n  *parseTokens(query, idx, depth) {\n    for (let valueIdx = 0; valueIdx < this.values.length; valueIdx++) {\n      const valueInfo = this.values[valueIdx];\n      let yieldedToken = false;\n\n      const remainingChar = query.length - idx;\n      const substr = query.lowercase.substring(idx);\n\n      // If all we have is a string which could be a number, it doesn't count as a defining feature.\n      // This is to get rid of \"10\" constantly suggesting \"10 ^ of ()\"\n      let isDefiningFeature = !TokenTypeNumberLiteral.isValidNumber(substr);\n\n      if (remainingChar < valueInfo.lower.length) {\n        if (valueInfo.lower.startsWith(substr)) {\n          const end = remainingChar < 0 ? 0 : query.length;\n          yield new Token(idx, end, this, valueInfo, { isTruncated: true, isDefiningFeature });\n          yieldedToken = true;\n        }\n      } else {\n        if (query.lowercase.startsWith(valueInfo.lower, idx)) {\n          yield new Token(idx, idx + valueInfo.lower.length, this, valueInfo, { isDefiningFeature });\n          yieldedToken = true;\n        }\n      }\n    }\n  }\n\n  createBlockValue(token, query) {\n    return token.value.value;\n  }\n\n  createText(token, query, endOnly) {\n    if (!token) return this.values[0].lower;\n    return token.value.lower;\n  }\n}\n\n/**\n * The token type for a literal string, like 'Hello World' in the query `say Hello World`\n */\nclass TokenTypeStringLiteral extends TokenType {\n  static TERMINATORS = [undefined, \" \", \"+\", \"-\", \"*\", \"/\", \"=\", \"<\", \">\", \")\"];\n\n  static isTerminator(char) {\n    return this.TERMINATORS.includes(char);\n  }\n\n  /**\n   * Each time we encounter a 'terminator' we have to return the string we've read so far as a\n   * possible interpretation. If we didn't, when looking for a string at index 4 of 'say Hello\n   * World for 10 seconds' we would just return 'Hello World for 10 seconds', leading to the\n   * only result being `say \"Hello World for 10 seconds\"`. This also means in addition to\n   * 'Hello World' we also return 'Hello', 'Hello World for', 'Hello World for 10' and '\n   * Hello World for 10 seconds', but that's just the price we pay for trying to enumerate every\n   * interpretation.\n   */\n  *parseTokens(query, idx, depth) {\n    // First, look for strings in quotes\n    let quoteEnd = -1;\n    if (query.str[idx] === '\"' || query.str[idx] === \"'\") {\n      const quote = query.str[idx];\n      let value = \"\";\n      let valueStart = idx + 1;\n      for (let i = idx + 1; i <= query.length; i++) {\n        if (query.str[i] === \"\\\\\") {\n          value += query.str.substring(valueStart, i);\n          valueStart = ++i;\n        } else if (query.str[i] === quote) {\n          yield new Token(idx, i + 1, this, value + query.str.substring(valueStart, i));\n          quoteEnd = i + 1;\n          break;\n        }\n      }\n    }\n    // Then all the other strings\n    let wasTerminator = false;\n    let wasIgnorable = false;\n    for (let i = idx; i <= query.length; i++) {\n      const isTerminator = TokenTypeStringLiteral.isTerminator(query.str[i]);\n      const isIgnorable = QueryInfo.IGNORABLE_CHARS.includes(query.str[i]);\n      if ((wasTerminator !== isTerminator || i == query.length) && !wasIgnorable && i !== idx && i !== quoteEnd) {\n        const value = query.str.substring(idx, i);\n        yield new Token(idx, i, this, value);\n      }\n      wasTerminator = isTerminator;\n      wasIgnorable = isIgnorable;\n    }\n  }\n\n  createText(token, query, endOnly) {\n    return query.str.substring(token.start, token.end);\n  }\n}\n\n/**\n * The token type for a literal number, like 69 in the query 'Hello + 69'\n * This token type also supports numbers in formats scratch doesn't let you type,\n * but accepts like '0xFF', 'Infinity' or '1e3'.\n */\nclass TokenTypeNumberLiteral extends TokenType {\n  static isValidNumber(str) {\n    return !isNaN(+str) || !isNaN(parseFloat(+str));\n  }\n\n  *parseTokens(query, idx, depth) {\n    for (let i = idx; i <= query.length; i++) {\n      if (TokenTypeStringLiteral.isTerminator(query.str[i]) && i !== idx) {\n        const value = query.str.substring(idx, i);\n        if (TokenTypeNumberLiteral.isValidNumber(value)) {\n          yield new Token(idx, i, this, value);\n          break;\n        }\n      }\n    }\n  }\n\n  createText(token, query, endOnly) {\n    return query.str.substring(token.start, token.end);\n  }\n}\n\n/**\n * A token type for literal colors, like '#ffffff' for white.\n */\nclass TokenTypeColor extends TokenType {\n  static INSTANCE = new TokenProviderOptional(new TokenTypeColor());\n  static HEX_CHARS = [\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\"];\n\n  *parseTokens(query, idx, depth) {\n    if (!query.str.startsWith(\"#\", idx)) return;\n    for (let i = 0; i < 6; i++) {\n      if (TokenTypeColor.HEX_CHARS.indexOf(query.lowercase[idx + i + 1]) === -1) return;\n    }\n    yield new Token(idx, idx + 7, this, query.str.substring(idx, idx + 7));\n  }\n\n  createText(token, query, endOnly) {\n    return query.query.substring(token.start, token.end);\n  }\n}\n\n/**\n * A token type for tokens that are in brackets, like (1 + 1) in '(1 + 1) * 2'.\n */\nclass TokenTypeBrackets extends TokenType {\n  /**\n   * @param {TokenProvider} tokenProvider\n   */\n  constructor(tokenProvider) {\n    super();\n    /** @type {TokenProvider} The tokens to look for between the brackets */\n    this.tokenProvider = tokenProvider;\n  }\n\n  *parseTokens(query, idx, depth) {\n    const start = idx;\n    if (query.str[idx++] !== \"(\") return;\n    idx = query.skipIgnorable(idx);\n    for (const token of this.tokenProvider.parseTokens(query, idx, depth)) {\n      if (token.type instanceof TokenTypeBlank) continue; // Do not allow empty brackets like '()'\n      var tokenEnd = query.skipIgnorable(token.end);\n      let isTruncated = token.isTruncated;\n      if (!isTruncated) {\n        if (tokenEnd === query.length) isTruncated = true;\n        else if (query.str[tokenEnd] === \")\") ++tokenEnd;\n        else continue;\n      }\n      // Note that for bracket tokens, precedence = 0\n      const newToken = new Token(start, tokenEnd, this, token.value, {\n        precedence: 0,\n        isTruncated,\n        isLegal: token.isLegal,\n      });\n      newToken.innerToken = token;\n      yield newToken;\n    }\n  }\n\n  createBlockValue(token, query) {\n    return token.innerToken.createBlockValue(token.innerToken, query);\n  }\n\n  createText(token, query, endOnly) {\n    let text = \"(\";\n    text += query.str.substring(token.start + 1, token.innerToken.start);\n    text += token.innerToken.type.createText(token.innerToken, query, endOnly);\n    if (token.innerToken.end !== token.end) text += query.str.substring(token.innerToken.end, token.end - 1);\n    text += \")\";\n    return text;\n  }\n\n  getSubtokens(token, query) {\n    return [token.innerToken];\n  }\n}\n\n/**\n * The token type for a block, like 'say Hello' or '1 + 1'.\n */\nclass TokenTypeBlock extends TokenType {\n  /**\n   * @param {WorkspaceQuerier} querier\n   * @param {BlockTypeInfo} block\n   * @private\n   */\n  constructor(querier, block) {\n    super();\n    this.block = block;\n    this.hasSubTokens = true;\n    /**\n     * The list of token types that make up this block.\n     *\n     * For example, for the non-griff version of the 'say' block this array would contains two\n     * providers, the first is a {@link StringEnum.FullTokenType} containing only the value 'say'\n     * and the second is equal to querier.tokenGroupString.\n     *\n     * @type {TokenProvider[]}\n     */\n    this.fullTokenProviders = [];\n\n    for (const blockPart of block.parts) {\n      let fullTokenProvider;\n      if (typeof blockPart === \"string\") {\n        fullTokenProvider = new TokenTypeStringEnum([{ value: null, string: blockPart }]);\n      } else {\n        switch (blockPart.type) {\n          case BlockInputType.ENUM:\n            fullTokenProvider = new TokenTypeStringEnum(blockPart.values);\n            if (blockPart.isRound) {\n              const enumGroup = new TokenProviderGroup();\n              enumGroup.pushProviders([fullTokenProvider, querier.tokenGroupRoundBlocks]);\n              fullTokenProvider = enumGroup;\n            }\n            break;\n          case BlockInputType.STRING:\n            fullTokenProvider = querier.tokenGroupString;\n            break;\n          case BlockInputType.NUMBER:\n            fullTokenProvider = querier.tokenGroupNumber;\n            break;\n          case BlockInputType.COLOUR:\n            fullTokenProvider = TokenTypeColor.INSTANCE;\n            break;\n          case BlockInputType.BOOLEAN:\n            fullTokenProvider = querier.tokenGroupBoolean;\n            break;\n          case BlockInputType.BLOCK:\n            fullTokenProvider = querier.tokenGroupStack;\n            break;\n        }\n      }\n      this.fullTokenProviders.push(fullTokenProvider);\n    }\n\n    /**\n     * @type {{strings: string[], inputs: [], length: number}[]}\n     */\n    this.stringForms = [];\n\n    const enumerateStringForms = (partIdx = 0, strings = [], inputs = [], length = 0) => {\n      for (; partIdx < block.parts.length; partIdx++) {\n        let blockPart = block.parts[partIdx];\n        if (typeof blockPart === \"string\") {\n          length += blockPart.length;\n          strings.push(...blockPart.toLowerCase().split(\" \"));\n        } else if (blockPart.type === BlockInputType.ENUM) {\n          for (const enumValue of blockPart.values) {\n            enumerateStringForms(\n              partIdx + 1,\n              [...strings, ...enumValue.string.toLowerCase().split(\" \")],\n              [...inputs, enumValue],\n              length + enumValue.string.length\n            );\n          }\n          return;\n        } else {\n          inputs.push(null);\n        }\n      }\n      this.stringForms.push({ strings, inputs, length });\n    };\n\n    enumerateStringForms();\n  }\n\n  /**\n   * @param {QueryInfo} query\n   * @param {number} idx\n   * @param {number} depth\n   * @returns\n   */\n  *parseTokens(query, idx, depth) {\n    if (depth !== 0 && !query.canCreateMoreNestedBlocks()) return;\n\n    let yieldedTokens = false;\n\n    for (const subtokens of this._parseSubtokens(query, idx, this.fullTokenProviders)) {\n      let token = this._createToken(query, idx, this.fullTokenProviders, subtokens);\n      if (token) {\n        yield token;\n        yieldedTokens = true;\n      }\n    }\n\n    if (yieldedTokens) return;\n\n    outer: for (const stringForm of this.stringForms) {\n      let lastPartIdx = -1;\n      let i = idx;\n      let hasDefiningFeature = false;\n\n      while (true) {\n        i = query.skipIgnorable(i);\n\n        const wordEnd = query.skipUnignorable(i);\n\n        if (wordEnd === i) {\n          if (hasDefiningFeature)\n            yield new Token(idx, wordEnd, this, { stringForm, lastPartIdx: -1 }, { isProper: false });\n          break;\n        } else {\n          const word = query.lowercase.substring(i, wordEnd);\n          let match = -1;\n\n          for (let formPartIdx = lastPartIdx + 1; formPartIdx < stringForm.strings.length; formPartIdx++) {\n            const stringFormPart = stringForm.strings[formPartIdx];\n\n            if (stringFormPart.startsWith(word)) {\n              match = formPartIdx;\n              break;\n            }\n          }\n\n          if (match === -1) continue outer;\n          lastPartIdx = match;\n\n          hasDefiningFeature ||= !TokenTypeNumberLiteral.isValidNumber(word);\n\n          if (query.skipIgnorable(wordEnd) < query.length) {\n            if (hasDefiningFeature)\n              yield new Token(idx, wordEnd, this, { stringForm, lastPartIdx, i }, { isProper: false });\n          }\n          i = wordEnd;\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   * @param {QueryInfo} query\n   * @param {number} idx\n   * @param {TokenProvider[]} subtokenProviders\n   * @param {Token[]} subtokens\n   * @returns {Token?}\n   */\n  _createToken(query, idx, subtokenProviders, subtokens) {\n    subtokens.reverse();\n    let isLegal = true;\n    let isTruncated = subtokens.length < subtokenProviders.length;\n    let hasDefiningFeature = false;\n\n    for (const subtoken of subtokens) {\n      isTruncated |= subtoken.isTruncated; // If any of our kids are truncated, so are we\n      isLegal &&= subtoken.isLegal; // If any of our kids are illegal, so are we\n      if (subtoken.isDefiningFeature && subtoken.start < query.length) hasDefiningFeature = true;\n    }\n\n    /** See {@link Token.isDefiningFeature} */\n    if (!hasDefiningFeature) return null;\n\n    const end = query.skipIgnorable(subtokens[subtokens.length - 1].end);\n    return new Token(idx, end, this, { subtokens }, { precedence: this.block.precedence, isTruncated, isLegal });\n  }\n\n  /**\n   * Parse all the tokens from this.tokenProviders[tokenProviderIdx] then\n   * recursively call this for the next token. Returns a list of tokens for\n   * each combination of possible interpretations of the subtokens.\n   *\n   * Note that the tokens in the returned token arrays are in reverse to the\n   * order of their providers in this.tokenProviders, just to confuse you :P\n   *\n   * @private\n   * @param {QueryInfo} query\n   * @param {number} idx\n   * @param {TokenProvider[]} subtokenProviders\n   * @param {number} depth\n   * @param {number} tokenProviderIdx\n   * @param {boolean} parseNextToken\n   * @yields {Token[]}\n   */\n  *_parseSubtokens(query, idx, subtokenProviders, depth, tokenProviderIdx = 0, parseNextToken = true) {\n    idx = query.skipIgnorable(idx);\n    let tokenProvider = subtokenProviders[tokenProviderIdx];\n\n    for (const token of tokenProvider.parseTokens(query, idx, depth + 1)) {\n      ++query.tokenCount;\n\n      if (!query.canCreateMoreTokens()) break;\n      if (depth !== 0 && !query.canCreateMoreNestedBlocks()) break;\n\n      if (this.block.precedence !== -1) {\n        if (\n          // If we care about the precedence of this block\n          // Discard this token if its precedence is higher than ours, meaning it should be calculated\n          //  before us not afterward.\n          token.precedence > this.block.precedence &&\n          // See https://github.com/ScratchAddons/ScratchAddons/issues/5981\n          (tokenProviderIdx === 0 || !(token.type instanceof TokenTypeBlock) || token.type.block.id !== \"operator_not\")\n        )\n          continue;\n        /**\n         * This check eliminates thousands of results by making sure blocks with equal precedence\n         * can only contain themselves as their own first input. Without this, the query '1 + 2 + 3'\n         * would have two interpretations '(1 + 2) + 3' and '1 + (2 + 3)'. This rule makes the second\n         * of those invalid because the root '+' block contains itself as its third token.\n         */\n        if (token.precedence === this.block.precedence) {\n          const inputIndex = this.block.parts[tokenProviderIdx].inputIdx;\n          if (inputIndex !== 0) continue;\n        }\n      }\n\n      if (!parseNextToken || !token.isLegal || tokenProviderIdx === subtokenProviders.length - 1) {\n        yield [token];\n      } else {\n        for (const subTokenArr of this._parseSubtokens(\n          query,\n          token.end,\n          subtokenProviders,\n          depth,\n          tokenProviderIdx + 1,\n          !token.isTruncated\n        )) {\n          subTokenArr.push(token);\n          yield subTokenArr;\n        }\n      }\n    }\n  }\n\n  createBlockValue(token, query) {\n    if (!token.isLegal) throw new Error(\"Cannot create a block from an illegal token.\");\n    let blockInputs;\n\n    if (token.value.stringForm) {\n      blockInputs = token.value.stringForm.inputs;\n    } else {\n      const subtokens = token.value.subtokens;\n      blockInputs = [];\n      for (let i = 0; i < subtokens.length; i++) {\n        const blockPart = this.block.parts[i];\n        if (typeof blockPart !== \"string\") blockInputs.push(subtokens[i].createBlockValue(query));\n      }\n      while (blockInputs.length < this.block.inputs.length) blockInputs.push(null);\n    }\n\n    return this.block.createBlock(...blockInputs);\n  }\n\n  createText(token, query, endOnly) {\n    if (token.value.stringForm) {\n      if (endOnly) {\n        if (token.value.lastPartIdx === -1 || token.end <= query.length) {\n          return query.str.substring(token.start, token.end);\n        } else {\n          return (\n            query.str.substring(token.start, token.end) +\n            token.value.stringForm.strings[token.value.lastPartIdx].substring(token.end - token.value.i) +\n            \" \" +\n            token.value.stringForm.strings.slice(token.value.lastPartIdx + 1).join(\" \")\n          );\n        }\n      }\n\n      return token.value.stringForm.strings.join(\" \");\n    }\n    if (!token.isTruncated && endOnly) return query.str.substring(token.start, token.end);\n    const subtokens = token.value.subtokens;\n    let text = \"\";\n    if (token.start !== subtokens[0].start) {\n      text += query.str.substring(token.start, subtokens[0].start);\n    }\n    let i;\n    for (i = 0; i < subtokens.length; i++) {\n      const subtoken = subtokens[i];\n      if (!token.isLegal && subtoken.start >= query.length) break;\n      const subtokenText = subtoken.type.createText(subtoken, query, endOnly) ?? \"\";\n      text += subtokenText;\n      if (i !== subtokens.length - 1) {\n        const next = subtokens[i + 1];\n        const nextStart = next.start;\n        if (nextStart !== subtoken.end) {\n          text += query.str.substring(subtoken.end, nextStart);\n        } else {\n          if (\n            (!endOnly || nextStart >= query.length) &&\n            subtokenText.length !== 0 &&\n            QueryInfo.IGNORABLE_CHARS.indexOf(subtokenText.at(-1)) === -1\n          )\n            text += \" \";\n        }\n      }\n    }\n    return text;\n  }\n\n  getSubtokens(token, query) {\n    return token.value.subtokens;\n  }\n}\n\n/**\n * A single interpretation of a query.\n */\nexport class QueryResult {\n  constructor(query, token) {\n    /**\n     * The query that this is a result of.\n     * @type {QueryInfo}\n     */\n    this.query = query;\n    /**\n     * The root token of this result.\n     *\n     * The root token is a token which encapsules the entire query.\n     * @type {Token}\n     */\n    this.token = token;\n  }\n\n  get isTruncated() {\n    return this.token.isTruncated;\n  }\n\n  /**\n   * @param {boolean} endOnly\n   * @returns {string}\n   */\n  toText(endOnly) {\n    return this.token.type.createText(this.token, this.query, endOnly) ?? \"\";\n  }\n\n  /**\n   * @returns {BlockInstance}\n   */\n  getBlock() {\n    if (!this.block) this.block = this.token.createBlockValue(this.query);\n    return this.block;\n  }\n\n  /**\n   * @returns {{stringLength: number, tokenLength: number}}\n   */\n  getLengths() {\n    if (this.lengths) return this.lengths;\n\n    let stringLength = 0;\n    let tokenLength = 0;\n\n    /** @type {(block: BlockInstance) => void} */\n    const getBlockLengths = (block) => {\n      let inputIdx = 0;\n\n      for (const part of block.typeInfo.parts) {\n        ++tokenLength;\n\n        if (typeof part === \"string\") {\n          stringLength += part.length;\n        } else {\n          const input = block.inputs[inputIdx++];\n          if (input instanceof BlockInstance) {\n            getBlockLengths(input);\n          } else if (part instanceof BlockInputEnum) {\n            stringLength += input.string.length;\n          } else if (part instanceof BlockInputString && input !== part.defaultValue) {\n            // Make string inputs 100x their real length so they appear at the bottom\n            stringLength += (\"\" + input).length * 100;\n          } else if (input != null) {\n            stringLength += (\"\" + input).length;\n          }\n        }\n      }\n\n      // Account for the spaces between inputs\n      stringLength += block.typeInfo.parts.length - 1;\n    };\n\n    getBlockLengths(this.getBlock());\n    return (this.lengths = { stringLength, tokenLength });\n  }\n}\n\n/**\n * Information on the current query being executed, with some utility\n * functions for helping out token providers.\n */\nclass QueryInfo {\n  /** Characters that can be safely skipped over. */\n  static IGNORABLE_CHARS = [\" \"];\n\n  constructor(querier, query, id) {\n    /** @type {WorkspaceQuerier} */\n    this.querier = querier;\n    /** @type {string} The query */\n    this.str = query.replaceAll(String.fromCharCode(160), \" \");\n    /** @type {string} A lowercase version of the query. Used for case insensitive comparisons. */\n    this.lowercase = this.str.toLowerCase();\n    /** @type {number} A unique identifier for this query */\n    this.id = id;\n    /** @type {number} The number of tokens we've found so far */\n    this.tokenCount = 0;\n    /** @type {number} The number of query results we've found so far */\n    this.resultCount = 0;\n  }\n\n  /**\n   * @param {string} str\n   * @param {number} idx The index to start at.\n   * @returns {number} The index of the next non-ignorable character in str, after idx.\n   */\n  static skipIgnorable(str, idx) {\n    while (QueryInfo.IGNORABLE_CHARS.indexOf(str[idx]) !== -1) ++idx;\n    return idx;\n  }\n\n  /**\n   * @param {number} idx The index to start at.\n   * @returns {number} The index of the next non-ignorable character in the query, after idx.\n   */\n  skipIgnorable(idx) {\n    return QueryInfo.skipIgnorable(this.lowercase, idx);\n  }\n\n  /**\n   * @param {string} str\n   * @param {number} idx The index to start at.\n   * @returns {number} The index of the next ignorable character in str, after idx.\n   */\n  static skipUnignorable(str, idx) {\n    while (QueryInfo.IGNORABLE_CHARS.indexOf(str[idx]) === -1 && idx < str.length) ++idx;\n    return idx;\n  }\n\n  /**\n   * @param {number} idx The index to start at.\n   * @returns {number} The index of the next ignorable character in the query, after idx.\n   */\n  skipUnignorable(idx) {\n    return QueryInfo.skipUnignorable(this.lowercase, idx);\n  }\n\n  /** @type {number} The length in characters of the query. */\n  get length() {\n    return this.str.length;\n  }\n\n  canCreateMoreTokens() {\n    return this.tokenCount < WorkspaceQuerier.MAX_TOKENS;\n  }\n\n  canCreateMoreNestedBlocks() {\n    return this.canCreateMoreTokens() && this.resultCount < WorkspaceQuerier.MAX_RESULTS;\n  }\n}\n\n/**\n * Workspace queriers keep track of all the data needed to query a given workspace (referred to as\n * the 'workspace index') and provides the methods to execute queries on the indexed workspace.\n */\nexport default class WorkspaceQuerier {\n  static ORDER_OF_OPERATIONS = [\n    null, // brackets\n    \"operator_join\",\n    \"operator_round\",\n    \"operator_mathop\",\n    \"operator_mod\",\n    \"operator_divide\",\n    \"operator_multiply\",\n    \"operator_subtract\",\n    \"operator_add\",\n    \"operator_equals\",\n    \"operator_lt\",\n    \"operator_gt\",\n    \"operator_or\",\n    \"operator_and\",\n    \"operator_not\",\n  ];\n\n  /**\n   * The maximum number of results to find before we give up searching sub-blocks.\n   */\n  static MAX_RESULTS = 2000;\n\n  /**\n   * The maximum number of tokens to find before giving up.\n   */\n  static MAX_TOKENS = 10000;\n\n  /**\n   * Indexes a workspace in preparation for querying it.\n   * @param {BlockTypeInfo[]} blocks The list of blocks in the workspace.\n   */\n  indexWorkspace(blocks) {\n    this._queryCounter = 0;\n    this._createTokenGroups();\n    this._populateTokenGroups(blocks);\n    this.workspaceIndexed = true;\n  }\n\n  /**\n   * Queries the indexed workspace for blocks matching the query string.\n   * @param {string} queryStr The query.\n   * @returns {{results: QueryResult[], illegalResult: QueryResult | null, limited: boolean}} A list of the results of the query, sorted by their relevance.\n   */\n  queryWorkspace(queryStr) {\n    if (!this.workspaceIndexed) throw new Error(\"A workspace must be indexed before it can be queried!\");\n    if (queryStr.trim().length === 0) return { results: [], illegalResult: null, limited: false };\n\n    const query = new QueryInfo(this, queryStr, this._queryCounter++);\n    const results = [];\n    let foundTokenCount = 0;\n    let limited = false;\n\n    let bestIllegalResult = null;\n    let bestIllegalResultText = \"\";\n\n    for (const option of this.tokenGroupBlocks.parseTokens(query, 0, 0)) {\n      if (option.end >= queryStr.length) {\n        if (option.isLegal) {\n          results.push(new QueryResult(query, option));\n        } else {\n          const text = option.type.createText(option, query, true);\n          if (!bestIllegalResult || text.length < text) {\n            bestIllegalResult = new QueryResult(query, option);\n            bestIllegalResultText = text;\n          }\n        }\n      }\n      ++query.resultCount;\n      if (!limited && query.resultCount >= WorkspaceQuerier.MAX_RESULTS) {\n        console.log(\"Warning: Workspace query exceeded maximum result count.\");\n        limited = true;\n      }\n\n      if (!query.canCreateMoreTokens()) {\n        console.log(\"Warning: Workspace query exceeded maximum token count.\");\n        limited = true;\n        break;\n      }\n    }\n\n    // Used to eliminate blocks whos strings can be parsed as something else.\n    //  This step removes silly suggestions like `if <(1 + 1) = \"2 then\"> then`\n    const canBeString = Array(queryStr.length).fill(true);\n\n    function searchToken(token) {\n      const subtokens = token.type.getSubtokens(token, query);\n      if (subtokens) for (const subtoken of subtokens) searchToken(subtoken);\n      else if (!(token.type instanceof TokenTypeStringLiteral) && token.isProper && !token.isTruncated)\n        for (let i = token.start; i < token.end; i++) {\n          canBeString[i] = false;\n        }\n    }\n    for (const result of results) searchToken(result.token);\n\n    function checkValidity(token) {\n      const subtokens = token.type.getSubtokens(token, query);\n      if (subtokens) {\n        for (const subtoken of subtokens) if (!checkValidity(subtoken)) return false;\n      } else if (token.type instanceof TokenTypeStringLiteral && !TokenTypeNumberLiteral.isValidNumber(token.value)) {\n        for (let i = token.start; i < token.end; i++) if (!canBeString[i]) return false;\n      }\n      return true;\n    }\n    let validResults = [];\n    for (const result of results) if (checkValidity(result.token)) validResults.push(result);\n\n    validResults = validResults.sort((a, b) => {\n      const aLengths = a.getLengths();\n      const bLengths = b.getLengths();\n      if (aLengths.stringLength != bLengths.stringLength) return aLengths.stringLength - bLengths.stringLength;\n      return aLengths.tokenLength - bLengths.tokenLength;\n    });\n\n    return {\n      results: validResults,\n      illegalResult: validResults.length === 0 ? bestIllegalResult : null,\n      limited,\n    };\n  }\n\n  /**\n   * Creates the token group hierarchy used by this querier.\n   *\n   * Each of these token groups represents a list of all the tokens that could be encountered\n   * when we're looking for a specific type of input. For example, tokenGroupString contains all\n   * the tokens that could be encountered when we're looking for a string input (like after the\n   * word 'say' for the `say ()` block). tokenGroupBlocks is an interesting one, it contains all\n   * the tokens that could be the root token of a query result. In practice, this just means all\n   * the stackable blocks (like 'say') and all the reporter blocks (like '+').\n   *\n   * But wait, there's a problem. Blocks like `() + ()` have two inputs, both of which are numbers.\n   * The issue arises when you realize the block '+' itself also returns a number. So when we\n   * try to call parseTokens on the '+' block, it will try to look for it's first parameter thus\n   * calling parseTokens on tokenGroupNumber, which will call parseTokens on the '+' block again\n   * (because + can return a number) which will call tokenGroupNumber again... and we're in an\n   * infinite loop. We can't just exclude blocks from being their own first parameter because then\n   * queries like '1 + 2 + 3' wouldn't work. The solution is something you might have only thought\n   * of as a performance boost; caching. When tokenGroupNumber gets queried for the second time,\n   * it's mid way though building its cache from the first query. If this happens, it just returns\n   * all the tokens it had already found, but no more. So in the example above, when the + block calls\n   * tokenGroupNumber for the second time it finds only the number literal '1'. It then finds the\n   * second number literal '2' and yields the block '1 + 2' which gets added to tokenGroupNumber's\n   * cache. '1 + 2' then gets disguarded by the queryWorkspace function because it doesn't cover the\n   * whole query. But the '+' block's query to tokenGroupNumber never finished, so it will continue\n   * and, because the first one we found is now a part of the cache, tokenGroupNumber will yield\n   * '1 + 2' as a result. The + block will continue parsing, find the second '+' and the number '3'\n   * and yield '(1 + 2) + 3'. No infinite loops!\n   *\n   * A consequence of this system is something I implicitly implied in the above paragraph \"when the\n   * + block calls tokenGroupNumber for the second time it finds only the number literal '1'\" This\n   * is only true if 'TokenTypeNumberLiteral' is searched before the '+' block. This is why the order\n   * the token providers are in is critically important. I'll leave it as an exercise to the reader to\n   * work out why, but the same parsing order problems crops up when implementing order of operations.\n   * If a suggestion that should show up isn't showing up, it's probably because the token providers\n   * in one of the groups is in the wrong order. Ordering the providers within the base groups is dealt\n   * with by {@link _populateTokenGroups} and the inter-group ordering is dealt with below, by the\n   * order they are passed into pushProviders.\n   *\n   * @private\n   */\n  _createTokenGroups() {\n    this.tokenTypeStringLiteral = new TokenProviderSingleCache(new TokenTypeStringLiteral());\n    this.tokenTypeNumberLiteral = new TokenProviderSingleCache(new TokenTypeNumberLiteral());\n\n    this.tokenGroupRoundBlocks = new TokenProviderGroup(); // Round blocks like (() + ()) or (my variable)\n    this.tokenGroupBooleanBlocks = new TokenProviderGroup(); // Boolean blocks like <not ()>\n    this.tokenGroupStackBlocks = new TokenProviderGroup(); // Stackable blocks like `move (10) steps`\n    this.tokenGroupHatBlocks = new TokenProviderGroup(); // Hat block like `when green flag clicked`\n\n    // Anything that fits into a boolean hole. (Boolean blocks + Brackets)\n    this.tokenGroupBoolean = new TokenProviderOptional(new TokenProviderGroup());\n    this.tokenGroupBoolean.inner.pushProviders([\n      this.tokenGroupBooleanBlocks,\n      new TokenTypeBrackets(this.tokenGroupBoolean),\n    ]);\n    this.tokenGroupBoolean.inner.pushProviders([this.tokenGroupRoundBlocks], false);\n\n    // Anything that fits into a number hole. (Round blocks + Boolean blocks + Number Literals + Brackets)\n    this.tokenGroupNumber = new TokenProviderOptional(new TokenProviderGroup());\n    this.tokenGroupNumber.inner.pushProviders([\n      this.tokenTypeNumberLiteral,\n      this.tokenGroupRoundBlocks,\n      this.tokenGroupBooleanBlocks,\n      new TokenTypeBrackets(this.tokenGroupNumber),\n    ]);\n\n    // Anything that fits into a string hole (Round blocks + Boolean blocks + String Literals + Brackets)\n    this.tokenGroupString = new TokenProviderOptional(new TokenProviderGroup());\n    this.tokenGroupString.inner.pushProviders([\n      this.tokenTypeStringLiteral,\n      this.tokenGroupRoundBlocks,\n      this.tokenGroupBooleanBlocks,\n      new TokenTypeBrackets(this.tokenGroupString),\n    ]);\n\n    // Anything that fits into a c shaped hole (Stackable blocks)\n    this.tokenGroupStack = new TokenProviderOptional(this.tokenGroupStackBlocks);\n\n    // Anything you can spawn using the menu (All blocks)\n    this.tokenGroupBlocks = new TokenProviderGroup();\n    this.tokenGroupBlocks.pushProviders([\n      this.tokenGroupStackBlocks,\n      this.tokenGroupBooleanBlocks,\n      this.tokenGroupRoundBlocks,\n      this.tokenGroupHatBlocks,\n    ]);\n  }\n\n  /**\n   * Populates the token groups created by {@link _createTokenGroups} with the blocks\n   * found in the workspace.\n   * @param {BlockTypeInfo[]} blocks The list of blocks in the workspace.\n   * @private\n   */\n  _populateTokenGroups(blocks) {\n    // Apply order of operations\n    for (const block of blocks) {\n      block.precedence = WorkspaceQuerier.ORDER_OF_OPERATIONS.indexOf(block.id);\n    }\n    for (let i = blocks.length - 1; i >= 0; i--) {\n      const block = blocks[i];\n      if (block.precedence !== -1) {\n        const target = blocks.length - (WorkspaceQuerier.ORDER_OF_OPERATIONS.length - (block.precedence - 1));\n        if (i !== target) {\n          const oldBlock = blocks[target];\n          blocks[target] = block;\n          blocks[i] = oldBlock;\n        }\n      }\n    }\n\n    for (const block of blocks) {\n      const blockTokenType = new TokenTypeBlock(this, block);\n      switch (block.shape) {\n        case BlockShape.Round:\n          this.tokenGroupRoundBlocks.pushProviders([blockTokenType]);\n          break;\n        case BlockShape.Boolean:\n          this.tokenGroupBooleanBlocks.pushProviders([blockTokenType]);\n          break;\n        case BlockShape.Stack:\n        case BlockShape.End:\n          this.tokenGroupStackBlocks.pushProviders([blockTokenType]);\n          break;\n        case BlockShape.Hat:\n          this.tokenGroupHatBlocks.pushProviders([blockTokenType]);\n          break;\n      }\n    }\n  }\n\n  /**\n   * Clears the memory used by the workspace index.\n   */\n  clearWorkspaceIndex() {\n    this.workspaceIndexed = false;\n    this._destroyTokenGroups();\n  }\n\n  /**\n   * @private\n   */\n  _destroyTokenGroups() {\n    this.tokenTypeStringLiteral = null;\n    this.tokenTypeNumberLiteral = null;\n\n    this.tokenGroupBooleanBlocks = null;\n    this.tokenGroupRoundBlocks = null;\n    this.tokenGroupStackBlocks = null;\n    this.tokenGroupHatBlocks = null;\n    this.tokenGroupBoolean = null;\n    this.tokenGroupNumber = null;\n    this.tokenGroupString = null;\n    this.tokenGroupStack = null;\n    this.tokenGroupBlocks = null;\n  }\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./userstyle.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"userstyle.css\": _css,\n};\n","import EventTarget from \"../../event-target.js\"; /* inserted by pull.js */\n\nconst textWidthCache = new Map();\nconst textWidthCacheSize = 1000;\n\nconst eventTarget = new EventTarget();\nconst eventClearTextCache = \"clearTextCache\";\n\n/**\n * Gets the width of an svg text element, with caching.\n * @param {SVGTextElement} textElement\n */\nexport function getTextWidth(textElement) {\n  let string = textElement.innerHTML;\n  if (string.length === 0) return 0;\n  let width = textWidthCache.get(string);\n  if (width) return width;\n  width = textElement.getBoundingClientRect().width;\n  textWidthCache.set(string, width);\n  if (textWidthCache.size > textWidthCacheSize) {\n    textWidthCache.delete(textWidthCache.keys().next());\n  }\n  return width;\n}\n\n/**\n * Clears the text width cache of the middle click popup.\n */\nexport function clearTextWidthCache() {\n  textWidthCache.clear();\n  eventTarget.dispatchEvent(new CustomEvent(eventClearTextCache));\n}\n\n/**\n * @param {() => void} func\n */\nexport function onClearTextWidthCache(func) {\n  eventTarget.addEventListener(eventClearTextCache, func);\n}\n","//@ts-check\n\nimport WorkspaceQuerier, { QueryResult } from \"./WorkspaceQuerier.js\";\nimport renderBlock, { BlockComponent, getBlockHeight } from \"./BlockRenderer.js\";\nimport { BlockInstance, BlockShape, BlockTypeInfo } from \"./BlockTypeInfo.js\";\nimport { onClearTextWidthCache } from \"./module.js\";\n\nexport default async function ({ addon, msg, console }) {\n  const Blockly = await addon.tab.traps.getBlockly();\n  const vm = addon.tab.traps.vm;\n\n  const PREVIEW_LIMIT = 50;\n\n  const popupRoot = document.body.appendChild(document.createElement(\"div\"));\n  popupRoot.classList.add(\"sa-mcp-root\");\n  popupRoot.dir = addon.tab.direction;\n  popupRoot.style.display = \"none\";\n\n  const popupContainer = popupRoot.appendChild(document.createElement(\"div\"));\n  popupContainer.classList.add(\"sa-mcp-container\");\n\n  const popupInputContainer = popupContainer.appendChild(document.createElement(\"div\"));\n  popupInputContainer.classList.add(addon.tab.scratchClass(\"input_input-form\"));\n  popupInputContainer.classList.add(\"sa-mcp-input-wrapper\");\n\n  const popupInputSuggestion = popupInputContainer.appendChild(document.createElement(\"input\"));\n  popupInputSuggestion.classList.add(\"sa-mcp-input-suggestion\");\n\n  const popupInput = popupInputContainer.appendChild(document.createElement(\"input\"));\n  popupInput.classList.add(\"sa-mcp-input\");\n  popupInput.setAttribute(\"autocomplete\", \"off\");\n\n  const popupPreviewContainer = popupContainer.appendChild(document.createElement(\"div\"));\n  popupPreviewContainer.classList.add(\"sa-mcp-preview-container\");\n\n  const popupPreviewScrollbarSVG = popupContainer.appendChild(\n    document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\n  );\n  popupPreviewScrollbarSVG.classList.add(\n    \"sa-mcp-preview-scrollbar\",\n    \"blocklyScrollbarVertical\",\n    \"blocklyMainWorkspaceScrollbar\"\n  );\n  popupPreviewScrollbarSVG.style.display = \"none\";\n\n  const popupPreviewScrollbarBackground = popupPreviewScrollbarSVG.appendChild(\n    document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\")\n  );\n  popupPreviewScrollbarBackground.setAttribute(\"width\", \"11\");\n  popupPreviewScrollbarBackground.classList.add(\"blocklyScrollbarBackground\");\n\n  const popupPreviewScrollbarHandle = popupPreviewScrollbarSVG.appendChild(\n    document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\")\n  );\n  popupPreviewScrollbarHandle.setAttribute(\"rx\", \"3\");\n  popupPreviewScrollbarHandle.setAttribute(\"ry\", \"3\");\n  popupPreviewScrollbarHandle.setAttribute(\"width\", \"6\");\n  popupPreviewScrollbarHandle.setAttribute(\"x\", \"2.5\");\n  popupPreviewScrollbarHandle.classList.add(\"blocklyScrollbarHandle\");\n\n  const popupPreviewBlocks = popupPreviewContainer.appendChild(\n    document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\")\n  );\n  popupPreviewBlocks.classList.add(\"sa-mcp-preview-blocks\");\n\n  const querier = new WorkspaceQuerier();\n\n  let mousePosition = { x: 0, y: 0 };\n  document.addEventListener(\"mousemove\", (e) => {\n    mousePosition = { x: e.clientX, y: e.clientY };\n  });\n  document.addEventListener(\"mousedown\", (e) => {\n    mousePosition = { x: e.clientX, y: e.clientY };\n  }, { capture: true });\n\n  onClearTextWidthCache(closePopup);\n\n  /**\n   * @typedef ResultPreview\n   * @property {BlockInstance} block\n   * @property {((endOnly: boolean) => string)?} autocompleteFactory\n   * @property {BlockComponent} renderedBlock\n   * @property {SVGGElement} svgBlock\n   * @property {SVGRectElement} svgBackground\n   */\n  /** @type {ResultPreview[]} */\n  let queryPreviews = [];\n  /** @type {QueryResult | null} */\n  let queryIllegalResult = null;\n  let selectedPreviewIdx = 0;\n  /** @type {BlockTypeInfo[]?} */\n  let blockTypes = null;\n  let limited = false;\n\n  let allowMenuClose = true;\n\n  let popupPosition = null;\n  let popupOrigin = null;\n\n  let previewWidth = 0;\n  let previewHeight = 0;\n\n  let previewScale = 0;\n\n  let previewMinHeight = 0;\n  let previewMaxHeight = 0;\n\n  function openPopup() {\n    if (addon.self.disabled) return;\n\n    // Don't show the menu if we're not in the code editor\n    if (addon.tab.editorMode !== \"editor\") return;\n    if (addon.tab.redux.state.scratchGui.editorTab.activeTabIndex !== 0) return;\n\n    blockTypes = BlockTypeInfo.getBlocks(Blockly, vm, Blockly.getMainWorkspace(), msg);\n    querier.indexWorkspace([...blockTypes]);\n    blockTypes.sort((a, b) => {\n      const prio = (block) => [\"operators\", \"data\"].indexOf(block.category.name) - block.id.startsWith(\"data_\");\n      return prio(b) - prio(a);\n    });\n\n    previewScale = window.innerWidth * 0.00005 + addon.settings.get(\"popup_scale\") / 100;\n    previewWidth = (window.innerWidth * addon.settings.get(\"popup_width\")) / 100;\n    previewMaxHeight = (window.innerHeight * addon.settings.get(\"popup_max_height\")) / 100;\n\n    popupContainer.style.width = previewWidth + \"px\";\n\n    popupOrigin = { x: mousePosition.x, y: mousePosition.y };\n    popupRoot.style.display = \"\";\n    popupInput.value = \"\";\n    popupInput.focus();\n    updateInput();\n  }\n\n  function closePopup() {\n    if (allowMenuClose) {\n      popupOrigin = null;\n      popupPosition = null;\n      popupRoot.style.display = \"none\";\n      blockTypes = null;\n      querier.clearWorkspaceIndex();\n    }\n  }\n\n  popupInput.addEventListener(\"input\", updateInput);\n\n  function updateInput() {\n    /**\n     * @typedef MenuItem\n     * @property {BlockInstance} block\n     * @property {(endOnly: boolean) => string} [autocompleteFactory]\n     */\n    /** @type {MenuItem[]} */\n    const blockList = [];\n\n    if (popupInput.value.trim().length === 0) {\n      queryIllegalResult = null;\n      if (blockTypes)\n        for (const blockType of blockTypes) {\n          blockList.push({\n            block: blockType.createBlock(),\n          });\n        }\n      limited = false;\n    } else {\n      // Get the list of blocks to display using the input content\n      const queryResultObj = querier.queryWorkspace(popupInput.value);\n      const queryResults = queryResultObj.results;\n      queryIllegalResult = queryResultObj.illegalResult;\n      limited = queryResultObj.limited;\n\n      if (queryResults.length > PREVIEW_LIMIT) queryResults.length = PREVIEW_LIMIT;\n\n      for (const queryResult of queryResults) {\n        blockList.push({\n          block: queryResult.getBlock(),\n          autocompleteFactory: (endOnly) => queryResult.toText(endOnly),\n        });\n      }\n    }\n\n    // @ts-ignore Delete the old previews\n    while (popupPreviewBlocks.firstChild) popupPreviewBlocks.removeChild(popupPreviewBlocks.lastChild);\n\n    // Create the new previews\n    queryPreviews.length = 0;\n    let y = 0;\n    for (let resultIdx = 0; resultIdx < blockList.length; resultIdx++) {\n      const result = blockList[resultIdx];\n\n      const mouseMoveListener = () => {\n        updateSelection(resultIdx);\n      };\n\n      const mouseDownListener = (e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        updateSelection(resultIdx);\n        allowMenuClose = !e.shiftKey;\n        selectBlock();\n        allowMenuClose = true;\n        if (e.shiftKey) popupInput.focus();\n      };\n\n      const svgBackground = popupPreviewBlocks.appendChild(\n        document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\")\n      );\n\n      const height = getBlockHeight(result.block);\n      svgBackground.setAttribute(\"transform\", `translate(0, ${(y + height / 10) * previewScale})`);\n      svgBackground.setAttribute(\"height\", height * previewScale + \"px\");\n      svgBackground.classList.add(\"sa-mcp-preview-block-bg\");\n      svgBackground.addEventListener(\"mousemove\", mouseMoveListener);\n      svgBackground.addEventListener(\"mousedown\", mouseDownListener);\n\n      const svgBlock = popupPreviewBlocks.appendChild(document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\"));\n      svgBlock.addEventListener(\"mousemove\", mouseMoveListener);\n      svgBlock.addEventListener(\"mousedown\", mouseDownListener);\n      svgBlock.classList.add(\"sa-mcp-preview-block\");\n\n      const renderedBlock = renderBlock(result.block, svgBlock);\n\n      queryPreviews.push({\n        block: result.block,\n        autocompleteFactory: result.autocompleteFactory ?? null,\n        renderedBlock,\n        svgBlock,\n        svgBackground,\n      });\n\n      y += height;\n    }\n\n    const height = (y + 8) * previewScale;\n\n    if (height < previewMinHeight) previewHeight = previewMinHeight;\n    else if (height > previewMaxHeight) previewHeight = previewMaxHeight;\n    else previewHeight = height;\n\n    popupPreviewBlocks.setAttribute(\"height\", `${height}px`);\n    popupPreviewContainer.style.height = previewHeight + \"px\";\n    popupPreviewScrollbarSVG.style.height = previewHeight + \"px\";\n    popupPreviewScrollbarBackground.setAttribute(\"height\", \"\" + previewHeight);\n    popupInputContainer.dataset[\"error\"] = \"\" + limited;\n\n    popupPosition = { x: popupOrigin.x + 16, y: popupOrigin.y - 8 };\n\n    const popupHeight = popupContainer.getBoundingClientRect().height;\n    const popupBottom = popupPosition.y + popupHeight;\n    if (popupBottom > window.innerHeight) {\n      popupPosition.y -= popupBottom - window.innerHeight;\n    }\n\n    popupRoot.style.top = popupPosition.y + \"px\";\n    popupRoot.style.left = popupPosition.x + \"px\";\n\n    selectedPreviewIdx = -1;\n    updateSelection(0);\n    updateCursor();\n    updateScrollbar();\n  }\n\n  function updateSelection(newIdx) {\n    if (selectedPreviewIdx === newIdx) return;\n\n    const oldSelection = queryPreviews[selectedPreviewIdx];\n    if (oldSelection) {\n      oldSelection.svgBackground.classList.remove(\"sa-mcp-preview-block-bg-selection\");\n      oldSelection.svgBlock.classList.remove(\"sa-mcp-preview-block-selection\");\n    }\n\n    if (queryPreviews.length === 0 && queryIllegalResult) {\n      popupInputSuggestion.value =\n        popupInput.value + queryIllegalResult.toText(true).substring(popupInput.value.length);\n      return;\n    }\n\n    const newSelection = queryPreviews[newIdx];\n    if (newSelection && newSelection.autocompleteFactory) {\n      newSelection.svgBackground.classList.add(\"sa-mcp-preview-block-bg-selection\");\n      newSelection.svgBlock.classList.add(\"sa-mcp-preview-block-selection\");\n\n      newSelection.svgBackground.scrollIntoView({\n        block: \"nearest\",\n        behavior: Math.abs(newIdx - selectedPreviewIdx) > 1 ? \"smooth\" : \"auto\",\n      });\n\n      popupInputSuggestion.value =\n        popupInput.value + newSelection.autocompleteFactory(true).substring(popupInput.value.length);\n    } else {\n      popupInputSuggestion.value = \"\";\n    }\n\n    selectedPreviewIdx = newIdx;\n  }\n\n  // @ts-ignore\n  document.addEventListener(\"selectionchange\", updateCursor);\n\n  function updateCursor() {\n    const cursorPos = popupInput.selectionStart ?? 0;\n    const cursorPosRel = popupInput.value.length === 0 ? 0 : cursorPos / popupInput.value.length;\n\n    let y = 0;\n    for (let previewIdx = 0; previewIdx < queryPreviews.length; previewIdx++) {\n      const preview = queryPreviews[previewIdx];\n\n      var blockX = 5;\n      if (blockX + preview.renderedBlock.width > previewWidth / previewScale)\n        blockX += (previewWidth / previewScale - blockX - preview.renderedBlock.width) * previewScale * cursorPosRel;\n      var blockY = (y + 30) * previewScale;\n\n      preview.svgBlock.setAttribute(\"transform\", `translate(${blockX}, ${blockY}) scale(${previewScale})`);\n\n      y += getBlockHeight(preview.block);\n    }\n\n    popupInputSuggestion.scrollLeft = popupInput.scrollLeft;\n  }\n\n  popupPreviewContainer.addEventListener(\"scroll\", updateScrollbar);\n\n  function updateScrollbar() {\n    const scrollTop = popupPreviewContainer.scrollTop;\n    const scrollY = popupPreviewContainer.scrollHeight;\n\n    if (scrollY <= previewHeight) {\n      popupPreviewScrollbarSVG.style.display = \"none\";\n      return;\n    }\n\n    const scrollbarHeight = (previewHeight / scrollY) * previewHeight;\n    const scrollbarY = (scrollTop / scrollY) * previewHeight;\n\n    popupPreviewScrollbarSVG.style.display = \"\";\n    popupPreviewScrollbarHandle.setAttribute(\"height\", \"\" + scrollbarHeight);\n    popupPreviewScrollbarHandle.setAttribute(\"y\", \"\" + scrollbarY);\n  }\n\n  function selectBlock() {\n    const selectedPreview = queryPreviews[selectedPreviewIdx];\n    if (!selectedPreview) return;\n\n    const workspace = Blockly.getMainWorkspace();\n    // This is mostly copied from https://github.com/scratchfoundation/scratch-blocks/blob/893c7e7ad5bfb416eaed75d9a1c93bdce84e36ab/core/scratch_blocks_utils.js#L171\n    // Some bits were removed or changed to fit our needs.\n    workspace.setResizesEnabled(false);\n\n    let newBlock;\n    Blockly.Events.disable();\n    try {\n      newBlock = selectedPreview.block.createWorkspaceForm();\n      Blockly.scratchBlocksUtils.changeObscuredShadowIds(newBlock);\n\n      var svgRootNew = newBlock.getSvgRoot();\n      if (!svgRootNew) {\n        throw new Error(\"newBlock is not rendered.\");\n      }\n\n      let blockBounds = newBlock.svgPath_.getBoundingClientRect();\n      let newBlockX = Math.floor((mousePosition.x - (blockBounds.left + blockBounds.right) / 2) / workspace.scale);\n      let newBlockY = Math.floor((mousePosition.y - (blockBounds.top + blockBounds.bottom) / 2) / workspace.scale);\n      newBlock.moveBy(newBlockX, newBlockY);\n    } finally {\n      Blockly.Events.enable();\n    }\n    if (Blockly.Events.isEnabled()) {\n      Blockly.Events.fire(new Blockly.Events.BlockCreate(newBlock));\n    }\n\n    let fakeEvent = {\n      clientX: mousePosition.x,\n      clientY: mousePosition.y,\n      type: \"mousedown\",\n      stopPropagation: function () {},\n      preventDefault: function () {},\n      target: selectedPreview.svgBlock,\n    };\n    if (workspace.getGesture(fakeEvent)) {\n      workspace.startDragWithFakeEvent(fakeEvent, newBlock);\n    }\n  }\n\n  function acceptAutocomplete() {\n    let factory;\n    if (queryPreviews[selectedPreviewIdx]) factory = queryPreviews[selectedPreviewIdx].autocompleteFactory;\n    else factory = () => popupInputSuggestion.value;\n    if (popupInputSuggestion.value.length === 0 || !factory) return;\n    popupInput.value = factory(false);\n    // Move cursor to the end of the newly inserted text\n    popupInput.selectionStart = popupInput.value.length + 1;\n    updateInput();\n  }\n\n  popupInput.addEventListener(\"keydown\", (e) => {\n    switch (e.key) {\n      case \"Escape\":\n        // If there's something in the input, clear it\n        if (popupInput.value.length > 0) {\n          popupInput.value = \"\";\n          updateInput();\n        } else {\n          // If not, close the menu\n          closePopup();\n        }\n        e.stopPropagation();\n        e.preventDefault();\n        break;\n      case \"Tab\":\n        acceptAutocomplete();\n        e.stopPropagation();\n        e.preventDefault();\n        break;\n      case \"Enter\":\n        selectBlock();\n        closePopup();\n        e.stopPropagation();\n        e.preventDefault();\n        break;\n      case \"ArrowDown\":\n        if (selectedPreviewIdx + 1 >= queryPreviews.length) updateSelection(0);\n        else updateSelection(selectedPreviewIdx + 1);\n        e.stopPropagation();\n        e.preventDefault();\n        break;\n      case \"ArrowUp\":\n        if (selectedPreviewIdx - 1 < 0) updateSelection(queryPreviews.length - 1);\n        else updateSelection(selectedPreviewIdx - 1);\n        e.stopPropagation();\n        e.preventDefault();\n        break;\n    }\n  });\n\n  popupInput.addEventListener(\"focusout\", closePopup);\n\n  // Open on ctrl + space\n  document.addEventListener(\"keydown\", (e) => {\n    if (e.key === \" \" && (e.ctrlKey || e.metaKey)) {\n      openPopup();\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  });\n\n  // Open on mouse wheel button\n  const _doWorkspaceClick_ = Blockly.Gesture.prototype.doWorkspaceClick_;\n  Blockly.Gesture.prototype.doWorkspaceClick_ = function () {\n    if (this.mostRecentEvent_.button === 1 || this.mostRecentEvent_.shiftKey) openPopup();\n    mousePosition = { x: this.mostRecentEvent_.clientX, y: this.mostRecentEvent_.clientY };\n    _doWorkspaceClick_.call(this);\n  };\n\n  // The popup should delete blocks dragged ontop of it\n  const _isDeleteArea = Blockly.WorkspaceSvg.prototype.isDeleteArea;\n  Blockly.WorkspaceSvg.prototype.isDeleteArea = function (e) {\n    if (popupPosition) {\n      if (\n        e.clientX > popupPosition.x &&\n        e.clientX < popupPosition.x + previewWidth &&\n        e.clientY > popupPosition.y &&\n        e.clientY < popupPosition.y + previewHeight\n      ) {\n        return Blockly.DELETE_AREA_TOOLBOX;\n      }\n    }\n    return _isDeleteArea.call(this, e);\n  };\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","export default async ({ addon, console, msg }) => {\n  const types = [\"sound\", \"costume\"];\n\n  addon.tab.createEditorContextMenu(\n    (ctx) => {\n      const target = addon.tab.traps.vm.editingTarget;\n      if (ctx.type === \"sound\") {\n        target.reorderSound(ctx.index, 0);\n      } else {\n        target.reorderCostume(ctx.index, 0);\n      }\n      queueMicrotask(() => {\n        addon.tab.traps.vm.emitTargetsUpdate();\n        addon.tab.traps.vm.runtime.emitProjectChanged();\n        ctx.target.click();\n      });\n    },\n    {\n      types,\n      position: \"assetContextMenuAfterExport\",\n      order: 1,\n      label: msg(\"top\"),\n      condition: (ctx) => ctx.index !== 0,\n    }\n  );\n  addon.tab.createEditorContextMenu(\n    (ctx) => {\n      const target = addon.tab.traps.vm.editingTarget;\n      if (ctx.type === \"sound\") {\n        target.reorderSound(ctx.index, Infinity);\n      } else {\n        target.reorderCostume(ctx.index, Infinity);\n      }\n      queueMicrotask(() => {\n        addon.tab.traps.vm.emitTargetsUpdate();\n        addon.tab.traps.vm.runtime.emitProjectChanged();\n        ctx.target.click();\n      });\n    },\n    {\n      types,\n      position: \"assetContextMenuAfterExport\",\n      order: 2,\n      label: msg(\"bottom\"),\n      condition: (ctx) => ctx.index !== ctx.target.parentNode.parentNode.childElementCount - 1,\n    }\n  );\n};\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./style.css\";\nimport _asset from \"!url-loader!./decrement.svg\";\nimport _asset2 from \"!url-loader!./increment.svg\";\nimport _asset3 from \"!url-loader!./settings.svg\";\nimport _asset4 from \"!url-loader!./toggle.svg\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"style.css\": _css,\n  \"decrement.svg\": _asset,\n  \"increment.svg\": _asset2,\n  \"settings.svg\": _asset3,\n  \"toggle.svg\": _asset4,\n};\n","export default async function ({ addon, console, msg }) {\n  const paper = await addon.tab.traps.getPaper();\n\n  const paintEditorCanvasContainer = await addon.tab.waitForElement(\"[class^='paint-editor_canvas-container']\");\n  try {\n    if (!(\"colorIndex\" in addon.tab.redux.state.scratchPaint.fillMode)) {\n      console.error(\"Detected new paint editor; this will be supported in future versions.\");\n      return;\n    }\n  } catch (_) {\n    // The check can technically fail when Redux isn't supported (rare cases)\n    // Just ignore in this case\n  }\n  const paperCanvas =\n    paintEditorCanvasContainer[addon.tab.traps.getInternalKey(paintEditorCanvasContainer)].child.child.child.stateNode;\n\n  const storedOnionLayers = [];\n\n  const parseHexColor = (color) => {\n    const hexString = color.substr(1);\n    const hexNumber = parseInt(hexString, 16);\n    return [\n      (hexNumber >> 16) & 0xff, // R\n      (hexNumber >> 8) & 0xff, // G\n      hexNumber & 0xff, // B\n    ];\n  };\n\n  const settings = {\n    enabled: addon.settings.get(\"default\") && !addon.self.disabled,\n    previous: +addon.settings.get(\"previous\"),\n    next: +addon.settings.get(\"next\"),\n    opacity: +addon.settings.get(\"opacity\"),\n    opacityStep: +addon.settings.get(\"opacityStep\"),\n    layering: addon.settings.get(\"layering\"),\n    mode: addon.settings.get(\"mode\"),\n    beforeTint: parseHexColor(addon.settings.get(\"beforeTint\")),\n    afterTint: parseHexColor(addon.settings.get(\"afterTint\")),\n  };\n\n  const getPaperCenter = () => {\n    const backgroundGuideLayer = paper.project.layers.find((i) => i.data.isBackgroundGuideLayer);\n    return backgroundGuideLayer.children[0].position;\n  };\n\n  const injectPaper = () => {\n    // When background guide layer is added, show onion layers.\n    // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/helper/layer.js#L145\n    const originalAddLayer = paper.Project.prototype.addLayer;\n    paper.Project.prototype.addLayer = function (layer) {\n      const result = originalAddLayer.call(this, layer);\n      if (layer.data.isBackgroundGuideLayer) {\n        let onion;\n        while ((onion = storedOnionLayers.shift())) {\n          originalAddLayer.call(this, onion);\n        }\n        relayerOnionLayers();\n      }\n      return result;\n    };\n\n    // Scratch uses importJSON to undo or redo\n    // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/helper/undo.js#L37\n    // The code prior to this will remove our onion layers, so we have to manually add them back.\n    const originalImportJSON = paper.Project.prototype.importJSON;\n    paper.Project.prototype.importJSON = function (json) {\n      const result = originalImportJSON.call(this, json);\n      if (settings.enabled) {\n        updateOnionLayers();\n      }\n      return result;\n    };\n\n    // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/helper/layer.js#L114\n    // When background guide layer is removed, hide onion layers.\n    const originalRemoveLayer = paper.Layer.prototype.remove;\n    paper.Layer.prototype.remove = function () {\n      if (this.data.isBackgroundGuideLayer) {\n        for (const layer of paper.project.layers) {\n          if (layer.data.sa_isOnionLayer) {\n            storedOnionLayers.push(layer);\n          }\n        }\n        for (const layer of storedOnionLayers) {\n          layer.remove();\n        }\n      }\n      return originalRemoveLayer.call(this);\n    };\n  };\n\n  const injectPaperCanvas = () => {\n    let expectingImport = false;\n\n    const PaperCanvas = paperCanvas.constructor;\n\n    // importImage is called to start loading an image.\n    // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L124\n    const originalImportImage = PaperCanvas.prototype.importImage;\n    PaperCanvas.prototype.importImage = function (...args) {\n      expectingImport = true;\n      removeOnionLayers();\n      return originalImportImage.call(this, ...args);\n    };\n\n    // recalibrateSize is called when the canvas finishes loading an image.\n    // all paths of importImage will result in a call to this method.\n    // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L310-L327\n    // We use this to know when to add layers.\n    const originalRecalibrateSize = PaperCanvas.prototype.recalibrateSize;\n    PaperCanvas.prototype.recalibrateSize = function (callback) {\n      return originalRecalibrateSize.call(this, () => {\n        if (callback) callback();\n        if (expectingImport) {\n          expectingImport = false;\n          if (settings.enabled) {\n            updateOnionLayers();\n          }\n        }\n      });\n    };\n\n    // Prototype overrides will work for all future instances, but Scratch manually binds some methods to `this`\n    // so we have to manually copy them for the current instance (but not future instances)\n    paperCanvas.recalibrateSize = PaperCanvas.prototype.recalibrateSize.bind(paperCanvas);\n    paperCanvas.importImage = PaperCanvas.prototype.importImage.bind(paperCanvas);\n  };\n\n  const createOnionLayer = () => {\n    const layer = new paper.Layer();\n    layer.locked = true;\n    layer.guide = true;\n    layer.data.sa_isOnionLayer = true;\n    return layer;\n  };\n\n  // Each onion layer update is given an ID\n  // Because updating layers is async, we need this to cancel all but the most recent update\n  let globalUpdateId = 0;\n  const cancelOngoingUpdatesAndGetNewId = () => ++globalUpdateId;\n\n  const removeOnionLayers = () => {\n    cancelOngoingUpdatesAndGetNewId();\n\n    const project = paper.project;\n    if (!project) {\n      return;\n    }\n\n    storedOnionLayers.length = 0;\n    const layers = project.layers;\n    // Iterate downward because we remove items mid-iteration\n    for (let i = layers.length - 1; i >= 0; i--) {\n      const layer = layers[i];\n      if (layer.data.sa_isOnionLayer) {\n        layer.remove();\n      }\n    }\n  };\n\n  const relayerOnionLayers = () => {\n    const project = paper.project;\n    if (!project) {\n      return;\n    }\n    const onionLayer = project.layers.find((i) => i.data.sa_isOnionLayer);\n    if (!onionLayer) {\n      return;\n    }\n    if (settings.layering === \"front\") {\n      project.addLayer(onionLayer);\n    } else {\n      const rasterLayer = project.layers.find((i) => i.data.isRasterLayer);\n      if (rasterLayer.index === 0) {\n        project.insertLayer(0, onionLayer);\n      } else {\n        project.insertLayer(1, onionLayer);\n      }\n    }\n  };\n\n  const recursePaperItem = (item, callback) => {\n    if (item.children) {\n      for (const child of item.children) {\n        recursePaperItem(child, callback);\n      }\n    }\n    callback(item);\n  };\n\n  const getTint = (red, green, blue, isBefore) => {\n    const referenceColor = isBefore ? settings.beforeTint : settings.afterTint;\n    const colorAverage = (red + green + blue) / 3 / 255;\n    const WEIGHT = 1.5;\n    const weighted = colorAverage / WEIGHT + (1 - 1 / WEIGHT);\n    return [referenceColor[0] * weighted, referenceColor[1] * weighted, referenceColor[2] * weighted];\n  };\n\n  const toHexColor = ([red, green, blue]) => {\n    const r = Math.round(red).toString(16).padStart(2, \"0\");\n    const g = Math.round(green).toString(16).padStart(2, \"0\");\n    const b = Math.round(blue).toString(16).padStart(2, \"0\");\n    return `#${r}${g}${b}`;\n  };\n\n  const getPaperColorTint = (color, isBefore) =>\n    toHexColor(getTint(color.red * 255, color.green * 255, color.blue * 255, isBefore));\n\n  const tintRaster = (raster, isBefore) => {\n    const { width, height } = raster.canvas;\n    const context = raster.context;\n    // TODO: check to see if this is a performance issue\n    const imageData = context.getImageData(0, 0, width, height);\n    const data = imageData.data;\n    for (let i = 0; i < data.length; i += 4 /* RGBA */) {\n      const red = data[i + 0];\n      const green = data[i + 1];\n      const blue = data[i + 2];\n      const alpha = data[i + 3];\n      if (alpha === 0) {\n        continue;\n      }\n      const newTint = getTint(red, green, blue, isBefore);\n      data[i + 0] = newTint[0];\n      data[i + 1] = newTint[1];\n      data[i + 2] = newTint[2];\n    }\n    context.putImageData(imageData, 0, 0);\n  };\n\n  const waitForAllRastersToLoad = (root) => {\n    const promises = [];\n    recursePaperItem(root, (item) => {\n      if (item instanceof paper.Raster) {\n        promises.push(\n          new Promise((resolve, reject) => {\n            item.on(\"load\", () => resolve());\n            item.on(\"error\", () => reject(new Error(\"Raster inside SVG failed to load\")));\n          })\n        );\n      }\n    });\n    return Promise.all(promises);\n  };\n\n  const rasterizeVector = (root) => {\n    const bounds = root.strokeBounds;\n    const { width, height } = bounds;\n\n    // Some browsers experience extremely poor performance when this value exceeds 3840.\n    const MAX_SIZE = 3000;\n    const maxScale = Math.min(MAX_SIZE / width, MAX_SIZE / height);\n\n    const raster = new paper.Raster(new paper.Size(width, height));\n    raster.remove();\n    raster.smoothing = true;\n\n    raster.guide = true;\n    raster.locked = true;\n\n    let renderedAtScale = 0;\n    const originalDraw = raster.draw;\n    raster.draw = function (...args) {\n      const displayedSize = this.getView().getZoom() * window.devicePixelRatio;\n      const newScale = Math.max(1, Math.min(maxScale, 2 ** Math.ceil(Math.log2(displayedSize))));\n      if (newScale > renderedAtScale) {\n        renderedAtScale = newScale;\n        const canvas = this.canvas;\n        const ctx = this.context;\n\n        // Based on https://github.com/scratchfoundation/paper.js/blob/16d5ff0267e3a0ef647c25e58182a27300afad20/src/item/Item.js#L1761\n        const scaledWidth = width * newScale;\n        const scaledHeight = height * newScale;\n        canvas.width = scaledWidth;\n        canvas.height = scaledHeight;\n\n        this._size = new paper.Size(scaledWidth, scaledHeight);\n        const topLeft = bounds.getTopLeft();\n        const bottomRight = bounds.getBottomRight();\n        const size = new paper.Size(bottomRight.subtract(topLeft));\n        const matrix = new paper.Matrix().scale(newScale).translate(topLeft.negate());\n        ctx.save();\n        matrix.applyToContext(ctx);\n        root.draw(\n          ctx,\n          new paper.Base({\n            matrices: [matrix],\n          })\n        );\n        ctx.restore();\n        this.matrix.reset();\n        this.transform(new paper.Matrix().translate(topLeft.add(size.divide(2))).scale(1 / newScale));\n      }\n\n      return originalDraw.call(this, ...args);\n    };\n\n    return raster;\n  };\n\n  const makeVectorOnion = (opacity, costume, asset, isBefore) =>\n    new Promise((resolve, reject) => {\n      const { rotationCenterX, rotationCenterY } = costume;\n      // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L196-L218\n      asset = asset.split(/<\\s*svg:/).join(\"<\");\n      asset = asset.split(/<\\/\\s*svg:/).join(\"</\");\n      const svgAttrs = asset.match(/<svg [^>]*>/);\n      if (svgAttrs && svgAttrs[0].indexOf(\"xmlns=\") === -1) {\n        asset = asset.replace(\"<svg \", '<svg xmlns=\"http://www.w3.org/2000/svg\" ');\n      }\n      const parser = new DOMParser();\n      const svgDom = parser.parseFromString(asset, \"text/xml\");\n      const viewBox = svgDom.documentElement.attributes.viewBox\n        ? svgDom.documentElement.attributes.viewBox.value.match(/\\S+/g)\n        : null;\n      if (viewBox) {\n        for (let i = 0; i < viewBox.length; i++) {\n          viewBox[i] = parseFloat(viewBox[i]);\n        }\n      }\n\n      const handleLoad = (root) => {\n        root.opacity = opacity;\n\n        // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L274-L275\n        recursePaperItem(root, (i) => {\n          if (i.className === \"PathItem\") {\n            i.clockwise = true;\n          }\n          if (i.className !== \"PointText\" && !i.children) {\n            if (i.strokeWidth) {\n              i.strokeWidth = i.strokeWidth * 2;\n            }\n          }\n          i.locked = true;\n          i.guide = true;\n        });\n        root.scale(2, new paper.Point(0, 0));\n\n        if (settings.mode === \"tint\") {\n          const gradients = new Set();\n          recursePaperItem(root, (i) => {\n            if (i.strokeColor) {\n              i.strokeColor = getPaperColorTint(i.strokeColor, isBefore);\n            }\n            if (i.fillColor) {\n              const gradient = i.fillColor.gradient;\n              if (gradient) {\n                if (gradients.has(gradient)) return;\n                gradients.add(gradient);\n                for (const stop of gradient.stops) {\n                  stop.color = getPaperColorTint(stop.color, isBefore);\n                }\n              } else {\n                i.fillColor = getPaperColorTint(i.fillColor, isBefore);\n              }\n            }\n            if (i.canvas) {\n              tintRaster(i, isBefore);\n            }\n          });\n        }\n\n        const paperCenter = getPaperCenter();\n        // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L277-L287\n        if (typeof rotationCenterX !== \"undefined\" && typeof rotationCenterY !== \"undefined\") {\n          let rotationPoint = new paper.Point(rotationCenterX, rotationCenterY);\n          if (viewBox && viewBox.length >= 2 && !isNaN(viewBox[0]) && !isNaN(viewBox[1])) {\n            rotationPoint = rotationPoint.subtract(viewBox[0], viewBox[1]);\n          }\n          root.translate(paperCenter.subtract(rotationPoint.multiply(2)));\n        } else {\n          root.translate(paperCenter.subtract(root.bounds.width, root.bounds.height));\n        }\n\n        return rasterizeVector(root);\n      };\n\n      paper.project.importSVG(asset, {\n        expandShapes: true,\n        insert: false,\n        onLoad: (root) => {\n          if (!root) {\n            reject(new Error(\"could not load onion skin\"));\n            return;\n          }\n          resolve(waitForAllRastersToLoad(root).then(() => handleLoad(root)));\n        },\n      });\n    });\n\n  const makeRasterOnion = (opacity, costume, asset, isBefore) =>\n    new Promise((resolve, reject) => {\n      let { rotationCenterX, rotationCenterY } = costume;\n\n      const image = new Image();\n      image.onload = () => {\n        const paperCenter = getPaperCenter();\n        const width = Math.min(paperCenter.x * 2, image.width);\n        const height = Math.min(paperCenter.y * 2, image.height);\n\n        // https://github.com/scratchfoundation/scratch-paint/blob/cdf0afc217633e6cfb8ba90ea4ae38b79882cf6c/src/containers/paper-canvas.jsx#L151-L156\n        if (typeof rotationCenterX === \"undefined\") {\n          rotationCenterX = width / 2;\n        }\n        if (typeof rotationCenterY === \"undefined\") {\n          rotationCenterY = height / 2;\n        }\n\n        const raster = new paper.Raster(image);\n        raster.opacity = opacity;\n        raster.guide = true;\n        raster.locked = true;\n        const x = width / 2 + (paperCenter.x - rotationCenterX);\n        const y = height / 2 + (paperCenter.y - rotationCenterY);\n        raster.position = new paper.Point(x, y);\n        raster.remove();\n\n        if (settings.mode === \"tint\") {\n          tintRaster(raster, isBefore);\n        }\n\n        resolve(raster);\n      };\n      image.onerror = () => {\n        reject(new Error(\"could not load image\"));\n      };\n      image.src = asset;\n    });\n\n  const getSelectedCostumeIndex = () => {\n    const item = document.querySelector(\"[class*='selector_list-item'][class*='sprite-selector-item_is-selected']\");\n    if (!item) return -1;\n    const numberEl = item.querySelector(\"[class*='sprite-selector-item_number']\");\n    if (!numberEl) return -1;\n    return +numberEl.textContent - 1;\n  };\n\n  const updateOnionLayers = async () => {\n    const project = paper.project;\n    if (!project) {\n      return;\n    }\n\n    const selectedCostumeIndex = getSelectedCostumeIndex();\n    if (selectedCostumeIndex === -1) {\n      return;\n    }\n\n    removeOnionLayers();\n\n    const localUpdateId = cancelOngoingUpdatesAndGetNewId();\n\n    const vm = addon.tab.traps.vm;\n    if (!vm) {\n      return;\n    }\n    const originalActiveLayer = project.activeLayer;\n    const costumes = vm.editingTarget.sprite.costumes;\n\n    const startIndex = Math.max(0, selectedCostumeIndex - settings.previous);\n    const endIndex = Math.min(costumes.length - 1, selectedCostumeIndex + settings.next);\n\n    try {\n      const layersToCreate = [];\n      for (let i = startIndex; i <= endIndex; i++) {\n        if (i === selectedCostumeIndex) {\n          continue;\n        }\n        const isBefore = i < selectedCostumeIndex;\n        const distance = Math.abs(i - selectedCostumeIndex) - 1;\n        const opacity = (settings.opacity - settings.opacityStep * distance) / 100;\n        if (opacity <= 0) {\n          continue;\n        }\n        layersToCreate.push({\n          index: i,\n          isBefore,\n          opacity,\n        });\n      }\n\n      const onions = await Promise.all(\n        layersToCreate.map(({ index, isBefore, opacity }) => {\n          const onionCostume = costumes[index];\n          const onionAsset = vm.getCostume(index);\n\n          if (onionCostume.dataFormat === \"svg\") {\n            return makeVectorOnion(opacity, onionCostume, onionAsset, isBefore);\n          } else if (onionCostume.dataFormat === \"png\" || onionCostume.dataFormat === \"jpg\") {\n            return makeRasterOnion(opacity, onionCostume, onionAsset, isBefore);\n          } else {\n            throw new Error(`Unknown data format: ${onionCostume.dataFormat}`);\n          }\n        })\n      );\n\n      // Make sure we haven't been cancelled\n      if (globalUpdateId === localUpdateId) {\n        const layer = createOnionLayer();\n        for (const item of onions) {\n          layer.addChild(item);\n        }\n        relayerOnionLayers();\n      }\n    } catch (e) {\n      console.error(e);\n    }\n\n    // We must make sure to always reset the active layer to avoid corruption.\n    originalActiveLayer.activate();\n  };\n\n  const setEnabled = (_enabled) => {\n    if (settings.enabled === _enabled) {\n      return;\n    }\n    settings.enabled = _enabled;\n    if (settings.enabled) {\n      if (settings.next === 0 && settings.previous === 0) {\n        settings.previous = 1;\n        layerInputs.previous.value = settings.previous;\n      }\n      if (settings.opacity === 0) {\n        settings.opacity = 25;\n        layerInputs.opacity.value = settings.opacity;\n      }\n      updateOnionLayers();\n    } else {\n      removeOnionLayers();\n    }\n    toggleButton.dataset.enabled = settings.enabled;\n  };\n\n  //\n  // Controls below editor\n  //\n\n  const settingsChanged = (onlyRelayerNeeded) => {\n    if ((settings.previous === 0 && settings.next === 0) || settings.opacity === 0) {\n      setEnabled(false);\n      return;\n    }\n    if (settings.enabled) {\n      if (onlyRelayerNeeded) {\n        relayerOnionLayers();\n      } else {\n        updateOnionLayers();\n      }\n    } else if (settings.previous > 0 || settings.next > 0) {\n      setEnabled(true);\n    }\n  };\n\n  const createGroup = () => {\n    const el = document.createElement(\"div\");\n    el.className = \"sa-onion-group\";\n    return el;\n  };\n\n  const createButton = ({ useButtonTag } = {}) => {\n    const el = document.createElement(useButtonTag ? \"button\" : \"span\");\n    el.className = \"sa-onion-button\";\n    el.setAttribute(\"role\", \"button\");\n    return el;\n  };\n\n  const createButtonImage = (name) => {\n    const el = document.createElement(\"img\");\n    el.className = \"sa-onion-image\";\n    el.draggable = false;\n    el.dataset.image = name;\n    el.loading = \"lazy\";\n    el.src = addon.self.getResource(\"/\" + name + \".svg\") /* rewritten by pull.js */;\n    return el;\n  };\n\n  const toggleControlsGroup = createGroup();\n  addon.tab.displayNoneWhileDisabled(toggleControlsGroup, { display: \"flex\" });\n\n  const toggleButton = createButton();\n  toggleButton.dataset.enabled = settings.enabled;\n  toggleButton.addEventListener(\"click\", () => setEnabled(!settings.enabled));\n  toggleButton.title = msg(\"toggle\");\n  toggleButton.appendChild(createButtonImage(\"toggle\"));\n\n  const settingButton = createButton();\n  settingButton.addEventListener(\"click\", () => setSettingsOpen(!areSettingsOpen()));\n  settingButton.title = msg(\"settings\");\n  settingButton.appendChild(createButtonImage(\"settings\"));\n\n  document.body.addEventListener(\"click\", (e) => {\n    if (areSettingsOpen() && !e.target.matches(\".sa-onion-group *\")) setSettingsOpen(false);\n  });\n\n  //\n  // Settings page\n  //\n\n  const settingPageWrapper = document.createElement(\"div\");\n  settingPageWrapper.className = \"sa-onion-settings-wrapper\";\n  toggleControlsGroup.append(settingPageWrapper, toggleButton, settingButton);\n\n  const settingsPage = document.createElement(\"div\");\n  settingsPage.className = \"sa-onion-settings\";\n\n  const setSettingsOpen = (open) => {\n    settingButton.dataset.enabled = open;\n    settingsPage.dataset.visible = open;\n  };\n  const areSettingsOpen = () => settingsPage.dataset.visible === \"true\";\n\n  const layerInputs = {};\n  for (const type of [\"previous\", \"next\", \"opacity\", \"opacityStep\"]) {\n    const container = document.createElement(\"label\");\n    container.className = \"sa-onion-settings-line\";\n\n    const label = document.createElement(\"div\");\n    label.className = \"sa-onion-settings-label\";\n    label.textContent = msg(type);\n    container.appendChild(label);\n\n    const group = createGroup();\n    const currentButton = createButton();\n\n    const filler = document.createElement(\"div\");\n    filler.style.width = \"20px\";\n    currentButton.appendChild(filler);\n\n    const currentInput = document.createElement(\"input\");\n    layerInputs[type] = currentInput;\n    currentInput.className = \"sa-onion-settings-input\";\n    currentInput.type = \"number\";\n    currentInput.step = \"1\";\n    currentInput.min = \"0\";\n    currentInput.max = \"100\";\n    currentInput.value = settings[type];\n    currentInput.addEventListener(\"input\", (e) => {\n      if (currentInput.value.length === 0) {\n        settings[type] = 0;\n        settingsChanged();\n        return;\n      }\n      let value = +currentInput.value;\n      if (value > +currentInput.max) {\n        value = +currentInput.max;\n      } else if (value < 0) {\n        value = 0;\n      }\n      currentInput.value = value;\n      settings[type] = value;\n      settingsChanged();\n    });\n    currentInput.addEventListener(\"blur\", () => {\n      if (!currentInput.value) {\n        currentInput.value = \"0\";\n      }\n    });\n    currentButton.appendChild(currentInput);\n\n    const decrementButton = createButton();\n    decrementButton.appendChild(createButtonImage(\"decrement\"));\n    decrementButton.addEventListener(\"click\", () => {\n      if (settings[type] > 0) {\n        settings[type]--;\n        currentInput.value = settings[type];\n        settingsChanged();\n      }\n    });\n\n    const incrementButton = createButton();\n    incrementButton.appendChild(createButtonImage(\"increment\"));\n    incrementButton.addEventListener(\"click\", () => {\n      if (settings[type] < +currentInput.max) {\n        settings[type]++;\n        currentInput.value = settings[type];\n        settingsChanged();\n      }\n    });\n\n    group.appendChild(decrementButton);\n    group.appendChild(currentButton);\n    group.appendChild(incrementButton);\n    container.appendChild(group);\n    settingsPage.appendChild(container);\n  }\n\n  const modeContainer = document.createElement(\"div\");\n  modeContainer.className = \"sa-onion-settings-line\";\n  const modeLabel = document.createElement(\"div\");\n  modeLabel.className = \"sa-onion-settings-label\";\n  modeLabel.textContent = msg(\"mode\");\n  const modeGroup = createGroup();\n  modeContainer.appendChild(modeLabel);\n  const modeMergeButton = createButton({ useButtonTag: true });\n  modeMergeButton.appendChild(document.createTextNode(msg(\"merge\")));\n  modeGroup.appendChild(modeMergeButton);\n  modeMergeButton.addEventListener(\"click\", (e) => {\n    settings.mode = \"merge\";\n    modeTintButton.dataset.enabled = false;\n    modeMergeButton.dataset.enabled = true;\n    settingsChanged();\n  });\n  modeMergeButton.dataset.enabled = settings.mode === \"merge\";\n  const modeTintButton = createButton({ useButtonTag: true });\n  modeTintButton.appendChild(document.createTextNode(msg(\"tint\")));\n  modeGroup.appendChild(modeTintButton);\n  modeTintButton.addEventListener(\"click\", (e) => {\n    settings.mode = \"tint\";\n    modeTintButton.dataset.enabled = true;\n    modeMergeButton.dataset.enabled = false;\n    settingsChanged();\n  });\n  modeTintButton.dataset.enabled = settings.mode === \"tint\";\n  modeContainer.appendChild(modeGroup);\n  settingsPage.appendChild(modeContainer);\n\n  const layeringContainer = document.createElement(\"div\");\n  layeringContainer.className = \"sa-onion-settings-line\";\n  const layeringLabel = document.createElement(\"div\");\n  layeringLabel.className = \"sa-onion-settings-label\";\n  layeringLabel.textContent = msg(\"layering\");\n  const layeringGroup = createGroup();\n  layeringContainer.appendChild(layeringLabel);\n  const layeringFrontButton = createButton({ useButtonTag: true });\n  layeringFrontButton.appendChild(document.createTextNode(msg(\"front\")));\n  layeringGroup.appendChild(layeringFrontButton);\n  layeringFrontButton.addEventListener(\"click\", (e) => {\n    settings.layering = \"front\";\n    layeringBehindButton.dataset.enabled = false;\n    layeringFrontButton.dataset.enabled = true;\n    settingsChanged(true);\n  });\n  layeringFrontButton.dataset.enabled = settings.layering === \"front\";\n  const layeringBehindButton = createButton({ useButtonTag: true });\n  layeringBehindButton.appendChild(document.createTextNode(msg(\"behind\")));\n  layeringGroup.appendChild(layeringBehindButton);\n  layeringBehindButton.addEventListener(\"click\", (e) => {\n    settings.layering = \"behind\";\n    layeringBehindButton.dataset.enabled = true;\n    layeringFrontButton.dataset.enabled = false;\n    settingsChanged(true);\n  });\n  layeringBehindButton.dataset.enabled = settings.layering === \"behind\";\n  layeringContainer.appendChild(layeringGroup);\n  settingsPage.appendChild(layeringContainer);\n\n  const SVG_NS = \"http://www.w3.org/2000/svg\";\n  const settingsTip = document.createElementNS(SVG_NS, \"svg\");\n  settingsTip.setAttribute(\"class\", \"sa-onion-settings-tip\");\n  settingsTip.setAttribute(\"width\", \"14\");\n  settingsTip.setAttribute(\"height\", \"7\");\n  const settingsTipShape = document.createElementNS(SVG_NS, \"polygon\");\n  settingsTipShape.setAttribute(\"class\", \"sa-onion-settings-polygon\");\n  settingsTipShape.setAttribute(\"points\", \"0,0 7,7, 14,0\");\n  settingsTip.appendChild(settingsTipShape);\n  settingsPage.appendChild(settingsTip);\n\n  let oldEnabled = null;\n  addon.self.addEventListener(\"disabled\", () => {\n    setSettingsOpen(false);\n    oldEnabled = settings.enabled;\n    setEnabled(false);\n  });\n  addon.self.addEventListener(\"reenabled\", () => {\n    setEnabled(oldEnabled);\n  });\n\n  const controlsLoop = async () => {\n    let hasRunOnce = false;\n    while (true) {\n      const canvasControls = await addon.tab.waitForElement(\"[class^='paint-editor_canvas-controls']\", {\n        markAsSeen: true,\n        reduxEvents: [\n          \"scratch-gui/navigation/ACTIVATE_TAB\",\n          \"scratch-gui/mode/SET_PLAYER\",\n          \"fontsLoaded/SET_FONTS_LOADED\",\n          \"scratch-gui/locales/SELECT_LOCALE\",\n          \"scratch-gui/targets/UPDATE_TARGET_LIST\",\n        ],\n        reduxCondition: (state) =>\n          state.scratchGui.editorTab.activeTabIndex === 1 && !state.scratchGui.mode.isPlayerOnly,\n      });\n      const zoomControlsContainer = canvasControls.querySelector(\"[class^='paint-editor_zoom-controls']\");\n\n      addon.tab.appendToSharedSpace({\n        space: \"paintEditorZoomControls\",\n        element: toggleControlsGroup,\n        order: 1,\n      });\n      settingPageWrapper.appendChild(settingsPage);\n\n      if (!hasRunOnce) {\n        hasRunOnce = true;\n        const groupClass = zoomControlsContainer.firstChild.className;\n        const buttonClass = zoomControlsContainer.firstChild.firstChild.className;\n        const imageClass = zoomControlsContainer.firstChild.firstChild.firstChild.className;\n        for (const el of document.querySelectorAll(\".sa-onion-group\")) {\n          el.className += \" \" + groupClass;\n        }\n        for (const el of document.querySelectorAll(\".sa-onion-button\")) {\n          el.className += \" \" + buttonClass;\n        }\n        for (const el of document.querySelectorAll(\".sa-onion-image\")) {\n          el.className += \" \" + imageClass;\n        }\n      }\n\n      if (settings.enabled) {\n        updateOnionLayers();\n      }\n    }\n  };\n\n  injectPaper();\n  injectPaperCanvas();\n  controlsLoop();\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","import { addons, initialize } from \"../paint-snap/compatibility.js\";\n\nexport default async function ({ addon }) {\n  const paper = await addon.tab.traps.getPaper();\n\n  const addSkew = function () {\n    if (!paper.tool || !paper.tool.boundingBoxTool) return;\n    // ScaleTool\n    const ST = paper.tool.boundingBoxTool._modeMap?.SCALE?.constructor;\n    if (!ST || ST.hasSkew) {\n      return;\n    }\n    ST.hasSkew = true;\n\n    const ogMouseDown = ST.prototype.onMouseDown;\n    ST.prototype.onMouseDown = function (hitResult, boundsPath, selectedItems) {\n      if (this.active) return;\n      this.index = hitResult.item.data.index;\n      ogMouseDown.call(this, hitResult, boundsPath, selectedItems);\n      this.skewCenter = false;\n      this.lastSkx = 0;\n      this.lastSky = 0;\n      this.skewBounds = this.itemGroup.bounds.clone();\n    };\n\n    addons.paintSkew = function (event, original) {\n      if (!this.active) return;\n      if (addon.self.disabled) return original();\n\n      const bounds = this.skewBounds;\n      const doShear = (skx, sky) => {\n        if (skx === 0 && sky === 0) return;\n\n        let offcenterPosition;\n        if (!this.skewCenter) {\n          switch (this._getRectCornerNameByIndex(this.index)) {\n            case \"topCenter\":\n            case \"leftCenter\":\n              offcenterPosition = this.itemGroup.position.add(new paper.Point(bounds.width / 2, bounds.height / 2));\n              break;\n            case \"bottomCenter\":\n            case \"rightCenter\":\n              offcenterPosition = this.itemGroup.position.subtract(\n                new paper.Point(bounds.width / 2, bounds.height / 2)\n              );\n              break;\n          }\n        }\n\n        const position = this.skewCenter ? this.itemGroup.position : offcenterPosition;\n\n        const shearMult = this.skewCenter ? 2 : 1;\n        // swap width and height because apparently\n        // shearing is based on the dimension perpendicular\n        // to the one that is being skewed\n        const shearX = (skx / bounds.height) * shearMult;\n        const shearY = (sky / bounds.width) * shearMult;\n\n        this.itemGroup.shear(shearX, shearY, position);\n        if (this.selectionAnchor) {\n          this.selectionAnchor.shear(-shearX, -shearY);\n        }\n      };\n\n      // Revert skew\n      doShear(-this.lastSkx, -this.lastSky);\n\n      this.skewCenter = event.modifiers.alt;\n\n      let skx = 0;\n      let sky = 0;\n      this.lastSkx = 0;\n      this.lastSky = 0;\n      if ((event.modifiers.control || event.modifiers.command) && !this.isCorner) {\n        // Skew\n        // Reset position\n        this.centered = false;\n        this.itemGroup.scale(1 / this.lastSx, 1 / this.lastSy, this.pivot);\n        if (this.selectionAnchor) {\n          this.selectionAnchor.scale(this.lastSx, this.lastSy);\n        }\n        this.lastSx = 1;\n        this.lastSy = 1;\n\n        const delta = event.point.subtract(this.pivot);\n        switch (this._getRectCornerNameByIndex(this.index)) {\n          case \"topCenter\":\n            delta.x *= -1;\n            delta.y = 0;\n            break;\n          case \"bottomCenter\":\n            delta.y = 0;\n            break;\n          case \"leftCenter\":\n            delta.y *= -1;\n            delta.x = 0;\n            break;\n          case \"rightCenter\":\n            delta.x = 0;\n            break;\n          default:\n            delta.x = 0;\n            delta.y = 0;\n        }\n        skx = delta.x;\n        sky = delta.y;\n\n        doShear(skx, sky);\n      } else {\n        // Scale\n        original();\n      }\n      this.lastSkx = skx;\n      this.lastSky = sky;\n    };\n\n    initialize(paper, ST);\n  };\n\n  addon.tab.redux.initialize();\n  addon.tab.redux.addEventListener(\"statechanged\", (e) => {\n    const action = e.detail.action;\n    if (\n      action.type === \"scratch-paint/modes/CHANGE_MODE\" &&\n      (action.mode === \"BIT_SELECT\" || action.mode === \"SELECT\")\n    ) {\n      addSkew();\n    }\n  });\n  addSkew();\n}\n","let overridden = false;\n\nexport const addons = {\n  paintSkew: null,\n  paintSnap: null,\n};\n\nexport function initialize(paper, ScaleTool) {\n  if (overridden) return;\n\n  overridden = true;\n  const ogMouseDrag = ScaleTool.prototype.onMouseDrag;\n  ScaleTool.prototype.onMouseDrag = function (event) {\n    if (!this.active) return;\n    const callSnap = () => {\n      if (addons.paintSnap) addons.paintSnap.call(this, event);\n      else ogMouseDrag.call(this, event);\n    };\n    if (addons.paintSkew) {\n      addons.paintSkew.call(this, event, callSnap);\n    } else {\n      callSnap();\n    }\n  };\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./style.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"style.css\": _css,\n};\n","export default async function ({ addon, msg, console }) {\n  const brand = Symbol();\n\n  const setIsPicking = (picking) => document.body.classList.toggle(\"sa-stage-color-picker-picking\", picking);\n\n  // We only want to handle color picker events from the user clicking on the button, not from\n  // addons or other scripts pressing it with click().\n  let isMostRecentClickUserInitiated = false;\n  document.addEventListener(\n    \"click\",\n    (e) => {\n      isMostRecentClickUserInitiated = e.isTrusted;\n    },\n    {\n      capture: true,\n    }\n  );\n\n  addon.tab.redux.initialize();\n  addon.tab.redux.addEventListener(\"statechanged\", (e) => {\n    const action = e.detail.action;\n\n    // Do not process events emitted by ourselves.\n    if (action[brand]) {\n      return;\n    }\n\n    if (\n      !addon.self.disabled &&\n      isMostRecentClickUserInitiated &&\n      action.type === \"scratch-paint/eye-dropper/ACTIVATE_COLOR_PICKER\"\n    ) {\n      setIsPicking(true);\n\n      // When scratch-paint's color picker is activated, also activate scratch-gui's color picker.\n      addon.tab.redux.dispatch({\n        type: \"scratch-gui/color-picker/ACTIVATE_COLOR_PICKER\",\n        callback: (color) => {\n          // callback is called from reducer; do not dispatch events in reducer\n          queueMicrotask(() => {\n            // By the time we get here, scratch-paint will have already deactivated its eye dropper.\n            // If we were to just call the callback, the color would indeed update, but the sliders\n            // in the color selector would not update.\n            // https://github.com/scratchfoundation/scratch-paint/blob/970b72c3e75d0ad44ab54e403a44786ca5f45512/src/containers/color-picker.jsx#L64\n            // To work around this, we will re-enable the color picker before running the callback.\n            addon.tab.redux.dispatch({\n              ...action,\n              [brand]: true,\n            });\n            action.callback(color);\n            if (action.previousMode) {\n              action.previousMode.activate();\n            }\n            addon.tab.redux.dispatch({\n              type: \"scratch-paint/eye-dropper/DEACTIVATE_COLOR_PICKER\",\n              [brand]: true,\n            });\n            setIsPicking(false);\n          });\n        },\n      });\n    }\n\n    // Don't check for addon being disabled here in case we were dynamically disabled while color\n    // picking. This code won't do anything anyways when the previous code doesn't run.\n    if (action.type === \"scratch-paint/eye-dropper/DEACTIVATE_COLOR_PICKER\") {\n      setIsPicking(false);\n\n      // When someone selects a color in the scratch-paint picker, cancel the scratch-gui picker\n      if (addon.tab.redux.state.scratchGui.colorPicker.active) {\n        addon.tab.redux.dispatch({\n          type: \"scratch-gui/color-picker/DEACTIVATE_COLOR_PICKER\",\n          [brand]: true,\n        });\n      }\n    }\n  });\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nexport const resources = {\n  \"userscript.js\": _js,\n};\n","export default async function ({ addon, msg, console }) {\n  const vm = addon.tab.traps.vm;\n  const Blockly = await addon.tab.traps.getBlockly();\n\n  // editor-searchable-dropdowns relies on this value\n  const RENAME_BROADCAST_MESSAGE_ID = \"RENAME_BROADCAST_MESSAGE_ID\";\n\n  const BROADCAST_MESSAGE_TYPE = Blockly.BROADCAST_MESSAGE_VARIABLE_TYPE;\n\n  const _dropdownCreate = Blockly.FieldVariable.dropdownCreate;\n  Blockly.FieldVariable.dropdownCreate = function () {\n    const options = _dropdownCreate.call(this);\n    if (\n      !addon.self.disabled &&\n      this.defaultType_ === BROADCAST_MESSAGE_TYPE &&\n      // Disable when workspace has no actual broadcast to rename\n      this.sourceBlock_.workspace.getVariableTypes().includes(\"broadcast_msg\")\n    ) {\n      options.push([msg(\"RENAME_BROADCAST\"), RENAME_BROADCAST_MESSAGE_ID]);\n    }\n    return options;\n  };\n\n  const _onItemSelected = Blockly.FieldVariable.prototype.onItemSelected;\n  Blockly.FieldVariable.prototype.onItemSelected = function (menu, menuItem) {\n    const workspace = this.sourceBlock_.workspace;\n    if (this.sourceBlock_ && workspace) {\n      if (menuItem.getValue() === RENAME_BROADCAST_MESSAGE_ID) {\n        promptRenameBroadcast(workspace, this.variable_);\n        return;\n      }\n    }\n    return _onItemSelected.call(this, menu, menuItem);\n  };\n\n  const resetVMCaches = () => {\n    const blockContainers = new Set(vm.runtime.targets.map((i) => i.blocks));\n    for (const blocks of blockContainers) {\n      blocks.resetCache();\n    }\n  };\n\n  const addUndoRedoHook = (callback) => {\n    const eventQueue = Blockly.Events.FIRE_QUEUE_;\n    // After a rename is emitted, some unrelated garbage events also get emitted\n    // So we should trap the first event\n    const undoItem = eventQueue[0];\n    const originalRun = undoItem.run;\n    undoItem.run = function (isRedo) {\n      originalRun.call(this, isRedo);\n      callback(isRedo);\n    };\n  };\n\n  const renameBroadcastInVM = (id, newName) => {\n    // Editor's rename won't completely rename the variable.\n    const vmVariable = vm.runtime.getTargetForStage().variables[id];\n    vmVariable.name = newName;\n    vmVariable.value = newName;\n\n    // Update all references to the broadcast. Broadcasts won't work if these\n    // don't match.\n    const blockContainers = new Set(vm.runtime.targets.map((i) => i.blocks));\n    for (const blockContainer of blockContainers) {\n      for (const block of Object.values(blockContainer._blocks)) {\n        const broadcastOption = block.fields && block.fields.BROADCAST_OPTION;\n        if (broadcastOption && broadcastOption.id === id) {\n          broadcastOption.value = newName;\n        }\n      }\n    }\n\n    resetVMCaches();\n  };\n\n  const renameBroadcast = (workspace, id, oldName, newName) => {\n    // Rename in editor. Undo/redo will work automatically.\n    workspace.renameVariableById(id, newName);\n\n    // Rename in VM. Need to manually implement undo/redo.\n    renameBroadcastInVM(id, newName);\n\n    addUndoRedoHook((isRedo) => {\n      if (isRedo) {\n        renameBroadcastInVM(id, newName);\n      } else {\n        renameBroadcastInVM(id, oldName);\n      }\n    });\n  };\n\n  const mergeBroadcast = (workspace, oldId, oldName, newName) => {\n    const newVmVariable = vm.runtime.getTargetForStage().lookupBroadcastByInputValue(newName);\n    const newId = newVmVariable.id;\n\n    // Merge in editor. Undo/redo will work automatically for this.\n    // Use group so that everything here is undone/redone at the same time.\n    Blockly.Events.setGroup(true);\n    for (const block of workspace.getAllBlocks()) {\n      for (const input of block.inputList) {\n        for (const field of input.fieldRow) {\n          if (field.name === \"BROADCAST_OPTION\" && field.getValue() === oldId) {\n            field.setValue(newId);\n          }\n        }\n      }\n    }\n    // Remove the broadcast from the editor so it doesn't appear in dropdowns.\n    // Undo/redo will work automatically for this.\n    workspace.deleteVariableById(oldId);\n    Blockly.Events.setGroup(false);\n\n    // Merge in VM to update sprites that aren't open. Need to manually implement undo/redo.\n    // To figure out how to undo this operation, we first figure out which blocks we're\n    // going to touch and keep hold of that list.\n    const vmBlocksToUpdate = [];\n    const blockContainers = new Set(vm.runtime.targets.map((i) => i.blocks));\n    for (const blockContainer of blockContainers) {\n      for (const block of Object.values(blockContainer._blocks)) {\n        const broadcastOption = block.fields && block.fields.BROADCAST_OPTION;\n        if (broadcastOption && broadcastOption.id === oldId) {\n          vmBlocksToUpdate.push(block);\n        }\n      }\n    }\n    const applyVmEdits = (isRedo) => {\n      const idToReplaceWith = isRedo ? newId : oldId;\n      const nameToReplaceWith = isRedo ? newName : oldName;\n      for (const block of vmBlocksToUpdate) {\n        const broadcastOption = block.fields.BROADCAST_OPTION;\n        broadcastOption.id = idToReplaceWith;\n        broadcastOption.value = nameToReplaceWith;\n      }\n      resetVMCaches();\n    };\n    applyVmEdits(true);\n\n    // Earlier editor updates are guaranteed to generate at least 1 event that we can hook as the\n    // broadcast block must exist in the editor for the user to rename it.\n    addUndoRedoHook((isRedo) => {\n      applyVmEdits(isRedo);\n    });\n  };\n\n  const promptRenameBroadcast = (workspace, variable) => {\n    const modalTitle = msg(\"RENAME_BROADCAST_MODAL_TITLE\");\n    const oldName = variable.name;\n    const id = variable.getId();\n    const promptText = msg(\"RENAME_BROADCAST_TITLE\", { name: oldName });\n    const promptDefaultText = oldName;\n\n    Blockly.prompt(\n      promptText,\n      promptDefaultText,\n      function (newName) {\n        newName = Blockly.Variables.trimName_(newName);\n        const nameIsEmpty = !newName;\n        if (nameIsEmpty) {\n          return;\n        }\n\n        const variableAlreadyExists = !!workspace.getVariable(newName, BROADCAST_MESSAGE_TYPE);\n        if (variableAlreadyExists) {\n          mergeBroadcast(workspace, id, oldName, newName);\n        } else {\n          renameBroadcast(workspace, id, oldName, newName);\n        }\n      },\n      modalTitle,\n      BROADCAST_MESSAGE_TYPE\n    );\n  };\n\n  const updateExistingMenuGenerators = () => {\n    const workspace = Blockly.getMainWorkspace();\n    const flyout = workspace && workspace.getFlyout();\n    if (workspace && flyout) {\n      const allBlocks = [...workspace.getAllBlocks(), ...flyout.getWorkspace().getAllBlocks()];\n      for (const block of allBlocks) {\n        for (const input of block.inputList) {\n          for (const field of input.fieldRow) {\n            if (field instanceof Blockly.FieldVariable) {\n              field.menuGenerator_ = Blockly.FieldVariable.dropdownCreate;\n            }\n          }\n        }\n      }\n    }\n  };\n\n  updateExistingMenuGenerators();\n}\n","/* generated by pull.js */\nimport _js from \"./userscript.js\";\nimport _css from \"!css-loader!./arrows.css\";\nexport const resources = {\n  \"userscript.js\": _js,\n  \"arrows.css\": _css,\n};\n","// https://github.com/scratchfoundation/scratch-blocks/blob/f210e042988b91bcdc2abeca7a2d85e178edadb2/blocks_vertical/procedures.js#L205\nexport function modifiedCreateAllInputs(connectionMap) {\n  // Split the proc into components, by %n, %b, %s and %l (ignoring escaped).\n  var procComponents = this.procCode_.split(/(?=[^\\\\]%[nbsl])/);\n  procComponents = procComponents.map(function (c) {\n    return c.trim(); // Strip whitespace.\n  });\n\n  // Create arguments and labels as appropriate.\n  var argumentCount = 0;\n  for (var i = 0, component; (component = procComponents[i]); i++) {\n    var labelText;\n    // Don't treat %l as an argument\n    if (component.substring(0, 1) == \"%\" && component.substring(1, 2) !== \"l\") {\n      var argumentType = component.substring(1, 2);\n      if (!(argumentType == \"n\" || argumentType == \"b\" || argumentType == \"s\")) {\n        throw new Error(\"Found an custom procedure with an invalid type: \" + argumentType);\n      }\n      labelText = component.substring(2).trim();\n\n      var id = this.argumentIds_[argumentCount];\n\n      var input = this.appendValueInput(id);\n      if (argumentType == \"b\") {\n        input.setCheck(\"Boolean\");\n      }\n      this.populateArgument_(argumentType, argumentCount, connectionMap, id, input);\n      argumentCount++;\n    } else {\n      labelText = component.trim().replace(\"%l \", \"\");\n    }\n    this.addProcedureLabel_(labelText.replace(/\\\\%/, \"%\"));\n  }\n\n  // remove all traces of %l at the earliest possible time\n  this.procCode_ = this.procCode_.replaceAll(\"%l \", \"\");\n}\n\n//https://github.com/scratchfoundation/scratch-blocks/blob/f210e042988b91bcdc2abeca7a2d85e178edadb2/blocks_vertical/procedures.js#L565\nexport function modifiedUpdateDeclarationProcCode(prefixLabels = false) {\n  this.procCode_ = \"\";\n  this.displayNames_ = [];\n  this.argumentIds_ = [];\n  for (var i = 0; i < this.inputList.length; i++) {\n    if (i != 0) {\n      this.procCode_ += \" \";\n    }\n    var input = this.inputList[i];\n    if (input.type == 5) {\n      // replaced Blocky.DUMMY_VALUE with 5\n      this.procCode_ += (prefixLabels ? \"%l \" : \"\") + input.fieldRow[0].getValue(); // modified to prepend %l delimiter, which prevents label merging\n    } else if (input.type == 1) {\n      // replaced Blocky.INPUT_VALUE with 1\n      // Inspect the argument editor.\n      var target = input.connection.targetBlock();\n      this.displayNames_.push(target.getFieldValue(\"TEXT\"));\n      this.argumentIds_.push(input.name);\n      if (target.type == \"argument_editor_boolean\") {\n        this.procCode_ += \"%b\";\n      } else {\n        this.procCode_ += \"%s\";\n      }\n    } else {\n      throw new Error(\"Unexpected input type on a procedure mutator root: \" + input.type);\n    }\n  }\n}\n","import { modifiedCreateAllInputs, modifiedUpdateDeclarationProcCode } from \"./modified-funcs.js\";\n\nexport default async function ({ addon, console }) {\n  function createArrow(direction, callback) {\n    const path = direction === \"left\" ? \"M 17 13 L 9 21 L 17 30\" : \"M 9 13 L 17 21 L 9 30\";\n\n    Blockly.WidgetDiv.DIV.insertAdjacentHTML(\n      \"beforeend\",\n      `\n            <svg width=\"20px\" height=\"40px\" \n                 style=\"left: ${direction === \"left\" ? \"calc(50% - 20px)\" : \"calc(50% + 20px)\"}\" \n                 class=\"blocklyTextShiftArrow\">\n                <path d=\"${path}\" fill=\"none\" stroke=\"#FF661A\" stroke-width=\"2\"></path>\n            </svg>`\n    );\n\n    Blockly.WidgetDiv.DIV.lastChild.addEventListener(\"click\", callback);\n  }\n\n  //https://github.com/scratchfoundation/scratch-blocks/blob/f210e042988b91bcdc2abeca7a2d85e178edadb2/blocks_vertical/procedures.js#L674\n  function modifiedRemoveFieldCallback(field) {\n    // Do not delete if there is only one input\n    if (this.inputList.length === 1) {\n      return;\n    }\n    var inputNameToRemove = null;\n    for (var n = 0; n < this.inputList.length; n++) {\n      var input = this.inputList[n];\n      if (input.connection) {\n        var target = input.connection.targetBlock();\n        if (target.getField(field.name) == field) {\n          inputNameToRemove = input.name;\n        }\n      } else {\n        for (var j = 0; j < input.fieldRow.length; j++) {\n          if (input.fieldRow[j] == field) {\n            inputNameToRemove = input.name;\n          }\n        }\n      }\n    }\n    if (inputNameToRemove) {\n      Blockly.WidgetDiv.hide(true);\n      this.removeInput(inputNameToRemove);\n      this.onChangeFn(true); // this is the only part we changed. We added this boolean input, which lets us switch on the merging.\n      this.updateDisplay_();\n    }\n  }\n\n  function addInputAfter(addInputFn, fnName) {\n    return function () {\n      const sourceBlock = selectedField?.sourceBlock_;\n      const proc = sourceBlock ? (sourceBlock.parentBlock_ ? sourceBlock.parentBlock_ : sourceBlock) : this;\n\n      // if a label is added, scratch's code will directly append the label text to the procCode\n      // We account for this with a hacky method of adding the delimiter at the end of the last label input\n      if (fnName === \"addLabelExternal\") {\n        const lastInput = proc.inputList[proc.inputList.length - 1];\n        if (lastInput.type === Blockly.DUMMY_INPUT) {\n          lastInput.fieldRow[0].setValue(lastInput.fieldRow[0].getValue() + \" %l\");\n        }\n      }\n\n      proc.onChangeFn(true);\n      if (sourceBlock === null || sourceBlock === undefined || !addon.settings.get(\"InsertInputsAfter\"))\n        return addInputFn.call(this, ...arguments);\n\n      let newPosition = getFieldInputNameAndIndex(selectedField, proc.inputList).index + 1;\n\n      addInputFn.call(proc, ...arguments);\n\n      const lastInputName = proc.inputList[proc.inputList.length - 1].name;\n      shiftInput(proc, lastInputName, newPosition);\n    };\n  }\n\n  function getFieldInputNameAndIndex(field, inputList) {\n    for (const [i, input] of inputList.entries()) {\n      const isTargetField = input.connection\n        ? input.connection.targetBlock()?.getField(field.name) === field\n        : input.fieldRow.includes(field);\n\n      if (isTargetField) {\n        return {\n          name: input.name,\n          index: i,\n        };\n      }\n    }\n  }\n\n  function shiftInput(procedureBlock, inputNameToShift, newPosition) {\n    const initialInputListLength = procedureBlock.inputList.length;\n\n    // return if inputNameToShift and newPosition are not valid\n    if (!(inputNameToShift && newPosition >= 0 && newPosition <= initialInputListLength)) {\n      return false;\n    }\n\n    const originalPosition = procedureBlock.inputList.findIndex((input) => input.name === inputNameToShift);\n    const itemToMove = procedureBlock.inputList.splice(originalPosition, 1)[0];\n    procedureBlock.inputList.splice(newPosition, 0, itemToMove);\n\n    Blockly.Events.disable();\n    try {\n      procedureBlock.onChangeFn(true);\n      procedureBlock.updateDisplay_();\n    } finally {\n      Blockly.Events.enable();\n    }\n\n    focusOnInput(procedureBlock.inputList[newPosition]);\n  }\n\n  function focusOnInput(input) {\n    if (!input) return;\n    if (input.type === Blockly.DUMMY_INPUT) {\n      input.fieldRow[0].showEditor_();\n    } else if (input.type === Blockly.INPUT_VALUE) {\n      const target = input.connection.targetBlock();\n      target.getField(\"TEXT\").showEditor_();\n    }\n  }\n\n  function shiftFieldCallback(sourceBlock, field, direction) {\n    const proc = sourceBlock.parentBlock_ ? sourceBlock.parentBlock_ : sourceBlock;\n\n    // if inputList length is 1 there's nowhere to shift the input so we can simply return\n    if (proc.inputList.length <= 1) return;\n\n    const { name, index } = getFieldInputNameAndIndex(field, proc.inputList);\n    const newPosition = direction === \"left\" ? index - 1 : index + 1;\n    shiftInput(proc, name, newPosition);\n  }\n\n  function polluteProcedureDeclaration(procedureDeclaration, save_original = true) {\n    procedureDeclaration.createAllInputs_ = modifiedCreateAllInputs;\n    procedureDeclaration.onChangeFn = modifiedUpdateDeclarationProcCode;\n    procedureDeclaration.removeFieldCallback = modifiedRemoveFieldCallback;\n\n    for (const inputFn of [\"addLabelExternal\", \"addBooleanExternal\", \"addStringNumberExternal\"]) {\n      if (save_original) {\n        originalAddFns[inputFn] = procedureDeclaration[inputFn];\n      }\n      procedureDeclaration[inputFn] = addInputAfter(procedureDeclaration[inputFn], inputFn);\n    }\n  }\n\n  function depolluteProcedureDeclaration(procedureDeclaration) {\n    procedureDeclaration.createAllInputs_ = originalCreateAllInputs;\n    procedureDeclaration.onChangeFn = originalUpdateDeclarationProcCode;\n    procedureDeclaration.removeFieldCallback = originalRemoveFieldCallback;\n\n    for (const [inputFnName, originalFn] of Object.entries(originalAddFns)) {\n      procedureDeclaration[inputFnName] = originalFn;\n    }\n  }\n\n  function getExistingProceduresDeclarationBlock() {\n    // Blockly.getMainWorkspace is required for this to work.\n    // for future reference \"upgrading\" to addon.tab.traps.getWorkspace() will cause bugs.\n    return Blockly.getMainWorkspace()\n      .getAllBlocks()\n      .find((block) => block.type === \"procedures_declaration\");\n  }\n\n  function enableAddon() {\n    // pollute the procedures_declaration prototype with a modified version that prevents merging, and allows inserting after\n    polluteProcedureDeclaration(Blockly.Blocks[\"procedures_declaration\"]);\n\n    // if custom procedures modal is already open we also directly pollute the existing procedures_declaration block\n    if (addon.tab.redux.state.scratchGui.customProcedures.active) {\n      polluteProcedureDeclaration(getExistingProceduresDeclarationBlock(), false);\n    }\n\n    Blockly.FieldTextInputRemovable.prototype.showEditor_ = function () {\n      originalShowEditor.call(this);\n      createArrow(\"left\", () => shiftFieldCallback(this.sourceBlock_, this, \"left\"));\n      createArrow(\"right\", () => shiftFieldCallback(this.sourceBlock_, this, \"right\"));\n      selectedField = this;\n    };\n  }\n\n  function disableAddon() {\n    // depollute the procedures_declaration prototype\n    depolluteProcedureDeclaration(Blockly.Blocks[\"procedures_declaration\"]);\n\n    // if custom procedures modal is already open we also directly depollute the existing procedures_declaration block\n    if (addon.tab.redux.state.scratchGui.customProcedures.active) {\n      depolluteProcedureDeclaration(getExistingProceduresDeclarationBlock());\n    }\n\n    Blockly.FieldTextInputRemovable.prototype.showEditor_ = originalShowEditor;\n    Blockly.WidgetDiv.DIV.querySelectorAll(\".blocklyTextShiftArrow\").forEach((e) => e.remove());\n  }\n\n  const Blockly = await addon.tab.traps.getBlockly();\n  const originalCreateAllInputs = Blockly.Blocks[\"procedures_declaration\"].createAllInputs_;\n  const originalUpdateDeclarationProcCode = Blockly.Blocks[\"procedures_declaration\"].onChangeFn;\n  const originalRemoveFieldCallback = Blockly.Blocks[\"procedures_declaration\"].removeFieldCallback;\n  const originalShowEditor = Blockly.FieldTextInputRemovable.prototype.showEditor_;\n  let originalAddFns = {};\n  let selectedField = null;\n\n  addon.self.addEventListener(\"disabled\", disableAddon);\n  addon.self.addEventListener(\"reenabled\", enableAddon);\n  enableAddon();\n}\n","export const getHexRegex = () => /^#?[0-9a-fA-F]{3,8}$/;\n\nexport const normalizeHex = (input) => {\n  let hex = String(input);\n  if (!getHexRegex().test(hex)) return \"#000000\";\n  if (!hex.startsWith(\"#\")) hex = `#${hex}`;\n  if (hex.length === 4) {\n    const [_, r, g, b] = hex;\n    hex = `#${r}${r}${g}${g}${b}${b}`;\n  }\n  return hex.toLowerCase();\n};\n","export default class RateLimiter {\n  constructor(wait) {\n    this.timeout = null;\n    this.callback = null;\n    this.wait = wait;\n  }\n\n  abort(call = true) {\n    if (this.timeout) {\n      clearTimeout(this.timeout);\n      if (call) this.callback();\n      this.timeout = this.callback = null;\n    }\n  }\n\n  limit(callback) {\n    this.abort(false);\n    this.callback = callback;\n    this.timeout = setTimeout(() => {\n      this.timeout = this.callback = null;\n      callback();\n    }, this.wait);\n  }\n}\n","// https://github.com/bgrins/TinyColor\n// Brian Grinstead, MIT License\n\nconst trimLeft = /^\\s+/;\nconst trimRight = /\\s+$/;\n\nexport default function tinycolor(color, opts) {\n  color = color ? color : \"\";\n  opts = opts || {};\n\n  // If input is already a tinycolor, return itself\n  if (color instanceof tinycolor) {\n    return color;\n  }\n  // If we are called as a function, call using new instead\n  if (!(this instanceof tinycolor)) {\n    return new tinycolor(color, opts);\n  }\n\n  var rgb = inputToRGB(color);\n  (this._originalInput = color),\n    (this._r = rgb.r),\n    (this._g = rgb.g),\n    (this._b = rgb.b),\n    (this._a = rgb.a),\n    (this._roundA = Math.round(100 * this._a) / 100),\n    (this._format = opts.format || rgb.format);\n  this._gradientType = opts.gradientType;\n\n  // Don't let the range of [0,255] come back in [0,1].\n  // Potentially lose a little bit of precision here, but will fix issues where\n  // .5 gets interpreted as half of the total, instead of half of 1\n  // If it was supposed to be 128, this was already taken care of by `inputToRgb`\n  if (this._r < 1) this._r = Math.round(this._r);\n  if (this._g < 1) this._g = Math.round(this._g);\n  if (this._b < 1) this._b = Math.round(this._b);\n\n  this._ok = rgb.ok;\n}\n\ntinycolor.prototype = {\n  isDark: function () {\n    return this.getBrightness() < 128;\n  },\n  isLight: function () {\n    return !this.isDark();\n  },\n  isValid: function () {\n    return this._ok;\n  },\n  getOriginalInput: function () {\n    return this._originalInput;\n  },\n  getFormat: function () {\n    return this._format;\n  },\n  getAlpha: function () {\n    return this._a;\n  },\n  getBrightness: function () {\n    //http://www.w3.org/TR/AERT#color-contrast\n    var rgb = this.toRgb();\n    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;\n  },\n  getLuminance: function () {\n    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    var rgb = this.toRgb();\n    var RsRGB, GsRGB, BsRGB, R, G, B;\n    RsRGB = rgb.r / 255;\n    GsRGB = rgb.g / 255;\n    BsRGB = rgb.b / 255;\n\n    if (RsRGB <= 0.03928) R = RsRGB / 12.92;\n    else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);\n    if (GsRGB <= 0.03928) G = GsRGB / 12.92;\n    else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);\n    if (BsRGB <= 0.03928) B = BsRGB / 12.92;\n    else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);\n    return 0.2126 * R + 0.7152 * G + 0.0722 * B;\n  },\n  setAlpha: function (value) {\n    this._a = boundAlpha(value);\n    this._roundA = Math.round(100 * this._a) / 100;\n    return this;\n  },\n  toHsv: function () {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };\n  },\n  toHsvString: function () {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    var h = Math.round(hsv.h * 360),\n      s = Math.round(hsv.s * 100),\n      v = Math.round(hsv.v * 100);\n    return this._a == 1\n      ? \"hsv(\" + h + \", \" + s + \"%, \" + v + \"%)\"\n      : \"hsva(\" + h + \", \" + s + \"%, \" + v + \"%, \" + this._roundA + \")\";\n  },\n  toHsl: function () {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };\n  },\n  toHslString: function () {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    var h = Math.round(hsl.h * 360),\n      s = Math.round(hsl.s * 100),\n      l = Math.round(hsl.l * 100);\n    return this._a == 1\n      ? \"hsl(\" + h + \", \" + s + \"%, \" + l + \"%)\"\n      : \"hsla(\" + h + \", \" + s + \"%, \" + l + \"%, \" + this._roundA + \")\";\n  },\n  toHex: function (allow3Char) {\n    return rgbToHex(this._r, this._g, this._b, allow3Char);\n  },\n  toHexString: function (allow3Char) {\n    return \"#\" + this.toHex(allow3Char);\n  },\n  toHex8: function (allow4Char) {\n    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);\n  },\n  toHex8String: function (allow4Char) {\n    return \"#\" + this.toHex8(allow4Char);\n  },\n  toRgb: function () {\n    return {\n      r: Math.round(this._r),\n      g: Math.round(this._g),\n      b: Math.round(this._b),\n      a: this._a,\n    };\n  },\n  toRgbString: function () {\n    return this._a == 1\n      ? \"rgb(\" +\n          Math.round(this._r) +\n          \", \" +\n          Math.round(this._g) +\n          \", \" +\n          Math.round(this._b) +\n          \")\"\n      : \"rgba(\" +\n          Math.round(this._r) +\n          \", \" +\n          Math.round(this._g) +\n          \", \" +\n          Math.round(this._b) +\n          \", \" +\n          this._roundA +\n          \")\";\n  },\n  toPercentageRgb: function () {\n    return {\n      r: Math.round(bound01(this._r, 255) * 100) + \"%\",\n      g: Math.round(bound01(this._g, 255) * 100) + \"%\",\n      b: Math.round(bound01(this._b, 255) * 100) + \"%\",\n      a: this._a,\n    };\n  },\n  toPercentageRgbString: function () {\n    return this._a == 1\n      ? \"rgb(\" +\n          Math.round(bound01(this._r, 255) * 100) +\n          \"%, \" +\n          Math.round(bound01(this._g, 255) * 100) +\n          \"%, \" +\n          Math.round(bound01(this._b, 255) * 100) +\n          \"%)\"\n      : \"rgba(\" +\n          Math.round(bound01(this._r, 255) * 100) +\n          \"%, \" +\n          Math.round(bound01(this._g, 255) * 100) +\n          \"%, \" +\n          Math.round(bound01(this._b, 255) * 100) +\n          \"%, \" +\n          this._roundA +\n          \")\";\n  },\n  toName: function () {\n    if (this._a === 0) {\n      return \"transparent\";\n    }\n\n    if (this._a < 1) {\n      return false;\n    }\n\n    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;\n  },\n  toFilter: function (secondColor) {\n    var hex8String = \"#\" + rgbaToArgbHex(this._r, this._g, this._b, this._a);\n    var secondHex8String = hex8String;\n    var gradientType = this._gradientType ? \"GradientType = 1, \" : \"\";\n\n    if (secondColor) {\n      var s = tinycolor(secondColor);\n      secondHex8String = \"#\" + rgbaToArgbHex(s._r, s._g, s._b, s._a);\n    }\n\n    return (\n      \"progid:DXImageTransform.Microsoft.gradient(\" +\n      gradientType +\n      \"startColorstr=\" +\n      hex8String +\n      \",endColorstr=\" +\n      secondHex8String +\n      \")\"\n    );\n  },\n  toString: function (format) {\n    var formatSet = !!format;\n    format = format || this._format;\n\n    var formattedString = false;\n    var hasAlpha = this._a < 1 && this._a >= 0;\n    var needsAlphaFormat =\n      !formatSet &&\n      hasAlpha &&\n      (format === \"hex\" ||\n        format === \"hex6\" ||\n        format === \"hex3\" ||\n        format === \"hex4\" ||\n        format === \"hex8\" ||\n        format === \"name\");\n\n    if (needsAlphaFormat) {\n      // Special case for \"transparent\", all other non-alpha formats\n      // will return rgba when there is transparency.\n      if (format === \"name\" && this._a === 0) {\n        return this.toName();\n      }\n      return this.toRgbString();\n    }\n    if (format === \"rgb\") {\n      formattedString = this.toRgbString();\n    }\n    if (format === \"prgb\") {\n      formattedString = this.toPercentageRgbString();\n    }\n    if (format === \"hex\" || format === \"hex6\") {\n      formattedString = this.toHexString();\n    }\n    if (format === \"hex3\") {\n      formattedString = this.toHexString(true);\n    }\n    if (format === \"hex4\") {\n      formattedString = this.toHex8String(true);\n    }\n    if (format === \"hex8\") {\n      formattedString = this.toHex8String();\n    }\n    if (format === \"name\") {\n      formattedString = this.toName();\n    }\n    if (format === \"hsl\") {\n      formattedString = this.toHslString();\n    }\n    if (format === \"hsv\") {\n      formattedString = this.toHsvString();\n    }\n\n    return formattedString || this.toHexString();\n  },\n  clone: function () {\n    return tinycolor(this.toString());\n  },\n\n  _applyModification: function (fn, args) {\n    var color = fn.apply(null, [this].concat([].slice.call(args)));\n    this._r = color._r;\n    this._g = color._g;\n    this._b = color._b;\n    this.setAlpha(color._a);\n    return this;\n  },\n  lighten: function () {\n    return this._applyModification(lighten, arguments);\n  },\n  brighten: function () {\n    return this._applyModification(brighten, arguments);\n  },\n  darken: function () {\n    return this._applyModification(darken, arguments);\n  },\n  desaturate: function () {\n    return this._applyModification(desaturate, arguments);\n  },\n  saturate: function () {\n    return this._applyModification(saturate, arguments);\n  },\n  greyscale: function () {\n    return this._applyModification(greyscale, arguments);\n  },\n  spin: function () {\n    return this._applyModification(spin, arguments);\n  },\n\n  _applyCombination: function (fn, args) {\n    return fn.apply(null, [this].concat([].slice.call(args)));\n  },\n  analogous: function () {\n    return this._applyCombination(analogous, arguments);\n  },\n  complement: function () {\n    return this._applyCombination(complement, arguments);\n  },\n  monochromatic: function () {\n    return this._applyCombination(monochromatic, arguments);\n  },\n  splitcomplement: function () {\n    return this._applyCombination(splitcomplement, arguments);\n  },\n  // Disabled until https://github.com/bgrins/TinyColor/issues/254\n  // polyad: function (number) {\n  //   return this._applyCombination(polyad, [number]);\n  // },\n  triad: function () {\n    return this._applyCombination(polyad, [3]);\n  },\n  tetrad: function () {\n    return this._applyCombination(polyad, [4]);\n  },\n};\n\n// If input is an object, force 1 into \"1.0\" to handle ratios properly\n// String input requires \"1.0\" as input, so 1 will be treated as 1\ntinycolor.fromRatio = function (color, opts) {\n  if (typeof color == \"object\") {\n    var newColor = {};\n    for (var i in color) {\n      if (color.hasOwnProperty(i)) {\n        if (i === \"a\") {\n          newColor[i] = color[i];\n        } else {\n          newColor[i] = convertToPercentage(color[i]);\n        }\n      }\n    }\n    color = newColor;\n  }\n\n  return tinycolor(color, opts);\n};\n\n// Given a string or object, convert that input to RGB\n// Possible string inputs:\n//\n//     \"red\"\n//     \"#f00\" or \"f00\"\n//     \"#ff0000\" or \"ff0000\"\n//     \"#ff000000\" or \"ff000000\"\n//     \"rgb 255 0 0\" or \"rgb (255, 0, 0)\"\n//     \"rgb 1.0 0 0\" or \"rgb (1, 0, 0)\"\n//     \"rgba (255, 0, 0, 1)\" or \"rgba 255, 0, 0, 1\"\n//     \"rgba (1.0, 0, 0, 1)\" or \"rgba 1.0, 0, 0, 1\"\n//     \"hsl(0, 100%, 50%)\" or \"hsl 0 100% 50%\"\n//     \"hsla(0, 100%, 50%, 1)\" or \"hsla 0 100% 50%, 1\"\n//     \"hsv(0, 100%, 100%)\" or \"hsv 0 100% 100%\"\n//\nfunction inputToRGB(color) {\n  var rgb = { r: 0, g: 0, b: 0 };\n  var a = 1;\n  var s = null;\n  var v = null;\n  var l = null;\n  var ok = false;\n  var format = false;\n\n  if (typeof color == \"string\") {\n    color = stringInputToObject(color);\n  }\n\n  if (typeof color == \"object\") {\n    if (\n      isValidCSSUnit(color.r) &&\n      isValidCSSUnit(color.g) &&\n      isValidCSSUnit(color.b)\n    ) {\n      rgb = rgbToRgb(color.r, color.g, color.b);\n      ok = true;\n      format = String(color.r).substr(-1) === \"%\" ? \"prgb\" : \"rgb\";\n    } else if (\n      isValidCSSUnit(color.h) &&\n      isValidCSSUnit(color.s) &&\n      isValidCSSUnit(color.v)\n    ) {\n      s = convertToPercentage(color.s);\n      v = convertToPercentage(color.v);\n      rgb = hsvToRgb(color.h, s, v);\n      ok = true;\n      format = \"hsv\";\n    } else if (\n      isValidCSSUnit(color.h) &&\n      isValidCSSUnit(color.s) &&\n      isValidCSSUnit(color.l)\n    ) {\n      s = convertToPercentage(color.s);\n      l = convertToPercentage(color.l);\n      rgb = hslToRgb(color.h, s, l);\n      ok = true;\n      format = \"hsl\";\n    }\n\n    if (color.hasOwnProperty(\"a\")) {\n      a = color.a;\n    }\n  }\n\n  a = boundAlpha(a);\n\n  return {\n    ok: ok,\n    format: color.format || format,\n    r: Math.min(255, Math.max(rgb.r, 0)),\n    g: Math.min(255, Math.max(rgb.g, 0)),\n    b: Math.min(255, Math.max(rgb.b, 0)),\n    a: a,\n  };\n}\n\n// Conversion Functions\n// --------------------\n\n// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:\n// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n\n// `rgbToRgb`\n// Handle bounds / percentage checking to conform to CSS color spec\n// <http://www.w3.org/TR/css3-color/>\n// *Assumes:* r, g, b in [0, 255] or [0, 1]\n// *Returns:* { r, g, b } in [0, 255]\nfunction rgbToRgb(r, g, b) {\n  return {\n    r: bound01(r, 255) * 255,\n    g: bound01(g, 255) * 255,\n    b: bound01(b, 255) * 255,\n  };\n}\n\n// `rgbToHsl`\n// Converts an RGB color value to HSL.\n// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n// *Returns:* { h, s, l } in [0,1]\nfunction rgbToHsl(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    l = (max + min) / 2;\n\n  if (max == min) {\n    h = s = 0; // achromatic\n  } else {\n    var d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n\n    h /= 6;\n  }\n\n  return { h: h, s: s, l: l };\n}\n\n// `hslToRgb`\n// Converts an HSL color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hslToRgb(h, s, l) {\n  var r, g, b;\n\n  h = bound01(h, 360);\n  s = bound01(s, 100);\n  l = bound01(l, 100);\n\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n\n  return { r: r * 255, g: g * 255, b: b * 255 };\n}\n\n// `rgbToHsv`\n// Converts an RGB color value to HSV\n// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n// *Returns:* { h, s, v } in [0,1]\nfunction rgbToHsv(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    v = max;\n\n  var d = max - min;\n  s = max === 0 ? 0 : d / max;\n\n  if (max == min) {\n    h = 0; // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return { h: h, s: s, v: v };\n}\n\n// `hsvToRgb`\n// Converts an HSV color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hsvToRgb(h, s, v) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s, 100);\n  v = bound01(v, 100);\n\n  var i = Math.floor(h),\n    f = h - i,\n    p = v * (1 - s),\n    q = v * (1 - f * s),\n    t = v * (1 - (1 - f) * s),\n    mod = i % 6,\n    r = [v, q, p, p, t, v][mod],\n    g = [t, v, v, q, p, p][mod],\n    b = [p, p, t, v, v, q][mod];\n\n  return { r: r * 255, g: g * 255, b: b * 255 };\n}\n\n// `rgbToHex`\n// Converts an RGB color to hex\n// Assumes r, g, and b are contained in the set [0, 255]\n// Returns a 3 or 6 character hex\nfunction rgbToHex(r, g, b, allow3Char) {\n  var hex = [\n    pad2(Math.round(r).toString(16)),\n    pad2(Math.round(g).toString(16)),\n    pad2(Math.round(b).toString(16)),\n  ];\n\n  // Return a 3 character hex if possible\n  if (\n    allow3Char &&\n    hex[0].charAt(0) == hex[0].charAt(1) &&\n    hex[1].charAt(0) == hex[1].charAt(1) &&\n    hex[2].charAt(0) == hex[2].charAt(1)\n  ) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n  }\n\n  return hex.join(\"\");\n}\n\n// `rgbaToHex`\n// Converts an RGBA color plus alpha transparency to hex\n// Assumes r, g, b are contained in the set [0, 255] and\n// a in [0, 1]. Returns a 4 or 8 character rgba hex\nfunction rgbaToHex(r, g, b, a, allow4Char) {\n  var hex = [\n    pad2(Math.round(r).toString(16)),\n    pad2(Math.round(g).toString(16)),\n    pad2(Math.round(b).toString(16)),\n    pad2(convertDecimalToHex(a)),\n  ];\n\n  // Return a 4 character hex if possible\n  if (\n    allow4Char &&\n    hex[0].charAt(0) == hex[0].charAt(1) &&\n    hex[1].charAt(0) == hex[1].charAt(1) &&\n    hex[2].charAt(0) == hex[2].charAt(1) &&\n    hex[3].charAt(0) == hex[3].charAt(1)\n  ) {\n    return (\n      hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0)\n    );\n  }\n\n  return hex.join(\"\");\n}\n\n// `rgbaToArgbHex`\n// Converts an RGBA color to an ARGB Hex8 string\n// Rarely used, but required for \"toFilter()\"\nfunction rgbaToArgbHex(r, g, b, a) {\n  var hex = [\n    pad2(convertDecimalToHex(a)),\n    pad2(Math.round(r).toString(16)),\n    pad2(Math.round(g).toString(16)),\n    pad2(Math.round(b).toString(16)),\n  ];\n\n  return hex.join(\"\");\n}\n\n// `equals`\n// Can be called with any tinycolor input\ntinycolor.equals = function (color1, color2) {\n  if (!color1 || !color2) return false;\n  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();\n};\n\ntinycolor.random = function () {\n  return tinycolor.fromRatio({\n    r: Math.random(),\n    g: Math.random(),\n    b: Math.random(),\n  });\n};\n\n// Modification Functions\n// ----------------------\n// Thanks to less.js for some of the basics here\n// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>\n\nfunction desaturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s -= amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\n\nfunction saturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s += amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\n\nfunction greyscale(color) {\n  return tinycolor(color).desaturate(100);\n}\n\nfunction lighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l += amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\n\nfunction brighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var rgb = tinycolor(color).toRgb();\n  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));\n  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));\n  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));\n  return tinycolor(rgb);\n}\n\nfunction darken(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l -= amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\n\n// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n// Values outside of this range will be wrapped into this range.\nfunction spin(color, amount) {\n  var hsl = tinycolor(color).toHsl();\n  var hue = (hsl.h + amount) % 360;\n  hsl.h = hue < 0 ? 360 + hue : hue;\n  return tinycolor(hsl);\n}\n\n// Combination Functions\n// ---------------------\n// Thanks to jQuery xColor for some of the ideas behind these\n// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>\n\nfunction complement(color) {\n  var hsl = tinycolor(color).toHsl();\n  hsl.h = (hsl.h + 180) % 360;\n  return tinycolor(hsl);\n}\n\nfunction polyad(color, number) {\n  if (isNaN(number) || number <= 0) {\n    throw new Error(\"Argument to polyad must be a positive number\");\n  }\n  var hsl = tinycolor(color).toHsl();\n  var result = [tinycolor(color)];\n  var step = 360 / number;\n  for (var i = 1; i < number; i++) {\n    result.push(tinycolor({ h: (hsl.h + i * step) % 360, s: hsl.s, l: hsl.l }));\n  }\n\n  return result;\n}\n\nfunction splitcomplement(color) {\n  var hsl = tinycolor(color).toHsl();\n  var h = hsl.h;\n  return [\n    tinycolor(color),\n    tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l }),\n    tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l }),\n  ];\n}\n\nfunction analogous(color, results, slices) {\n  results = results || 6;\n  slices = slices || 30;\n\n  var hsl = tinycolor(color).toHsl();\n  var part = 360 / slices;\n  var ret = [tinycolor(color)];\n\n  for (hsl.h = (hsl.h - ((part * results) >> 1) + 720) % 360; --results; ) {\n    hsl.h = (hsl.h + part) % 360;\n    ret.push(tinycolor(hsl));\n  }\n  return ret;\n}\n\nfunction monochromatic(color, results) {\n  results = results || 6;\n  var hsv = tinycolor(color).toHsv();\n  var h = hsv.h,\n    s = hsv.s,\n    v = hsv.v;\n  var ret = [];\n  var modification = 1 / results;\n\n  while (results--) {\n    ret.push(tinycolor({ h: h, s: s, v: v }));\n    v = (v + modification) % 1;\n  }\n\n  return ret;\n}\n\n// Utility Functions\n// ---------------------\n\ntinycolor.mix = function (color1, color2, amount) {\n  amount = amount === 0 ? 0 : amount || 50;\n\n  var rgb1 = tinycolor(color1).toRgb();\n  var rgb2 = tinycolor(color2).toRgb();\n\n  var p = amount / 100;\n\n  var rgba = {\n    r: (rgb2.r - rgb1.r) * p + rgb1.r,\n    g: (rgb2.g - rgb1.g) * p + rgb1.g,\n    b: (rgb2.b - rgb1.b) * p + rgb1.b,\n    a: (rgb2.a - rgb1.a) * p + rgb1.a,\n  };\n\n  return tinycolor(rgba);\n};\n\n// Readability Functions\n// ---------------------\n// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)\n\n// `contrast`\n// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)\ntinycolor.readability = function (color1, color2) {\n  var c1 = tinycolor(color1);\n  var c2 = tinycolor(color2);\n  return (\n    (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) /\n    (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05)\n  );\n};\n\n// `isReadable`\n// Ensure that foreground and background color combinations meet WCAG2 guidelines.\n// The third argument is an optional Object.\n//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';\n//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.\n// If the entire object is absent, isReadable defaults to {level:\"AA\",size:\"small\"}.\n\n// *Example*\n//    tinycolor.isReadable(\"#000\", \"#111\") => false\n//    tinycolor.isReadable(\"#000\", \"#111\",{level:\"AA\",size:\"large\"}) => false\ntinycolor.isReadable = function (color1, color2, wcag2) {\n  var readability = tinycolor.readability(color1, color2);\n  var wcag2Parms, out;\n\n  out = false;\n\n  wcag2Parms = validateWCAG2Parms(wcag2);\n  switch (wcag2Parms.level + wcag2Parms.size) {\n    case \"AAsmall\":\n    case \"AAAlarge\":\n      out = readability >= 4.5;\n      break;\n    case \"AAlarge\":\n      out = readability >= 3;\n      break;\n    case \"AAAsmall\":\n      out = readability >= 7;\n      break;\n  }\n  return out;\n};\n\n// `mostReadable`\n// Given a base color and a list of possible foreground or background\n// colors for that base, returns the most readable color.\n// Optionally returns Black or White if the most readable color is unreadable.\n// *Example*\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:false}).toHexString(); // \"#112255\"\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:true}).toHexString();  // \"#ffffff\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"large\"}).toHexString(); // \"#faf3f3\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"small\"}).toHexString(); // \"#ffffff\"\ntinycolor.mostReadable = function (baseColor, colorList, args) {\n  var bestColor = null;\n  var bestScore = 0;\n  var readability;\n  var includeFallbackColors, level, size;\n  args = args || {};\n  includeFallbackColors = args.includeFallbackColors;\n  level = args.level;\n  size = args.size;\n\n  for (var i = 0; i < colorList.length; i++) {\n    readability = tinycolor.readability(baseColor, colorList[i]);\n    if (readability > bestScore) {\n      bestScore = readability;\n      bestColor = tinycolor(colorList[i]);\n    }\n  }\n\n  if (\n    tinycolor.isReadable(baseColor, bestColor, {\n      level: level,\n      size: size,\n    }) ||\n    !includeFallbackColors\n  ) {\n    return bestColor;\n  } else {\n    args.includeFallbackColors = false;\n    return tinycolor.mostReadable(baseColor, [\"#fff\", \"#000\"], args);\n  }\n};\n\n// Big List of Colors\n// ------------------\n// <https://www.w3.org/TR/css-color-4/#named-colors>\nvar names = (tinycolor.names = {\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\",\n});\n\n// Make it easy to access colors via `hexNames[hex]`\nvar hexNames = (tinycolor.hexNames = flip(names));\n\n// Utilities\n// ---------\n\n// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`\nfunction flip(o) {\n  var flipped = {};\n  for (var i in o) {\n    if (o.hasOwnProperty(i)) {\n      flipped[o[i]] = i;\n    }\n  }\n  return flipped;\n}\n\n// Return a valid alpha value [0,1] with all invalid values being set to 1\nfunction boundAlpha(a) {\n  a = parseFloat(a);\n\n  if (isNaN(a) || a < 0 || a > 1) {\n    a = 1;\n  }\n\n  return a;\n}\n\n// Take input from [0, n] and return it as [0, 1]\nfunction bound01(n, max) {\n  if (isOnePointZero(n)) n = \"100%\";\n\n  var processPercent = isPercentage(n);\n  n = Math.min(max, Math.max(0, parseFloat(n)));\n\n  // Automatically convert percentage into number\n  if (processPercent) {\n    n = parseInt(n * max, 10) / 100;\n  }\n\n  // Handle floating point rounding errors\n  if (Math.abs(n - max) < 0.000001) {\n    return 1;\n  }\n\n  // Convert into [0, 1] range if it isn't already\n  return (n % max) / parseFloat(max);\n}\n\n// Force a number between 0 and 1\nfunction clamp01(val) {\n  return Math.min(1, Math.max(0, val));\n}\n\n// Parse a base-16 hex value into a base-10 integer\nfunction parseIntFromHex(val) {\n  return parseInt(val, 16);\n}\n\n// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\nfunction isOnePointZero(n) {\n  return typeof n == \"string\" && n.indexOf(\".\") != -1 && parseFloat(n) === 1;\n}\n\n// Check to see if string passed in is a percentage\nfunction isPercentage(n) {\n  return typeof n === \"string\" && n.indexOf(\"%\") != -1;\n}\n\n// Force a hex value to have 2 characters\nfunction pad2(c) {\n  return c.length == 1 ? \"0\" + c : \"\" + c;\n}\n\n// Replace a decimal with it's percentage value\nfunction convertToPercentage(n) {\n  if (n <= 1) {\n    n = n * 100 + \"%\";\n  }\n\n  return n;\n}\n\n// Converts a decimal to a hex value\nfunction convertDecimalToHex(d) {\n  return Math.round(parseFloat(d) * 255).toString(16);\n}\n// Converts a hex value to a decimal\nfunction convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\n\nvar matchers = (function () {\n  // <http://www.w3.org/TR/css3-values/#integers>\n  var CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\n\n  // <http://www.w3.org/TR/css3-values/#number-value>\n  var CSS_NUMBER = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\n\n  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.\n  var CSS_UNIT = \"(?:\" + CSS_NUMBER + \")|(?:\" + CSS_INTEGER + \")\";\n\n  // Actual matching.\n  // Parentheses and commas are optional, but not required.\n  // Whitespace can take the place of commas or opening paren\n  var PERMISSIVE_MATCH3 =\n    \"[\\\\s|\\\\(]+(\" +\n    CSS_UNIT +\n    \")[,|\\\\s]+(\" +\n    CSS_UNIT +\n    \")[,|\\\\s]+(\" +\n    CSS_UNIT +\n    \")\\\\s*\\\\)?\";\n  var PERMISSIVE_MATCH4 =\n    \"[\\\\s|\\\\(]+(\" +\n    CSS_UNIT +\n    \")[,|\\\\s]+(\" +\n    CSS_UNIT +\n    \")[,|\\\\s]+(\" +\n    CSS_UNIT +\n    \")[,|\\\\s]+(\" +\n    CSS_UNIT +\n    \")\\\\s*\\\\)?\";\n\n  return {\n    CSS_UNIT: new RegExp(CSS_UNIT),\n    rgb: new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n    rgba: new RegExp(\"rgba\" + PERMISSIVE_MATCH4),\n    hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n    hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n    hsv: new RegExp(\"hsv\" + PERMISSIVE_MATCH3),\n    hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n  };\n})();\n\n// `isValidCSSUnit`\n// Take in a single string / number and check to see if it looks like a CSS unit\n// (see `matchers` above for definition).\nfunction isValidCSSUnit(color) {\n  return !!matchers.CSS_UNIT.exec(color);\n}\n\n// `stringInputToObject`\n// Permissive string parsing.  Take in a number of formats, and output an object\n// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\nfunction stringInputToObject(color) {\n  color = color.replace(trimLeft, \"\").replace(trimRight, \"\").toLowerCase();\n  var named = false;\n  if (names[color]) {\n    color = names[color];\n    named = true;\n  } else if (color == \"transparent\") {\n    return { r: 0, g: 0, b: 0, a: 0, format: \"name\" };\n  }\n\n  // Try to match string input using regular expressions.\n  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n  // Just return an object and let the conversion functions handle that.\n  // This way the result will be the same whether the tinycolor is initialized with string or object.\n  var match;\n  if ((match = matchers.rgb.exec(color))) {\n    return { r: match[1], g: match[2], b: match[3] };\n  }\n  if ((match = matchers.rgba.exec(color))) {\n    return { r: match[1], g: match[2], b: match[3], a: match[4] };\n  }\n  if ((match = matchers.hsl.exec(color))) {\n    return { h: match[1], s: match[2], l: match[3] };\n  }\n  if ((match = matchers.hsla.exec(color))) {\n    return { h: match[1], s: match[2], l: match[3], a: match[4] };\n  }\n  if ((match = matchers.hsv.exec(color))) {\n    return { h: match[1], s: match[2], v: match[3] };\n  }\n  if ((match = matchers.hsva.exec(color))) {\n    return { h: match[1], s: match[2], v: match[3], a: match[4] };\n  }\n  if ((match = matchers.hex8.exec(color))) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4]),\n      format: named ? \"name\" : \"hex8\",\n    };\n  }\n  if ((match = matchers.hex6.exec(color))) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      format: named ? \"name\" : \"hex\",\n    };\n  }\n  if ((match = matchers.hex4.exec(color))) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      a: convertHexToDecimal(match[4] + \"\" + match[4]),\n      format: named ? \"name\" : \"hex8\",\n    };\n  }\n  if ((match = matchers.hex3.exec(color))) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      format: named ? \"name\" : \"hex\",\n    };\n  }\n\n  return false;\n}\n\nfunction validateWCAG2Parms(parms) {\n  // return valid WCAG2 parms for isReadable.\n  // If input parms are invalid, return {\"level\":\"AA\", \"size\":\"small\"}\n  var level, size;\n  parms = parms || { level: \"AA\", size: \"small\" };\n  level = (parms.level || \"AA\").toUpperCase();\n  size = (parms.size || \"small\").toLowerCase();\n  if (level !== \"AA\" && level !== \"AAA\") {\n    level = \"AA\";\n  }\n  if (size !== \"small\" && size !== \"large\") {\n    size = \"small\";\n  }\n  return { level: level, size: size };\n}\n"],"mappings":";;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AA3DA;AAAA;AA6DA;AACA;AACA;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAGA;AACA;AACA;AAGA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1iCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7FA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjvBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAIA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AADA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;ACtTA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAGA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACx0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAYA;AACA;AAEA;AACA;AACA;AAaA;AACA;AAEA;AACA;AACA;AASA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAlBA;AAAA;AAmBA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAeA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AASA;AACA;AACA;AASA;AACA;AASA;AAAA;AACA;AASA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAzCA;AACA;AAKA;AACA;AAsCA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAHA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAvCA;AACA;AACA;AACA;AACA;AAuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC9kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AA1BA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAjBA;AACA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvEA;AAAA;AAwEA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AApRA;AACA;AAgBA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAFA;;;;;;;;;;;;AC3oCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAKA;AAEA;AAGA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpdA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAFA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAAA;AA9BA;AAAA;AAgCA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;ACjzBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClIA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;AC/LA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AC/MA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACXA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAOA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;;;;A","sourceRoot":""}